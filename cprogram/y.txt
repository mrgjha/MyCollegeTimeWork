listing 1
int i, j, k;

char ch, chr;

float f, balance;

double d;

listing 2
#include <iostream>
using namespace std;

void func();

int main()
{
  int x; // local to main()

  x = 10;
  func(); 
  cout << "\n";
  cout << x; // displays 10

  return 0;
}

void func()
{
  int x; // local to func()

  x = -199;
  cout << x; // displays -199
}

listing 3
int func1(int first, int last, char ch)
{
  .
  .
  .
}

listing 4
#include <iostream>
using namespace std;

void func1();
void func2();

int count; // this is a global variable 

int main()
{
  int i; // this is a local variable 

  for(i=0; i<10; i++) {
    count = i * 2;
    func1();
  }

  return 0;
}

void func1()
{
  cout << "count: " << count; // access global count
  cout << '\n'; // output a newline
  func2();
}

void func2()
{
  int count; // this is a local variable

  for(count=0; count<3; count++) cout << '.';
}

listing 5
#include <iostream>
using namespace std;

/* This program shows the difference between 
   signed and unsigned integers.
*/
int main()
{
  short int i; // a signed short integer
  short unsigned int j; // an unsigned short integer

  j = 60000;
  i = j;
  cout << i << " " << j;

  return 0;
}

listing 6
unsigned x;
unsigned int y;

listing 7
// This program prints the alphabet in reverse order.

#include <iostream>
using namespace std;

int main()
{
  char letter;

  for(letter = 'Z'; letter >= 'A'; letter--)
    cout << letter;

  return 0;
}

listing 8
ch = 'Z';

listing 9
wchar_t wc;
wc = L'A';

listing 10
hex = 0xFF; // 255 in decimal
oct = 011; // 9 in decimal

listing 11
#include <iostream>
using namespace std;

int main()
{
  cout << "\n\\\b";

  return 0;
}

listing 12
char ch = 'a';
int first = 0;
float balance = 123.23F;

listing 13
// An example that uses variable initialization. 

#include <iostream> 
using namespace std; 
 
void total(int x); 

int main() 
{ 
  cout << "Computing summation of 5.\n";
  total(5); 

  cout << "\nComputing summation of 6.\n";
  total(6); 
 
  return 0; 
} 
 
void total(int x) 
{ 
  int sum=0; // initialize sum 
  int i, count; 
 
  for(i=1; i<=x; i++) { 
    sum = sum + i; 
    for(count=0; count<10; count++) cout << '.'; 
    cout << "The current sum is " << sum << '\n'; 
  } 
}

listing 14
#include <iostream>
using namespace std;

int main()
{
  int x, y;

  x = 10;
  y = 3;
  cout << x/y; // will display 3
  cout << "\n";
  cout << x%y; /* will display 1, the remainder of
                  the integer division */
  cout << "\n";

  x = 1;
  y = 2;
  cout << x/y << " " << x%y; // will display 0 1

  return 0;
}

listing 15
x = x+1;

listing 16
++x;

listing 17
x = x-1;

listing 18
--x;

listing 19
x = x+1; 

listing 20
++x; // prefix form

listing 21
x++; // postfix form

listing 22
x = 10;
y = ++x;

listing 23
x = 10;
y = x++;

listing 24
bool xor(bool a, bool b)
{
  return (a || b) && !(a && b);
}

listing 25
// This program demonstrates the xor() function.
#include <iostream>
using namespace std;

bool xor(bool a, bool b);

int main()
{
  bool p, q;

  cout << "Enter P (0 or 1): ";
  cin >> p;
  cout << "Enter Q (0 or 1): ";
  cin >> q;

  cout << "P AND Q: " << (p && q) << '\n';
  cout << "P OR Q: " << (p || q) << '\n';
  cout << "P XOR Q: " << xor(p, q) << '\n'; 

  return 0;
}

bool xor(bool a, bool b)
{
  return (a || b) && !(a && b);
}

listing 26
var>15 || !(10<count) && 3<=item

listing 28
(float) x / 2

listing 29
#include <iostream>
using namespace std;

int main() // print i and i/2 with fractions
{
  int i;

  for(i=1; i<=100; ++i )
    cout << i << "/ 2 is: " << (float) i / 2 << '\n';

  return 0;
}

listing 30
x=10/y*(127/x);

x = 10 / y * (127/x);

listing 31
x = y/3-34*temp+127;

x = (y/3) - (34*temp) + 127;




listing 1
// Magic Number program.
#include <iostream>
#include <cstdlib>
using namespace std;

int main()
{
  int magic;  // magic number
  int guess;  // user's guess

  magic = rand(); // get a random number
  
  cout << "Enter your guess: ";
  cin >> guess;

  if(guess == magic) cout << "** Right **";

  return 0;
}

listing 2
// Magic Number program: 1st improvement.

#include <iostream>
#include <cstdlib>
using namespace std;

int main()
{
  int magic;  // magic number
  int guess;  // user's guess

  magic = rand(); // get a random number
  
  cout << "Enter your guess: ";
  cin >> guess;

  if(guess == magic) cout << "** Right **";
  else cout << "...Sorry, you're wrong.";

  return 0;
}

listing 3
// Divide the first number by the second.

#include <iostream>
using namespace std;

int main()
{
  int a, b;

  cout << "Enter two numbers: ";
  cin >> a >> b;

  if(b) cout << a/b << '\n';
  else cout << "Cannot divide by zero.\n";

  return 0;
}

listing 4
if(b == 0) cout << a/b << '\n';

listing 5
if(i) {
  if(j) statement1;
  if(k) statement2; // this if
  else statement3; // is associated with this else
}
else statement4; // associated with if(i)

listing 6
// Magic Number program: 2nd improvement.

#include <iostream>
#include <cstdlib>
using namespace std;

int main()
{
  int magic;  // magic number
  int guess;  // user's guess 

  magic = rand(); // get a random number
  
  cout << "Enter your guess: ";
  cin >> guess;

  if (guess == magic) {
    cout << "** Right **\n";
    cout << magic << " is the magic number.\n";
  }
  else {
    cout << "...Sorry, you're wrong.";
    if(guess > magic) cout <<" Your guess is too high.\n";
    else cout << " Your guess is too low.\n";
  }

  return 0;
}

listing 7
// Demonstrate an if-else-if ladder.
#include <iostream>
using namespace std;

int main()
{
  int x;

  for(x=0; x<6; x++) {
    if(x==1) cout << "x is one\n";
    else if(x==2) cout << "x is two\n";
    else if(x==3) cout << "x is three\n";
    else if(x==4) cout << "x is four\n";
    else cout << "x is not between 1 and 4\n";
  }

  return 0;
}

listing 8
#include <iostream>
#include <cmath>
using namespace std;

int main()
{
  int num;
  double sq_root;

  for(num=1; num < 100; num++) {
    sq_root = sqrt((double) num);
    cout << num << " " << sq_root << '\n';
  }

  return 0;
}

listing 9
#include <iostream>
using namespace std;

int main()
{
  int i;

  for(i=100; i >= -100; i = i-5) cout << i << ' ';

  return 0;
}

listing 10
for(count=10; count < 5; count++)
  cout << count; // this statement will not execute

listing 11
for(x=0, y=10; x<=10; ++x, --y) 
  cout << x << ' ' << y << '\n';

listing 12
#include <iostream>
#include <conio.h>
using namespace std;

int main()
{
  int i;

  // print numbers until a key is pressed
  for(i=0; !kbhit(); i++) cout << i << ' ';

  return 0;
}

listing 13
#include <iostream>
using namespace std;

int main()
{
  int x;

  for(x=0; x != 123; ) {
    cout << "Enter a number: ";
    cin >> x;
  }

  return 0;
}

listing 14
cout << "Enter tab position: ";
cin >> x;

for( ; x < tablimit; x++) cout << ' ';

listing 15
for(;;)
{
  //...
}

listing 16
for(x=0; x<1000; x++) ;

listing 17
// Demonstrate the switch using a simple "help" program.
#include <iostream>
using namespace std;

int main()
{
  int choice;

  cout << "Help on:\n\n";
  cout << "1. for\n";
  cout << "2. if\n";
  cout << "3. switch\n\n";
  
  cout << "Enter choice (1-3): ";
  cin >> choice;
  cout << "\n";

  switch(choice) {
    case 1: 
      cout << "for is C++'s most versatile loop.\n";
      break;
    case 2: 
      cout << "if is C++'s conditional branch statement.\n";
      break;
    case 3:
      cout << "switch is C++'s multi-way branch statement.\n";
      break;
    default: 
      cout << "You must enter a number between 1 and 3.\n";
  }

  return 0;
}

listing 18
#include <iostream>
using namespace std;

int main()
{
  int i;

  for(i=0; i<5; i++) {
    switch(i) {
      case 0: cout << "less than 1\n";
      case 1: cout << "less than 2\n";
      case 2: cout << "less than 3\n";
      case 3: cout << "less than 4\n";
      case 4: cout << "less than 5\n";
    }
    cout << '\n';
  }

  return 0;
}

listing 19
switch(i) {
  case 1:
  case 2:
  case 3: do_something();
    break;
  case 4: do_something_else();
    break;

listing 20
switch(ch1) {
  case 'A': cout << "This A is part of outer switch";
    switch(ch2) {
      case 'A': 
        cout << "This A is part of inner switch";
        break;
      case 'B': // ...
    }
    break;
  case 'B': // ...

listing 21
/* This program displays all printable characters,
   including the extended character set, if one exists.
*/

#include <iostream>
using namespace std;

int main()
{
  unsigned char ch;

  ch = 32;
  while(ch) {
    cout << ch;
    ch++;
  }

  return 0;
}

listing 22
#include <iostream>
using namespace std;

int main()
{
  int len;

  cout << "Enter length (1 to 79): ";
  cin >> len;

  while(len>0 && len<80)  {
    cout << '.';
    len--;
  }

  return 0;
}

listing 23
while(rand() != 100) ;

listing 24
#include <iostream>
using namespace std;

int main()
{
  int num;

  do {
    cout << "Enter a number (100 to stop): ";
    cin >> num;
  } while(num != 100);

  return 0;
}

listing 25
// Magic Number program: 3rd improvement. 

#include <iostream>
#include <cstdlib>
using namespace std;

int main()
{
  int magic; // magic number
  int guess; // user's guess

  magic = rand(); // get a random number
  
  do {
    cout << "Enter your guess: ";
    cin >> guess;
    if(guess == magic) {
      cout << "** Right ** ";
      cout << magic << " is the magic number.\n";
    }
    else {
      cout << "...Sorry, you're wrong.";
      if(guess > magic)
         cout << " Your guess is too high.\n";
      else cout << " Your guess is too low.\n";
    }
  } while(guess != magic);

  return 0;
}

listing 26
#include <iostream>
using namespace std;

int main()
{
  int x;

  for(x=0; x<=100; x++) {
    if(x%2) continue;
    cout << x << ' ';
  }

  return 0;
}

listing 27
#include <iostream>
using namespace std;

int main()
{
  int t;

  // Loops from 0 to 9, not to 100!
  for(t=0; t<100; t++) {
    if(t==10) break;
    cout << t << ' ';
  }

  return 0;
}

listing 28
for(i=0; i<1000; i++) {
  // do something
  if(kbhit()) break;
}

listing 29
#include <iostream>
using namespace std;

int main()
{
  int t, count; 

  for(t=0; t<100; t++) {
    count = 1;
    for(;;) {
      cout << count << ' ';
      count++;
      if(count==10) break;
    } 
    cout << '\n';
  }

  return 0;
}

listing 30
/* This program finds the prime numbers from  
   2 to 1000.
*/

#include <iostream>
using namespace std;

int main()
{
  int i, j;

  for(i=2; i<1000; i++) {
    for(j=2; j <= (i/j); j++)
      if(!(i%j)) break; // if factor found, not prime
    if(j > (i/j)) cout << i << " is prime\n";
  }

  return 0;
}

listing 31
x = 1;
  loop1:
    x++;
    if(x < 100) goto loop1;

listing 32
for(...) {
  for(...) {
    while(...) {
      if(...) goto stop;
      .
      .
      .
    }
  }
}
stop:
  cout << "Error in program.\n";

listing 33
// Magic Number program: Final improvement.

#include <iostream>
#include <cstdlib>
using namespace std;

void play(int m);

int main()
{    
  int option;
  int magic;

  magic = rand();

  do {
    cout << "1. Get a new magic number\n";
    cout << "2. Play\n";
    cout << "3. Quit\n";
    do {
      cout << "Enter your choice: ";
      cin >> option;
    } while(option<1 || option>3);

    switch(option) {
      case  1:
        magic = rand();
        break;
      case 2:
        play(magic);
        break;
      case 3:
        cout << "Goodbye\n";
        break;
    }
  } while(option!=3);

  return 0;
}

// Play the game.
void play(int m)
{
  int t, x;

  for(t=0; t<100; t++) {
    cout << "Guess the number: ";
    cin >> x;
    if(x==m) {
      cout << "** Right **\n";
      return;
    }
    else
      if(x<m) cout << "Too low.\n";
      else cout << "Too high.\n";    
  }
  cout << "You've used up all your guesses. Try again.\n";
}


listing 1
int sample[10];

listing 2
#include <iostream>
using namespace std;

int main()
{
  int sample[10]; // this reserves 10 integer elements
  int t;

  // load the array
  for(t=0; t<10; ++t) sample[t]=t;

  // display the array
  for(t=0; t<10; ++t) cout << sample[t] << ' ';

  return 0;
}

listing 3
#include <iostream>
#include <cstdlib>
using namespace std;

int main()
{
  int i, min_value, max_value;
  int list[10];

  for(i=0; i<10; i++) list[i] = rand();

  // find minimum value   
  min_value = list[0];
  for(i=1; i<10; i++) 
    if(min_value > list[i]) min_value = list[i];

  cout << "minimum value: " << min_value << '\n';

  // find maximum value
  max_value = list[0];
  for(i=1; i<10; i++) 
    if(max_value < list[i]) max_value = list[i];

  cout << "maximum value: " <<  max_value << '\n';

  return 0;
}

listing 4
int a[10], b[10];

// ...

a = b; // error -- illegal

listing 5
// An incorrect program.  Do Not Execute!

int main()
{
  int crash[10], i;

  for(i=0; i<100; i++) crash[i]=i;

  return 1;
}

listing 6
// Using the bubble sort to order an array.
#include <iostream>
#include <cstdlib>
using namespace std;

int main()
{
  int nums[10];
  int a, b, t;
  int size;

  size = 10; // number of elements to sort

  // give the array some random initial values
  for(t=0; t<size; t++) nums[t] = rand();

  // display original array
  cout << "Original array is: ";
  for(t=0; t<size; t++) cout << nums[t] << ' ';
  cout << '\n';

  // This is the bubble sort.
  for(a=1; a<size; a++)
    for(b=size-1; b>=a; b--) {
      if(nums[b-1] > nums[b]) { // if out of order
        // exchange elements 
        t = nums[b-1];
        nums[b-1] = nums[b];
        nums[b] = t;
      }
    }
  // This is the end of the bubble sort.

  // display sorted array
  cout << "Sorted array is: ";
  for(t=0; t<size; t++) cout << nums[t] << ' ';

  return 0;
}

listing 7
char str[11];

listing 8
// Using cin to read a string from the keyboard.

#include <iostream>
using namespace std;

int main()
{
  char str[80];

  cout << "Enter a string: ";
  cin >> str; // read string from keyboard
  cout << "Here is your string: ";
  cout << str;

  return 0;
}

listing 9
// Using gets() to read a string from the keyboard.

#include <iostream>
#include <cstdio>
using namespace std;

int main()
{
  char str[80];

  cout << "Enter a string: ";
  gets(str); // read a string from the keyboard
  cout << "Here is your string: ";
  cout << str;

  return 0;
}

listing 10
#include <iostream>
#include <cstring>
using namespace std;

int main()
{
  char str[80];

  strcpy(str, "hello");
  cout << str;

  return 0;
}

listing 11
#include <iostream>
#include <cstring>
using namespace std;

int main()
{
  char s1[20], s2[10];

  strcpy(s1, "hello");
  strcpy(s2, " there");
  strcat(s1, s2);
  cout << s1;

  return 0;
}

listing 12
#include <iostream>
#include <cstring>
#include <cstdio>
using namespace std;

bool password();

int main()
{
  if(password()) cout << "Logged on.\n";
  else cout << "Access denied.\n";

  return 0;
}

// Return true if password accepted; false otherwise.
bool password()
{
  char s[80];

  cout << "Enter password: ";
  gets(s);

  if(strcmp(s, "password")) {  // strings differ
    cout << "Invalid password.\n";
    return false;
  }

  // strings compared the same 
  return true;
}

listing 13
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;

int main()
{
  char s[80];

  for(;;) {
    cout << "Enter a string: ";
    gets(s);
    if(!strcmp("quit", s)) break;
  }

  return 0;
}

listing 14
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;

int main()
{
  char str[80];

  cout << "Enter a string: ";

  gets(str);

  cout << "Length is: " <<  strlen(str);

  return 0;
}

listing 15
// Print a string backwards.
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;

int main()
{
  char str[80];
  int i;
 
  cout << "Enter a string: ";
  gets(str);

  for(i=strlen(str)-1; i>=0; i--) cout << str[i];

  return 0;
}

listing 16
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;

int main()
{
  char s1[80], s2[80];

  cout << "Enter two strings: ";

  gets(s1); gets(s2);

  cout << "lengths: " << strlen(s1);
  cout << ' ' << strlen(s2) << '\n';

  if(!strcmp(s1, s2)) 
     cout << "The strings are equal\n";
  else cout << "not equal\n";
  
  strcat(s1, s2);
  cout << s1 << '\n';

  strcpy(s1, s2);
  cout << s1 << " and " << s2 << ' ';
  cout << "are now the same\n";

  return 0;
}

listing 17
// Convert a string to uppercase. 
#include <iostream>
#include <cstring>
#include <cctype>
using namespace std;

int main()
{
  char str[80];
  int i;

  strcpy(str, "this is a test");

  for(i=0; str[i]; i++) str[i] = toupper(str[i]);

  cout << str;

  return 0;
}

listing 18
int twod[10][20];

listing 19
#include <iostream>
using namespace std;

int main()
{
  int t,i, num[3][4];

  for(t=0; t<3; ++t) {
    for(i=0; i<4; ++i) {
      num[t][i] = (t*4)+i+1;
      cout << num[t][i] << ' ';
    }
    cout << '\n';
  }

  return 0;
}

listing 20
int multidim[4][10][3];

listing 21
int i[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

listing 22
char str[6] = "hello";

listing 23
char str[6] = {'h', 'e', 'l', 'l', 'o', '\0'};

listing 24
int sqrs[10][2] = {
  1, 1,
  2, 4,
  3, 9,
  4, 16,
  5, 25,
  6, 36,
  7, 49,
  8, 64,
  9, 81,
  10, 100
};

listing 25
int sqrs[10][2] = {
  {1, 1},
  {2, 4},
  {3, 9},
  {4, 16},
  {5, 25},
  {6, 36},
  {7, 49},
  {8, 64},
  {9, 81},
  {10, 100}
};

listing 26
#include <iostream>
using namespace std;

int sqrs[10][2] = {
  {1, 1},
  {2, 4},
  {3, 9},
  {4, 16},
  {5, 25},
  {6, 36},
  {7, 49},
  {8, 64},
  {9, 81},
  {10, 100}
};

int main()
{
  int i, j;

  cout << "Enter a number between 1 and 10: ";
  cin >> i;

  // look up i
  for(j=0; j<10; j++) 
    if(sqrs[j][0]==i) break;
  cout << "The square of " << i << " is ";
  cout << sqrs[j][1];

  return 0;
}

listing 27
#include <iostream>
#include <cstring>
using namespace std;

void f1();

int main()
{
  f1(); 
  f1();

  return 0;
}

void f1()
{
  char s[80]="this is a test\n";

  cout << s;
  strcpy(s, "CHANGED\n"); // change s
  cout << s;
}

listing 28
char e1[14] = "Divide by 0\n";
char e2[23] = "End-of-File\n";
char e3[21] = "Access Denied\n";

listing 29
char e1[] = "Divide by 0\n";
char e2[] = "End-of-File\n"; 
char e3[] = "Access Denied\n";

listing 30
int sqrs[][2] = {
  1, 1,
  2, 4,
  3, 9,
  4, 16,
  5, 25,
  6, 36,
  7, 49,
  8, 64,
  9, 81,
  10, 100
};

listing 31
char str_array[30][80];

listing 32
gets(str_array[2]);

listing 33
// Enter and display strings.
#include <iostream>
#include <cstdio>
using namespace std;

int main()
{
  int t, i;
  char text[100][80];

  for(t=0; t<100; t++) {
    cout << t << ": ";
    gets(text[t]);
    if(!text[t][0]) break; // quit on blank line
  }

  // redisplay the strings
  for(i=0; i<t; i++) 
    cout << text[i] << '\n';

  return 0;
}

listing 34
char name[10][80];  // this array holds employee names
char phone[10][20]; // their phone numbers
float hours[10];    // hours worked per week
float wage[10];     // wage

listing 35
// Enter information.
void enter()
{
  int i;
  char temp[80];

  for(i=0; i<10; i++) {
    cout << "Enter last name: ";
    cin >> name[i];
    cout << "Enter phone number: ";
    cin >> phone[i];
    cout << "Enter number of hours worked: ";
    cin >> hours[i];
    cout << "Enter wage: ";
    cin >> wage[i];
  }
}

listing 36
// Display report.
void report()
{
  int i;

  for(i=0; i<10; i++) {
    cout << name[i] << ' ' << phone[i] << '\n';
    cout << "Pay for the week: " << wage[i] * hours[i];
    cout << '\n';
  }
}

listing 37
// A simple employee database program.

#include <iostream>
using namespace std;

char name[10][80];  // this array holds employee names
char phone[10][20]; // their phone numbers
float hours[10];    // hours worked per week
float wage[10];     // wage

int menu();
void enter(), report();

int main()
{
  int choice;

  do {
    choice = menu(); // get selection
    switch(choice) {
      case 0: break;
      case 1: enter();
        break;
      case 2: report();
        break;
      default: cout << "Try again.\n\n";
    }
  } while(choice != 0);

  return 0;
}

// Return a user's selection.
int menu()
{
  int choice;

  cout << "0. Quit\n";
  cout << "1. Enter information\n";
  cout << "2. Report information\n";
  cout << "\nChoose one: ";
  cin >> choice;

  return choice;
}

// Enter information.
void enter()
{
  int i;
  char temp[80];

  for(i=0; i<10; i++) {
    cout << "Enter last name: ";
    cin >> name[i];
    cout << "Enter phone number: ";
    cin >> phone[i];
    cout << "Enter number of hours worked: ";
    cin >> hours[i];
    cout << "Enter wage: ";
    cin >> wage[i];
  }
}

// Display report.
void report()
{
  int i;

  for(i=0; i<10; i++) {
    cout << name[i] << ' ' << phone[i] << '\n';
    cout << "Pay for the week: " << wage[i] * hours[i];
    cout << '\n';
  }
}


listing 1
int *p;

listing 2
float *p;

listing 3
int *ip; // pointer to integers

double *dp; // pointer to doubles

listing 4
balptr = &balance;

listing 5
value = *balptr;

listing 6
#include <iostream>
using namespace std;

int main()
{
  int balance;
  int *balptr;
  int value;

  balance = 3200;
  balptr = &balance;
  value = *balptr;
  cout << "balance is: " << value << '\n';

  return 0;
}

listing 7
int *p;
double f;
// ...
p = &f; // ERROR

listing 8
int *p ;
double f;
// ...
p = (int *) &f; // Now technically OK

listing 9
// This program will not work right.
#include <iostream>
using namespace std;

int main()
{
  double x, y;
  int *p; 

  x = 123.23;
  p = (int *) &x; // use cast to assign double * to int *

  y = *p; // What will this do?
  cout << y; // What will this print?

  return 0;
}

listing 10
*p = 101;

listing 11
(*p)++;

listing 12
#include <iostream>
using namespace std;

int main()
{
  int *p, num;

  p = &num;

  *p = 100;
  cout << num << ' ';
  (*p)++;
  cout << num << ' ';
  (*p)--;
  cout << num << '\n';

  return 0;
}

listing 13
p1++;

listing 14
p1--;

listing 15
p1 = p1 + 9;

listing 16
#include <iostream>
using namespace std;

int main()
{
  int *i, j[10];
  double *f, g[10];
  int x;

  i = j; 
  f = g; 

  for(x=0; x<10; x++) 
    cout << i+x << ' ' << f+x << '\n';    

  return 0;
}

listing 17
char str[80];
char *p1;

p1 = str;

listing 18
str[4]

listing 20
// Tokenizing program: pointer version.
#include <iostream>
#include <cstdio>
using namespace std;

int main()
{
  char str[80];
  char token[80];
  char *p, *q;

  cout << "Enter a sentence: ";
  gets(str);

  p = str;

  // Read a token at a time from the string.
  while(*p) {
    q = token;  // set q pointing to start of token

    /* Read characters until either a space or the
       null terminator is encountered. */
    while(*p!=' ' && *p) {
      *q = *p;
       q++; p++;
    }
    if(*p) p++; // advance past the space
    *q = '\0'; // null terminate the token
    cout << token << '\n';
  }

  return 0;
}

listing 21
// Tokenizing program: array-indexing version.
#include <iostream>
#include <cstdio>
using namespace std;

int main()
{
  char str[80];
  char token[80];
  int i, j;

  cout << "Enter a sentence: ";
  gets(str);

  // Read a token at a time from the string. 
  for(i=0; ; i++) {
    /* Read characters until either a space or the
       null terminator is encountered. */
    for(j=0; str[i]!=' ' && str[i]; j++, i++)
      token[j] = str[i];

    token[j] = '\0'; // null terminate the token
    cout << token << '\n';
    if(!str[i]) break;
  }

  return 0;
}

listing 22
// Indexing a pointer like an array.

#include <iostream>
#include <cctype>
using namespace std;

int main()
{
  char str[20] = "hello tom";
  char *p;
  int i;

  p = str;

  // index a pointer
  for(i=0; p[i]; i++) p[i] = toupper(p[i]);
  cout << p; // display the string

  return 0;
}

listing 23
int num[10];
int i;

for(i=0; i<10; i++) {
  *num = i; // this is OK
  num++; // ERROR -- cannot modify num
}

listing 24
*(num+3) = 100; // This is OK because num is not changed

listing 25
cout << strlen("C++ Compiler");

listing 26
#include <iostream>
using namespace std;

int main()
{
  char *s;

  s = "Pointers are fun to use.\n";

  cout << s;

  return 0;
}

listing 27
#include <iostream>
using namespace std;

int main()
{
  int num[10];
  int *start, *end;

  start = num;
  end = &num[9];

  while(start <= end) {
    cout << "Enter a number: ";
    cin >> *start;
    start++;
  }
  start = num;  /* reset the starting pointer */
  while(start <= end) {
    cout << *start << ' ';
    start++;
  }

  return 0; 
}

listing 28
int *pi[10];

listing 29
int var;

pi[2] = &var;

listing 30
*pi[2]

listing 31
char *fortunes[] = {
  "Soon, you will come into some money.\n",
  "A new love will enter your life.\n",
  "You will live long and prosper.\n",
  "Now is a good time to invest for the future.\n",
  "A close friend will ask for a favor.\n"
};

listing 32
cout << fortunes[1];

listing 33
#include <iostream>
#include <cstdlib>
#include <conio.h>
using namespace std;

char *fortunes[] = {
  "Soon, you will come into some money.\n",
  "A new love will enter your life.\n",
  "You will live long and prosper.\n",
  "Now is a good time to invest for the future.\n",
  "A close friend will ask for a favor.\n"
};

int main()
{
  int chance;

  cout << "To see your fortune, press a key: ";

  // randomize the random number generator 
  while(!kbhit()) rand();

  cout << '\n';

  chance = rand();
  chance = chance % 5;
  cout << fortunes[chance];

  return 0;
}

listing 34
// A simple C++ keyword synopsis program.

#include <iostream>
#include <cstring>
using namespace std;

char *keyword[][2] = {
  "for", "for(initialization; condition; increment)",
  "if", "if(condition) ... else ...",
  "switch", "switch(value) { case-list }",
  "while", "while(condition) ...",
  // add the rest of the C++ keywords here
  "", ""  // terminate the list with nulls 
};

int main()
{
  char str[80];
  int i;

  cout << "Enter keyword: ";
  cin >> str;

  // display syntax
  for(i=0; *keyword[i][0]; i++) 
    if(!strcmp(keyword[i][0], str))
      cout << keyword[i][1];

  return 0;
}

listing 35
float *p = 0; // p is now a null pointer

listing 36
if(p) // succeeds if p is not null

if(!p) // succeeds if p is null

listing 37
int **balance;

listing 38
// Multiple indirection.
#include <iostream>
using namespace std;

int main()
{
  int x, *p, **q;

  x = 10;
  p = &x;
  q = &p;

  cout << **q; // prints the value of x

  return 0;
}

listing 39
// This program is wrong.
int main(){
  int x, *p;

  x = 10;
  *p = x; // where does p point?

  return 0;
}

listing 40
char s[80];
char y[80];
char *p1, *p2;

p1 = s;
p2 = y;
if(p1 < p2) . . .

listing 41
int first[10];
int second[10];

int *p, t;

p = first;
for(t=0; t<20; ++t) {
  *p = t;
  p++;
}

listing 42
// This program is wrong.

#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;

int main()
{
  char s[80];
  char *p1;

  p1 = s;

  do {
    cout << "Enter a string: ";
    gets(p1); // read a string
    // print the ASCII values of each character
    while(*p1) cout << (int) *p1++ << ' ';
    cout << '\n';
  } while(strcmp(s, "done"));

  return 0;
}

listing 43
// This program is correct.

#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;

int main()
{
  char s[80];
  char *p1;

  do {
    p1 = s; // reset p1 each time through the loop

    cout << "Enter a string: ";
    gets(p1); // read a string 
    // print the ASCII values of each character
    while(*p1) cout << (int) *p1++ << ' ';
    cout << '\n';
  } while(strcmp(s, "done"));
  
  return 0;
}

listing 1
#include <iostream>
using namespace std;

void f1();

int main()
{
  char str[]="this is str in main()";

  cout << str << '\n';
  f1();
  cout << str << '\n';

  return 0;
}

void f1()
{
  char str[80];

  cout << "Enter something: ";
  cin >> str;
  cout << str << '\n';
}

listing 2
auto char ch;

listing 3
/* This program illustrates how variables can be
   local to a block.
*/

#include <iostream>
#include <cstring>
using namespace std;

int main()
{
  int choice;

  cout << "(1) add numbers or ";
  cout << "(2) concatenate strings?: ";

  cin >> choice;
  if(choice == 1) {
    int a, b;  /* activate two integer vars */
    cout << "Enter two numbers: ";
    cin >> a >> b;
    cout << "Sum is " << a+b << '\n';
  }
  else {
    char s1[80], s2[80];  /* activate two strings */
    cout << "Enter two strings: ";
    cin >> s1;
    cin >> s2;
    strcat(s1, s2);
    cout << "Concatenation is " << s1 << '\n';
  }

  return 0;
}

listing 4
/* This program is incorrect. */

#include <iostream>
#include <cstring>
using namespace std;

int main()
{
  int choice;

  cout << "(1) add numbers or ";
  cout << "(2) concatenate strings?: ";

  cin >> choice;
  if(choice == 1) {
    int a, b;  /* activate two integer vars */
    cout << "Enter two numbers: ";
    cin >> a >> b;
    cout << "Sum is " << a+b << '\n';
  }
  else {
    char s1[80], s2[80];  /* activate two strings */
    cout << "Enter two strings: ";
    cin >> s1;
    cin >> s2;
    strcat(s1, s2);
    cout << "Concatenation is " << s1 << '\n';
  }

  a = 10; // *** Error *** -- a not known here!

  return 0;
}

listing 5
#include <iostream>
using namespace std;

int main()
{
  int i, j;

  i = 10;
  j = 100;

  if(j > 0) {
    int i; // this i is separate from outer i
    
    i = j / 2;
    cout << "inner i: " << i << '\n';
  }

  cout << "outer i: " << i << '\n';

  return 0;
}

listing 6
#include <iostream>
using namespace std;

int main()
{
  cout << "Enter a number: ";
  int a; // declare one variable
  cin >> a;

  cout << "Enter a second number: ";
  int b; // declare another variable
  cin >> b;

  cout << "Product: " << a*b << '\n';

  return 0;
}

listing 7
#include <iostream>
using namespace std;

int main()
{
  // i is local to for
  for(int i = 0; i<10; i++) {
    cout << i << " ";
    cout << "squared is " << i * i << "\n";
  }

  // i = 10; // *** Error *** -- i not known here!

  return 0;
}

listing 8
if(int x = 20) {
  cout << "This is x: ";
  cout << x;
}

listing 9
// A simple addition drill program.

#include <iostream>
#include <cstdlib>
using namespace std;

void drill();

int count;  // count and num_right are global
int num_right;

int main()
{
  cout << "How many practice problems: ";
  cin >> count;

  num_right = 0;
  do {
    drill();
    count--;
  } while(count);
  cout << "You got " << num_right << " right.\n";

  return 0;
}

void drill()
{
  int count;  /* This count is local and unrelated to
                 the global one.
              */
  int a, b, ans;

  // Generate two numbers between 0 and 99.
  a = rand() % 100;  
  b = rand() % 100;

  // The user gets three tries to get it right.
  for(count=0; count<3; count++) {
    cout << "What is " << a << " + " << b << "? ";
    cin >> ans;
    if(ans==a+b) {
      cout << "Right\n";
      num_right++;
      return;
    }
  }  
  cout << "You've used up all your tries.\n";
  cout << "The answer is " << a+b << '\n';
}

listing 10
// Pass a pointer to a function.
#include <iostream>
using namespace std;

void f(int *j);

int main()
{
  int i;
  int *p;

  p = &i; // p now points to i

  f(p);

  cout << i;  // i is now 100

  return 0;
}
   
void f(int *j)
{
  *j = 100; // var pointed to by j is assigned 100
}

listing 11
// Pass a pointer to a function -- revised version.
#include <iostream>
using namespace std;

void f(int *j);

int main()
{
  int i;

  f(&i);

  cout << i;

  return 0;
}
   
void f(int *j)
{
  *j = 100; // var pointed to by j is assigned 100
}

listing 12
#include <iostream>
using namespace std;

void display(int num[10]);

int main()
{
  int t[10],i;

  for(i=0; i<10; ++i) t[i]=i;

  display(t); // pass array t to a function

  return 0;
}

// Print some numbers. 
void display(int num[10])
{
  int i;

  for(i=0; i<10; i++) cout << num[i] << ' ';
}

listing 13
void display(int num[])
{
  int i;

  for(i=0; i<10; i++) cout << num[i] << ' ';
}

listing 14
void display(int *num)
{
  int i;

  for(i=0; i<10; i++) cout << num[i] << ' ';
}

listing 15
#include <iostream>
using namespace std;

void display(int num);

int main()
{
  int t[10],i;

  for(i=0; i<10; ++i) t[i]=i;
  for(i=0; i<10; i++) display(t[i]);

  return 0;
}

// Print some numbers. 
void display(int num)
{
  cout << num << ' ';
}

listing 16
#include <iostream>
using namespace std;

void cube(int *n, int num);

int main()
{
  int i, nums[10];

  for(i=0; i<10; i++) nums[i] = i+1;
  cout << "Original contents: ";
  for(i=0; i<10; i++) cout << nums[i] << ' ';
  cout << '\n';

  cube(nums, 10); // compute cubes

  cout << "Altered contents: ";
  for(i=0; i<10; i++) cout << nums[i] << ' ';

  return 0;
}

void cube(int *n, int num)
{
  while(num) {
    *n = *n * *n * *n;
    num--;
    n++;
  }
}

listing 17
// Pass a string to a function.
#include <iostream>
#include <cstring>
#include <cctype>
using namespace std;

void stringupper(char *str);

int main()
{
  char str[80];

  strcpy(str, "this is a test");

  stringupper(str);
  cout << str; // display uppercase string
  return 0;
}
   
void stringupper(char *str)
{
  while(*str) {
    *str = toupper(*str); // uppercase one char
    str++; // move on to next char
  }
}

listing 18
// A custom version of strlen().
#include <iostream>
using namespace std;

int mystrlen(char *str);

int main()
{
  cout << "Length of Hello There is: ";
  cout << mystrlen("Hello There");

  return 0;
}

// A custom version of strlen().
int mystrlen(char *str)
{
  int i;

  for(i=0; str[i]; i++) ; // find the end of the string

  return i;
}

listing 19
#include <iostream>
using namespace std;

int main(int argc, char *argv[])
{
  if(argc!=2) {
    cout << "You forgot to type your name.\n";
    return 1;
  }
  cout << "Hello " << argv[1] << '\n';

  return 0;
}

listing 20
/* The program prints all command line arguments it is
   called with one character at a time. */
#include <iostream>
using namespace std;

int main(int argc, char *argv[])
{
  int t, i;

  for(t=0; t<argc; ++t) {
    i = 0;
    while(argv[t][i]) {
      cout << argv[t][i];
      ++i;
    }
    cout << ' ';
  }

  return 0;
}

listing 21
/* This program displays the sum of the two numeric
   command line arguments.
*/

#include <iostream>
#include <cstdlib>
using namespace std;

int main(int argc, char *argv[])
{

  double a, b;

  if(argc!=3) {
    cout << "Usage: add num num\n";
    return 1;
  }

  a = atof(argv[1]);
  b = atof(argv[2]);

  cout << a + b;

  return 0;
}

listing 22
// Demonstrate atoi(), atol(), and atof().
#include <iostream>
#include <cstdlib>
using namespace std;

int main()
{
  int i;
  long j;
  double k;

  i = atoi("100");
  j = atol("100000");
  k = atof("-0.123");

  cout << i << ' ' << j << ' ' << k;
  cout << '\n';

  return 0;
}

listing 23
void power(int base, int exp)
{
  int i;

  if(exp<0) return; /* Can't do negative exponents,
                       so return to calling routine
                       and bypass the rest of the 
                       function. */

  i = 1;

  for( ; exp; exp--) i = base * i;
  cout << "The answer is: " << i;
}

listing 24
void f()
{
  // ...

  switch(c) {
    case 'a': return;
    case 'b': // ...
    case 'c': return;
  }
  if(count<100) return;
  // ...
}

listing 25
x = power(y);

if(max(x, y)) > 100) cout << "greater";

switch(abs(x)) {

listing 26
#include <iostream>
#include <cstdlib>
using namespace std;

int main()
{
  int i;

  i = abs(-10);     // line 1
  cout << abs(-23); // line 2
  abs(100);         // line 3

  return 0;
}

listing 27
#include <iostream>
using namespace std;

int find_substr(char *sub, char *str);

int main()
{
  int index;

  index = find_substr("three", "one two three four");

  cout << "Index of three is " << index; // index is 8

  return 0;
}

// Return index of substring or -1 if not found.
int find_substr(char *sub, char *str)
{
  int t;
  char *p, *p2;

  for(t=0; str[t]; t++) {
    p = &str[t]; // reset pointers 
    p2 = sub;
    while(*p2 && *p2==*p) { // check for substring
      p++;
      p2++;
    } 

    /* If at end of p2 (i.e., substring), then
       a match has been found. */
    if(!*p2) return t; // return index of match
  }
  return -1; // no match found
}

listing 28
#include <iostream>
using namespace std;

void print_vertical(char *str); 

int main(int argc, char *argv[])
{
  if(argc==2) print_vertical(argv[1]);

  return 0;
}

void print_vertical(char *str)
{
  while(*str) 
    cout << *str++ << '\n';
}

listing 29
x = print_vertical("hello"); // Error

listing 30
// Rework find_substr() to return a pointer.
#include <iostream>
using namespace std;

char *find_substr(char *sub, char *str);

int main()
{
  char *substr;

  substr = find_substr("three", "one two three four");

  cout << "substring found: " << substr;

  return 0;
}

// Return pointer to substring or null if not found.
char *find_substr(char *sub, char *str)
{
  int t;
  char *p, *p2, *start;

  for(t=0; str[t]; t++) {
    p = &str[t]; // reset pointers 
    start = p; 
    p2 = sub;    
    while(*p2 && *p2==*p) { // check for substring
      p++;
      p2++;
    } 

    /* If at end of p2 (i.e., substring), then
       a match has been found. */
    if(!*p2)
      return start; // return pointer to beginning of substring
  }
  return 0; // no match found
}

listing 31
/* This program uses a function prototype to
   enforce strong type checking.
*/

void sqr_it(int *i); // prototype

int main()
{
  int x;

  x = 10;  
  sqr_it(x); // *** Error *** -- type mismatch!

  return 0;
}

void sqr_it(int *i)
{
  *i = *i * *i; 
}

listing 32
float f(int a, int b, char ch)
{ ...

listing 33
float f(a, b, ch)
int a, b;
char ch;
{ ...

listing 34
#include <iostream>
using namespace std;

int factr(int n);
int fact(int n);

int main()
{
  // use recursive version
  cout << "4 factorial is " << factr(4);
  cout << '\n';

  // use iterative version
  cout << "4 factorial is " << fact(4);
  cout << '\n';

  return 0;
}

// Recursive version.
int factr(int n) 
{
  int answer;

  if(n==1) return(1);
  answer = factr(n-1)*n;
  return(answer);
}

// Iterative version.
int fact(int n)
{
  int t, answer;

  answer = 1;
  for(t=1; t<=n; t++) answer = answer*(t);
  return(answer);
}

listing 35
// Print a string backwards using recursion.
#include <iostream>
using namespace std;

void reverse(char *s);

int main()
{
  char str[] = "this is a test";

  reverse(str);

  return 0;
}

// Print string backwards.
void reverse(char *s)
{
  if(*s) 
    reverse(s+1); 
  else
    return;

  cout << *s;
}


listing 1
#include <iostream>
using namespace std;

int sqr_it(int x);

int main()
{
  int t=10;

  cout << sqr_it(t) << ' ' << t;

  return 0;
}

int sqr_it(int x)
{
  x = x*x;
  return x;
}

listing 2
void swap(int *x, int *y)
{
  int temp;

  temp = *x; // save the value at address x
  *x = *y;   // put y into x
  *y = temp; // put x into y
}

listing 3
#include <iostream>
using namespace std;

// Declare swap() using pointers.
void swap(int *x, int *y);

int main()
{
  int i, j;

  i = 10;
  j = 20;

  cout << "initial values of i and j: ";
  cout << i << ' ' << j << '\n';
  swap(&j, &i); // call swap() with addresses of i and j
  cout << "swapped values of i and j: ";
  cout << i << ' ' << j << '\n';

  return 0;
}

// Exchange arguments.
void swap(int *x, int *y)
{
  int temp;

  temp = *x; // save the value at address x
  *x = *y;   // put y into x
  *y = temp; // put x into y
}

listing 4
// Using a reference parameter.
#include <iostream>
using namespace std;

void f(int &i);

int main()
{
  int val = 1;

  cout << "Old value for val: " << val << '\n';

  f(val); // pass address of val to f()

  cout << "New value for val: " << val << '\n';

  return 0;
}

void f(int &i)
{
  i = 10; // this modifies calling argument
}

listing 5
void f(int &i)
{
  i = 10; // this modifies calling argument
}

listing 6
i = 10;

listing 7
f(val);  // pass address of val to f()

listing 8
#include <iostream>
using namespace std;

// Declare swap() using reference parameters.
void swap(int &x, int &y);

int main()
{
  int i, j;

  i = 10;
  j = 20;

  cout << "initial values of i and j: ";
  cout << i << ' ' << j << '\n';
  swap(j, i);
  cout << "swapped values of i and j: ";
  cout << i << ' ' << j << '\n';

  return 0;
}

/* Here, swap() is defined as using call-by-reference,
   not call-by-value. Thus, it can exchange the two
   arguments it is called with.
*/
void swap(int &x, int &y)
{
  int temp;

  temp = x; // save the value at address x
  x = y;    // put y into x
  y = temp; // put x into y
}

listing 9
void swap(int& x, int& y);

listing 10
float* p;

listing 11
int* a, b;

listing 12
// Returning a reference.
#include <iostream>
using namespace std;

double &f();

double val = 100.0;

int main()
{
  double newval;

  cout << f() << '\n'; // display val's value

  newval = f(); // assign value of val to newval
  cout << newval << '\n'; // display newval's value

  f() = 99.1; // change val's value
  cout << f() << '\n'; // display val's new value

  return 0;
}

double &f()
{
  return val; // return reference to val
}

listing 13
cout << f() << '\n'; // display val's value

listing 14
return val; // return reference to val

listing 15
newval = f(); // assign value of val to newval

listing 16
f() = 99.1; // change val's value

listing 17
#include <iostream>
using namespace std;

double &change_it(int i); // return a reference

double vals[] = {1.1, 2.2, 3.3, 4.4, 5.5};

int main()
{
  int i;

  cout << "Here are the original values: ";
  for(i=0; i<5; i++)
    cout << vals[i] << ' ';
  cout << '\n';

  change_it(1) = 5298.23; // change 2nd element
  change_it(3) = -98.8; // change 4th element

  cout << "Here are the changed values: ";
  for(i=0; i<5; i++)
    cout << vals[i] << ' ';
  cout << '\n';

  return 0;
}

double &change_it(int i)
{
  return vals[i]; // return a reference to the ith element
}

listing 18
// Error, cannot return reference to local var.
int &f()
{
  int i=10;
  return i;
}

listing 19
#include <iostream>
using namespace std;

int &put(int i); // put value into the array
int get(int i); // obtain a value from the array

int vals[10];
int error = -1;

int main()
{
  put(0) = 10; // put values into the array
  put(1) = 20;
  put(9) = 30;

  cout << get(0) << ' ';
  cout << get(1) << ' ';
  cout << get(9) << ' ';

  // now, intentionally generate an error
  put(12) = 1; // Out of Bounds

  return 0;
}

// Put a value into the array.
int &put(int i)
{
  if(i>=0 && i<10)
    return vals[i]; // return a reference to the ith element
  else {
    cout << "Bounds Error!\n";
    return error; // return a reference to error
  }
}

// Get a value from the array.
int get(int i)
{
  if(i>=0 && i<10)
    return vals[i]; // return the value of the ith element
  else {
    cout << "Bounds Error!\n";
    return error; // return an error
  }
}

listing 20
#include <iostream>
using namespace std;

int main()
{
  int j, k;
  int &i = j; // independent reference

  j = 10;

  cout << j << " " << i; // outputs 10 10

  k = 121;
  i = k; // copies k's value into j
         // not k's address

  cout << "\n" << j;  // outputs 121

  return 0;
}

listing 21
// Overload a function three times.
#include <iostream>
using namespace std;

void f(int i);        // integer parameter
void f(int i, int j); // two integer parameters
void f(double k);     // one double parameter

int main()
{
  f(10);     // call f(int)

  f(10, 20); // call f(int, int)

  f(12.23);  // call f(double)

  return 0;
}

void f(int i)
{
  cout << "In f(int), i is " << i << '\n';
}

void f(int i, int j)
{
  cout << "In f(int, int), i is " << i;
  cout << ", j is " << j << '\n';
}

void f(double k)
{
  cout << "In f(double), k is " << k << '\n';
}

listing 22
// Create an overloaded abs function.
#include <iostream>
using namespace std;

// myabs() is overloaded three ways.
int myabs(int i);
double myabs(double d);
long myabs(long l);

int main()
{
  cout << myabs(-10) << "\n";

  cout << myabs(-11.0) << "\n";

  cout << myabs(-9L) << "\n";

  return 0;
}

int myabs(int i)
{
  cout << "Using integer myabs(): ";

  if(i<0) return -i;
  else return i;
}

double myabs(double d)
{
  cout << "Using double myabs(): ";

  if(d<0.0) return -d;
  else return d;
}

long myabs(long l)
{
  cout << "Using long myabs(): ";

  if(l<0) return -l;
  else return l;
}

listing 23
overload myfunc;

listing 24
void myfunc(double num = 0.0, char ch = 'X')
{
  .
  .
  .
}

listing 25
myfunc(198.234, 'A');  // pass explicit values

myfunc(10.1); // pass num a value, let ch default

myfunc();   // let both num and ch default

listing 26
#include <iostream>
using namespace std;

void clrscr(int size=25);

int main()
{
  int i;

  for(i=0; i<30; i++ ) cout << i << '\n';
  clrscr(); // clears 25 lines

  for(i=0; i<30; i++ ) cout << i << '\n';
  clrscr(10); // clears 10 lines

  return 0;
}

void clrscr(int size)
{
   for(; size; size--) cout << '\n';
}

listing 27
// wrong!
void f(int a = 1, int b);

listing 28
int myfunc(float f, char *str, int i=10, int j);

listing 29
void mystrcat(char *s1, char *s2, int len);
void mystrcat(char *s1, char *s2);

listing 30
// A customized version of strcat().
#include <iostream>
#include <cstring>
using namespace std;

void mystrcat(char *s1, char *s2, int len = -1);

int main()
{
  char str1[80] = "This is a test";
  char str2[80] = "0123456789";

  mystrcat(str1, str2, 5); // concatenate 5 chars
  cout << str1 << '\n';

  strcpy(str1, "this is a test"); // reset str1

  mystrcat(str1, str2); // concatenate entire string
  cout << str1 << '\n';

  return 0;
}

// A custom version of strcat().
void mystrcat(char *s1, char *s2, int len)
{
  // find end of s1
  while(*s1) s1++;

  if(len == -1) len = strlen(s2);

  while(*s2 && len) {
    *s1 = *s2; // copy chars
    s1++;
    s2++;
    len--;
  }

  *s1 = '\0'; // null terminate s1
}

listing 31
int myfunc(double d);
.
.
.
cout << myfunc('c');  // not an error, conversion applied

listing 32
// Overloading ambiguity
#include <iostream>
using namespace std;

float myfunc(float i);
double myfunc(double i);

int main()
{
  // unambiguous, calls myfunc(double)
  cout << myfunc(10.1) << " ";

  // ambiguous
  cout << myfunc(10);

  return 0;
}

float myfunc(float i)
{
  return i;
}

double myfunc(double i)
{
  return -i;
}

listing 33
#include <iostream>
using namespace std;

char myfunc(unsigned char ch);
char myfunc(char ch);

int main()
{
  cout << myfunc('c');  // this calls myfunc(char)
  cout << myfunc(88) << " "; // ambiguous

  return 0;
}

char myfunc(unsigned char ch)
{
  return ch-1;
}


char myfunc(char ch)
{
  return ch+1;
}

listing 34
#include <iostream>
using namespace std;

int myfunc(int i);
int myfunc(int i, int j=1);

int main()
{
  cout << myfunc(4, 5) << " "; // unambiguous
  cout << myfunc(10); // ambiguous

  return 0;
}

int myfunc(int i)
{
  return i;
}

int myfunc(int i, int j)
{
  return i*j;
}



listing 1
const double version =  3.2;

listing 2
#include <iostream>
using namespace std;

void code(const char *str);
 
int main()
{
  code("this is a test");

  return 0;
}

/* Use of const ensures str cannot modify the
   argument to which it points. */
void code(const char *str)
{
  while(*str) {
    cout << (char) (*str+1);
    str++;
  }
}

listing 3
// This is wrong.
void code(const char *str)
{
  while(*str) {
    *str = *str + 1; // Error, can't modify the argument
    cout << (char) *str;
    str++;
  }
}

listing 4
// const references cannot be modified.
#include <iostream>
using namespace std;

void f(const int &i);

int main()
{
  int k = 10;

  f(k);
  return 0;
}

// Use a const reference parameter.
void f(const int &i)
{
  i = 100; // Error, can't modify a const reference.
  cout <<  i;
}

listing 5
#include <iostream>
using namespace std;

const int size = 10;

int main()
{
  int A1[size], A2[size], A3[size];

  // ...
}

listing 6
int clock, timer;
// ... 
timer = clock;                             // line A
// ... do something
cout << "Elapsed type is " << clock-timer; // line B

listing 7
volatile int clock;

listing 8
const volatile unsigned char *port;

listing 9
#include <iostream>
using namespace std;

int main()
{
  extern int first, last; // use global vars

  cout << first << " " << last << "\n";

  return 0;
}

// global definition of first and last 
int first = 10, last = 20;

listing 10
static int count;

listing 11
static int count = 200;

listing 12
/* Compute a running average of numbers entered by 
   the user.
*/
#include <iostream>
using namespace std;

int r_avg(int i);

int main()
{
  int num;

  do {
    cout << "Enter numbers (-1 to quit): ";
    cin >> num;
    if(num != -1) cout << "Running average is: " << r_avg(num);
    cout << '\n';
  } while(num > -1);

  return 0;
}

// Compute a running average.
int r_avg(int i)
{
  static int sum=0, count=0;

  sum = sum + i;

  count++;

  return sum / count;
}

listing 13
// ---------------------- First File ----------------------

#include <iostream>
using namespace std;

int r_avg(int i);
void reset();

int main()
{
  int num;

  do {
    cout << "Enter numbers (-1 to quit, -2 to reset): ";
    cin >> num;
    if(num==-2) {
      reset();
      continue;
    }
    cout << "Running average is: " << r_avg(num);
    cout << '\n';
  } while(num != -1);

  return 0;
}

// ---------------------- Second File ----------------------

static int sum=0, count=0;

int r_avg(int i)
{
  sum = sum + i;

  count++;

  return sum / count;
}

void reset()
{
  sum = 0;
  count = 0;
}

listing 14
int signed_pwr(register int m, register int e)
{
  register int temp;
  int sign;

  if(m < 0) sign = -1;
  else sign = 1;

  temp = 1;
  for( ;e ;e--) temp = temp * m;

  return temp * sign;
}

listing 15
/* This program shows the difference a register variable
   can make to the speed of program execution.
*/

#include <iostream>
#include <ctime> 
using namespace std;

unsigned int i; // non-register 
unsigned int delay;

int main()
{
  register unsigned int j;
  long start, end;

  start = clock();
  for(delay=0; delay<50; delay++)
    for(i=0; i<6400000; i++);
  end = clock();
  cout << "Number of clock ticks for non-register loop: ";
  cout << end-start << '\n';

  start = clock();
  for(delay=0; delay<50; delay++)
    for(j=0; j<6400000; j++) ;
  end = clock();
  cout << "Number of clock ticks for register loop: ";
  cout << end-start << '\n';

  return 0;
}

listing 16
enum apple {Jonathan, Golden_Del, Red_Del, Winesap,
            Cortland, McIntosh} red, yellow;

listing 17
apple fruit;

listing 18
enum apple fruit;

listing 19
fruit = Winesap;
if(fruit==Red_Del) cout << "Red Delicious\n";

listing 20
cout << Jonathan << ' ' << Cortland;

listing 21
fruit = 1; // Error

listing 22
fruit = (apple) 1; // now OK, but probably poor style

listing 23
enum apple {Jonathan, Golden_Del, Red_Del, Winesap=10,
             Cortland, McIntosh};

listing 24
// This will not print "McIntosh" on the screen.
fruit = McIntosh;
cout << fruit;

listing 25
switch(fruit) {
  case Jonathan: cout << "Jonathan";
    break;
  case Golden_Del: cout << "Golden Delicious";
    break;
  case Red_Del: cout << "Red Delicious";
    break;
  case Winesap: cout << "Winesap";
    break;
  case Cortland: cout << "Cortland";
    break;
  case McIntosh: cout << "McIntosh";
    break;
}

listing 26
#include <iostream>
using namespace std;

enum  apple {Jonathan, Golden_Del, Red_Del, Winesap,
             Cortland, McIntosh};

// Array of strings that correspond to the apple enumeration.
char name[][20] = {
  "Jonathan",
  "Golden Delicious",
  "Red Delicious",
  "Winesap",
  "Cortland",
  "McIntosh"
};

int main()
{
  apple fruit;

  fruit = Jonathan;
  cout << name[fruit] << '\n';

  fruit = Winesap;
  cout << name[fruit] << '\n';

  fruit = McIntosh;
  cout << name[fruit] << '\n';

  return 0;
}

listing 27
typedef float balance;

listing 28
balance over_due;

listing 29
// Uppercase letters.
#include <iostream>
using namespace std;

int main()
{
  char ch;

  do {
    cin >> ch;

    // This statement turns off the 6th bit. 
    ch = ch & 223; // ch is now uppercase

    cout << ch;
  } while(ch!='Q');

  return 0;
}

listing 30
if(status & 8) cout << "bit 4 is on";

listing 31
// Display the bits within a byte.
void disp_binary(unsigned u)
{
  register int t;

  for(t=128; t>0; t = t/2)
    if(u & t) cout << "1 ";
    else cout << "0 ";
  cout << "\n";
}

listing 32
// Lowercase letters.
#include <iostream>
using namespace std;

int main()
{
  char ch;

  do {
    cin >> ch;

    /* This lowercases the letter by turning
       on bit 6.
    */
    ch = ch | 32;

    cout << ch;
  } while(ch != 'q');

  return 0;
}

listing 33
#include <iostream>
using namespace std;

void disp_binary(unsigned u);

int main()
{
  unsigned u;

  cout << "Enter a number between 0 and 255: ";
  cin >> u;

  cout << "Here's the number in binary: ";
  disp_binary(u);

  cout << "Here's the complement of the number: ";
  disp_binary(~u);

  return 0;
}

// Display the bits within a byte.
void disp_binary(unsigned u)
{
  register int t;

  for(t=128; t>0; t = t/2)
    if(u & t) cout << "1 ";
    else cout << "0 ";
  cout << "\n";
}

listing 34
// Example of bitshifting. 

#include <iostream>
using namespace std;

void disp_binary(unsigned u);

int main()
{
  int i=1, t;

  for(t=0; t<8; t++) {
    disp_binary(i);
    i = i << 1;
  }

  cout << "\n";

  for(t=0; t<8; t++) {
    i = i >> 1;
    disp_binary(i);
  }

  return 0;
}

// Display the bits within a byte.
void disp_binary(unsigned u)
{
  register int t;

  for(t=128; t>0; t=t/2)
    if(u & t) cout << "1 ";
    else cout << "0 ";
  cout << "\n";
}

listing 35
while(something) {
  x = count > 0 ? 0 : 1;
  // ...
}

listing 36
while(something) {
  if(count > 0) x = 0;
  else x = 1;
  // ...
}

listing 37
/* This program uses the ? operator to prevent
   a division by zero. */

#include <iostream>
using namespace std;

int div_zero();

int main()
{
  int i, j, result;

  cout << "Enter dividend and divisor: ";
  cin >> i >> j;

  // This statement prevents a divide by zero error.
  result = j ? i/j : div_zero();

  cout << "Result: " << result;

  return 0;
}

int div_zero()
{
  cout << "Cannot divide by zero.\n";
  return 0;
}

listing 38
x = x+10;

listing 39
x += 10;

listing 40
x = x-100;

listing 41
x -= 100;

listing 42
var = (count=19, incr=10, count+1);

listing 43
#include <iostream>
using namespace std;

int main()
{
  int i, j;

  j = 10;

  i = (j++, j+100, 999+j);

  cout << i;

  return 0;
}

listing 44
count = incr = index = 10;

listing 45
// Demonstrate sizeof.
#include <iostream>
using namespace std;

int main()
{
  char ch;
  int i;

  cout << sizeof ch << ' '; // size of char
  cout << sizeof i << ' ';  // size of int
  cout << sizeof (float) << ' '; // size of float
  cout << sizeof (double) << ' '; // size of double

  return 0;
}

listing 46
int nums[4];

cout << sizeof nums; // displays 16

listing 47
#include <iostream>
using namespace std;

int main()
{
  int *p;  

  p = new int; // allocate memory for int

  *p = 20; // assign that memory the value 20
  cout << *p; // prove that it works by displaying value

  delete p; // free the memory

  return 0;
}

listing 48
#include <iostream>
using namespace std;

int main()
{
  int *p;

  p = new int (99);  // initialize with 99

  cout << *p; // displays 99

  delete p;

  return 0;
}

listing 49
#include <iostream>
using namespace std;

int main()
{
  double *p;
  int i;

  p = new double [10]; // get a 10-element array

  // assign the values 100 through 109
  for(i=0; i<10; i++) p[i] = 100.00 + i;

  // display the contents of the array
  for(i=0; i<10; i++)  cout << p[i] << " ";

  delete [] p; // delete the entire array

  return 0;
}

listing 50
#include <iostream>
#include <cstdlib>
using namespace std;

int main()
{
  int *i;
  double *j;

  i = (int *) malloc(sizeof(int));
  if(!i) {
    cout << "Allocation Failure.\n";
    return 1;
  }

  j = (double *) malloc(sizeof(double));
  if(!j) {
    cout << "Allocation Failure.\n";
    return 1;
  }

  *i= 10;
  *j = 100.123;

  cout << *i << ' ' << *j;

  // free the memory
  free(i);
  free(j);

  return 0;
}



listing 1
struct inv_type {
  char item[40]; // name of item
  double cost;   // cost
  double retail; // retail price
  int on_hand;   // amount on hand
  int lead_time; // number of days before resupply
};

listing 2
inv_type inv_var;

listing 3
struct inv_type {
  char item[40]; // name of item
  double cost;   // cost
  double retail; // retail price
  int on_hand;   // amount on hand
  int lead_time; // number of days before resupply
} inv_varA, inv_varB, inv_varC;

listing 4
struct {
  char item[40]; // name of item
  double cost;   // cost
  double retail; // retail price
  int on_hand;   // amount on hand
  int lead_time; // number of days before resupply
} temp;

listing 5
inv_var.cost = 10.39;

listing 6
cout << inv_var.cost;

listing 7
gets(inv_var.item);

listing 8
int t;

for(t=0; inv_var.item[t]; t++)
  cout << inv_var.item[t];

listing 9
inv_type invtry[100];

listing 10
cout << invtry[2].on_hand;

listing 11
const int SIZE = 100;

struct inv_type {
  char item[40]; // name of item
  double cost;   // cost
  double retail; // retail price
  int on_hand;   // amount on hand
  int lead_time; // number of days before resupply
} invtry[SIZE];

listing 12
// Initialize the inv_type_info array.
void init_list()
{
  int t;

  // a zero length name signifies empty
  for(t=0; t<SIZE; t++) *invtry[t].item = '\0';
}

listing 13
// Get a menu selection.
int menu()
{
  char ch;

  cout << '\n';
  do {
    cout << "(E)nter\n";
    cout << "(D)isplay\n";
    cout << "(U)pdate\n";
    cout << "(Q)uit\n\n";
    cout << "choose one: ";
    cin >> ch;
  } while(!strchr("eduq", tolower(ch)));
  return tolower(ch);
}

listing 14
// Enter items into the list.
void enter()
{
  int i;

  // find the first free structure
  for(i=0; i<SIZE; i++)
    if(!*invtry[i].item) break;

  // i will equal SIZE if the list is full
  if(i==SIZE) {
    cout << "List full.\n";
    return;
  }

  input(i);
}

// Input the information.
void input(int i)
{
  // enter the information
  cout << "Item: ";
  cin >> invtry[i].item;

  cout << "Cost: ";
  cin >> invtry[i].cost;

  cout << "Retail price: ";
  cin >> invtry[i].retail;

  cout << "On hand: ";
  cin >> invtry[i].on_hand;

  cout << "Lead time to resupply (in days): ";
  cin >> invtry[i].lead_time;
}

listing 15
// Modify an existing item.
void update()
{
  int i;
  char name[80];

  cout << "Enter item: ";
  cin >> name;

  for(i=0; i<SIZE; i++)
    if(!strcmp(name, invtry[i].item)) break;

  if(i==SIZE) {
    cout << "Item not found.\n";
    return;
  }

  cout << "Enter new information.\n";
  input(i);
}

listing 16
// Display the list.
void display()
{
  int t;

  for(t=0; t<SIZE; t++) {
    if(*invtry[t].item) {
      cout << invtry[t].item << '\n';
      cout << "Cost: $" << invtry[t].cost;
      cout << "\nRetail: $";
      cout << invtry[t].retail << '\n';
      cout << "On hand: " << invtry[t].on_hand;
      cout << "\nResupply time: ";
      cout << invtry[t].lead_time << " days\n\n";
    }
  }
}

listing 17
/* A simple inventory program that uses an array
   of structures. */

#include <iostream>
#include <cctype>
#include <cstring>
#include <cstdlib>
using namespace std;

const int SIZE = 100;

struct inv_type {
  char item[40]; // name of item
  double cost;   // cost
  double retail; // retail price
  int on_hand;   // amount on hand
  int lead_time; // number of days before resupply
}  invtry[SIZE];

void enter(), init_list(), display();
void update(), input(int i);
int menu();

int main()
{
  char choice;

  init_list();

  for(;;) {
    choice = menu();
    switch(choice) {
      case 'e': enter();
        break;
      case 'd': display();
        break;
      case 'u': update();
        break;
      case 'q': return 0;
    }
  }
}

// Initialize the inv_type_info array.
void init_list()
{
  int t;

  // a zero length name signifies empty
  for(t=0; t<SIZE; t++) *invtry[t].item = '\0';
}

// Get a menu selection.
int menu()
{
  char ch;

  cout << '\n';
  do {
    cout << "(E)nter\n";
    cout << "(D)isplay\n";
    cout << "(U)pdate\n";
    cout << "(Q)uit\n\n";
    cout << "choose one: ";
    cin >> ch;
  } while(!strchr("eduq", tolower(ch)));
  return tolower(ch);
}

// Enter items into the list.
void enter()
{
  int i;

  // find the first free structure
  for(i=0; i<SIZE; i++)
    if(!*invtry[i].item) break;

  // i will equal SIZE if the list is full
  if(i==SIZE) {
    cout << "List full.\n";
    return;
  }

  input(i);
}

// Input the information.
void input(int i)
{
  // enter the information
  cout << "Item: ";
  cin >> invtry[i].item;

  cout << "Cost: ";
  cin >> invtry[i].cost;

  cout << "Retail price: ";
  cin >> invtry[i].retail;

  cout << "On hand: ";
  cin >> invtry[i].on_hand;

  cout << "Lead time to resupply (in days): ";
  cin >> invtry[i].lead_time;
}

// Modify an existing item.
void update()
{
  int i;
  char name[80];

  cout << "Enter item: ";
  cin >> name;

  for(i=0; i<SIZE; i++)
    if(!strcmp(name, invtry[i].item)) break;

  if(i==SIZE) {
    cout << "Item not found.\n";
    return;
  }

  cout << "Enter new information.\n";
  input(i);
}

// Display the list.
void display()
{
  int t;

  for(t=0; t<SIZE; t++) {
    if(*invtry[t].item) {
      cout << invtry[t].item << '\n';
      cout << "Cost: $" << invtry[t].cost;
      cout << "\nRetail: $";
      cout << invtry[t].retail << '\n';
      cout << "On hand: " << invtry[t].on_hand;
      cout << "\nResupply time: ";
      cout << invtry[t].lead_time << " days\n\n";
    }
  }
}

listing 18
// Pass a structure to a function.
#include <iostream>
using namespace std;

// Define a structure type.
struct sample {
  int a;
  char ch;
} ;

void f1(sample parm);

int main()
{
  struct sample arg; // declare arg

  arg.a = 1000;
  arg.ch = 'X';

  f1(arg);

  return 0;
}

void f1(sample parm)
{
  cout << parm.a << " " << parm.ch;
  cout << "\n";
}

listing 19
// Demonstrate structure assignments.
#include <iostream>
using namespace std;

struct stype {
  int a, b;
};

int main()
{
  stype svar1, svar2;

  svar1.a = svar1.b = 10;
  svar2.a = svar2.b = 20;

  cout << "Structures before assignment.\n";
  cout << "svar1: " << svar1.a << ' ' << svar1.b;
  cout << '\n';
  cout << "svar2: " << svar2.a << ' ' << svar2.b;
  cout << "\n\n";

  svar2 = svar1; // assign structures

  cout << "Structures after assignment.\n";
  cout << "svar1: " << svar1.a << ' ' << svar1.b;
  cout << '\n';
  cout << "svar2: " << svar2.a << ' ' << svar2.b;

  return 0;
}

listing 20
struct stype1 {
  int a, b;
};

struct stype2 {
  int a, b;
};

stype1 svar1;
stype2 svar2;

svar2 = svar1; // Error - type mismatch

listing 21
inv_type *inv_pointer;

listing 22
struct bal {
  float balance;
  char name[80];
} person;

bal *p; // declare a structure pointer

listing 23
p = &person;

listing 24
p->balance

listing 25
struct tm {
  int tm_sec;   // seconds, 0-61 
  int tm_min;   // minutes, 0-59 
  int tm_hour;  // hours, 0-23 
  int tm_mday;  // day of the month, 1-31 
  int tm_mon;   // months since Jan, 0-11 
  int tm_year;  // years from 1900 
  int tm_wday;  // days since Sunday, 0-6 
  int tm_yday;  // days since Jan 1, 0-365 
  int tm_isdst; // Daylight Saving Time indicator 
};

listing 26
// This program displays the current system time.

#include <iostream>
#include <ctime>
using namespace std;

int main()
{
  struct tm *ptr;
  time_t lt;

  lt = time('\0');

  ptr = localtime(&lt);

  cout << ptr->tm_hour << ':' << ptr->tm_min;
  cout << ':' << ptr->tm_sec;

  return 0;
}

listing 27
// This program displays the current system time.

#include <iostream>
#include <ctime>
using namespace std;

int main()
{
  struct tm *ptr;
  time_t lt;

  lt = time('\0');

  ptr = localtime(&lt);
  cout << asctime(ptr);

  return 0;
}

listing 28
// Demonstrate a reference to a structure.
#include <iostream>
using namespace std;

struct mystruct {
  int a;
  int b;
};

mystruct &f(mystruct &var);

int main()
{
  mystruct x, y;
  x.a = 10; x.b = 20;

  cout << "Original x.a and x.b: ";
  cout << x.a << ' ' << x.b << '\n';

  y = f(x);

  cout << "Modified x.a and x.b: ";
  cout << x.a << ' ' << x.b << '\n';
  cout << "Modified y.a and y.b: ";
  cout << y.a << ' ' << y.b << '\n';

  return 0;
}

// Receive and return a reference to a structure.
mystruct &f(mystruct &var)
{
  var.a = var.a * var.a;
  var.b = var.b / var.b;
  return var;
}

listing 29
struct stype {
  int nums[10][10]; // 10 x 10 array of ints
  float b;
} var;

listing 30
var.nums[3][7]

listing 31
struct addr {
  char name[40];
  char street[40];
  char city[40];
  char zip[10];
}

struct emp {
  addr address;
  float wage;
} worker;

listing 32
worker.address.zip = 98765;

listing 33
struct mystruct {
  int a;
  char str[80];
  mystruct *sptr; // pointer to mystruct objects
};

listing 34
struct C_struct {
 int a;
 int b;
}

// declare a C_struct variable
struct C_struct svar:

listing 35
struct status_type {
  unsigned delta_cts: 1;
  unsigned delta_dsr: 1;
  unsigned tr_edge:   1;
  unsigned delta_rec: 1;
  unsigned cts:       1;
  unsigned dsr:       1;
  unsigned ring:      1;
  unsigned rec_line:  1;
} status;

listing 36
status = get_port_status();

if(status.cts) cout << "clear to send";
if(status.dsr) cout << "data ready";

listing 37
status.ring = 0;

listing 38
struct status_type {
  unsigned : 4;
  unsigned cts: 1;
  unsigned dsr: 1;
} status;

listing 39
struct emp {
  struct addr address;
  float pay;
  unsigned lay_off: 1; // lay off or active
  unsigned hourly: 1: // hourly pay or wage
  unsigned deductions: 3: // IRS deductions
};

listing 40
union utype {
  short int i;
  char ch;
} ;

listing 41
utype u_var;

listing 42
u_var.ch = 'A';

listing 43
  // ...
  func1(&u_var); // pass func1() a pointer to u_var 
  // ...
}

void func1(utype *un)
{
  un->i = 10; /* Assign 10 to u_var using
                 a pointer. */
}

listing 44
// Use a union to exchange the bytes within a short integer.
#include <iostream>
using namespace std;

void disp_binary(unsigned u);

union swap_bytes {
  short int num;
  char ch[2];
};

int main()
{
  swap_bytes sb;
  char temp;

  sb.num = 15;  // binary: 0000 0000 0000 1111


  cout << "Original bytes:  ";
  disp_binary(sb.ch[1]);
  cout << "  ";
  disp_binary(sb.ch[0]);
  cout << "\n\n";


  // exchange the bytes
  temp = sb.ch[0];
  sb.ch[0] = sb.ch[1];
  sb.ch[1] = temp;

  cout << "Exchanged bytes: ";
  disp_binary(sb.ch[1]);
  cout << "  ";
  disp_binary(sb.ch[0]);
  cout << "\n\n";

  return 0;
}

// Display the bits within a byte.
void disp_binary(unsigned u)
{
  register int t;

  for(t=128; t>0; t=t/2)
    if(u & t) cout << "1 ";
    else cout << "0 ";
}

listing 45
// Display the ASCII code in binary for characters.

#include <iostream>
#include <conio.h>
using namespace std;

// a bit field that will be decoded
struct byte {
  unsigned a : 1;
  unsigned b : 1;
  unsigned c : 1;
  unsigned d : 1;
  unsigned e : 1;
  unsigned f : 1;
  unsigned g : 1;
  unsigned h : 1;
};

union bits {
  char ch;
  struct byte bit;
} ascii ;

void disp_bits(bits b);

int main()
{
  do {
    cin >> ascii.ch;
    cout << ": ";
    disp_bits(ascii);
  } while(ascii.ch!='q'); // quit if q typed

  return 0;
}

// Display the bit pattern for each character.
void disp_bits(bits b)
{
  if(b.bit.h) cout << "1 ";
    else cout << "0 ";
  if(b.bit.g) cout << "1 ";
    else cout << "0 ";
  if(b.bit.f) cout << "1 ";
    else cout << "0 ";
  if(b.bit.e) cout << "1 ";
    else cout << "0 ";
  if(b.bit.d) cout << "1 ";
    else cout << "0 ";
  if(b.bit.c) cout << "1 ";
    else cout << "0 ";
  if(b.bit.b) cout << "1 ";
    else cout << "0 ";
  if(b.bit.a) cout << "1 ";
    else cout << "0 ";
  cout << "\n";
}

listing 46
// Demonstrate an anonymous union.
#include <iostream>
using namespace std;

int main()
{
  // this is an anonymous union
  union {
    short int count;
    char ch[2];
  };

  // Here, refer to union members directly
  ch[0] = 'X';
  ch[1] = 'Y';
  cout << "union as chars: " << ch[0] << ch[1] << '\n';
  cout << "union as integer: " << count << '\n';

  return 0;
}

listing 47
union x {
  char ch;
  int i;
 double f;
} u_var;



listing 1
// This creates the class queue.
class queue {
  int q[100];
  int sloc, rloc;
public:
  void init();
  void qput(int i);
  int qget();
};

listing 2
queue Q1, Q2;

listing 3
void queue::qput(int i)
{
  if(sloc==100) {
    cout << "Queue is full.\n";
    return;
  }
  sloc++;
  q[sloc] = i;
}

listing 4
queue ob1, ob2;

ob1.init();

listing 5
#include <iostream>
using namespace std;

// This creates the class queue.
class queue {
  int q[100];
  int sloc, rloc;
public:
  void init();
  void qput(int i); 
  int qget();
};

// Initialize the queue.
void queue::init()
{
  rloc = sloc = 0;
}

// Put an integer into the queue.
void queue::qput(int i)
{
  if(sloc==100) {
    cout << "Queue is full.\n";
    return;
  }
  sloc++;
  q[sloc] = i;
}

// Get an integer from the queue.
int queue::qget()
{
  if(rloc == sloc) {
    cout << "Queue underflow.\n";
    return 0;
  }
  rloc++;
  return q[rloc];
}

int main()
{
  queue a, b;  // create two queue objects

  a.init();
  b.init();

  a.qput(10);
  b.qput(19);

  a.qput(20);
  b.qput(1);

  cout << "Contents of queue a: ";
  cout << a.qget() << " ";
  cout << a.qget() << "\n";

  cout << "Contents of queue b: ";
  cout << b.qget() << " ";
  cout << b.qget() << "\n";

  return 0;
}

listing 6
a.rloc = 0;

listing 7
// Demonstrate class member access.
#include <iostream>
using namespace std;

class myclass {
  int a; // private data
public:
  int b; // public data
  void setab(int i); // public functions
  int geta();
  void reset();
};

void myclass::setab(int i)
{
  a = i; // refer directly to a
  b = i*i; // refer directly to b 
}

int myclass::geta()
{
  return a; // refer directly to a
}

void myclass::reset()
{
  // call setab() directly
  setab(0); // the object is already known
}

int main()
{
  myclass ob;

  ob.setab(5); // set ob.a and ob.b
  cout << "ob after setab(5): ";
  cout << ob.geta() << ' ';
  cout << ob.b; // can access b because it is public
  cout << '\n';

  ob.b = 20; // can access b because it is public
  cout << "ob after ob.b=20: ";
  cout << ob.geta() << ' ';
  cout << ob.b;
  cout << '\n';

  ob.reset();
  cout << "ob after ob.reset(): ";
  cout << ob.geta() << ' ';
  cout << ob.b;
  cout << '\n';
   
  return 0;
}

listing 8
// This creates the class queue.
class queue {
  int q[100];
  int sloc, rloc;
public:
  queue();  // constructor
  void qput(int i); 
  int qget();
};

listing 9
// This is the constructor.
queue::queue()
{
  sloc = rloc = 0;
  cout << "Queue Initialized.\n";
}

listing 10
// This creates the class queue.
class queue {
  int q[100];
  int sloc, rloc;
public:
  queue();  // constructor
  ~queue(); // destructor
  void qput(int i); 
  int qget();
};

// This is the constructor.
queue::queue()
{
  sloc = rloc = 0;
  cout << "Queue initialized.\n";
}

// This is the destructor.
queue::~queue()
{
  cout << "Queue destroyed.\n";
}

listing 11
// Demonstrate a constructor and a destructor.
#include <iostream>
using namespace std;

// This creates the class queue.
class queue {
  int q[100];
  int sloc, rloc;
public:
  queue();  // constructor
  ~queue(); // destructor
  void qput(int i); 
  int qget();
};

// This is the constructor.
queue::queue()
{
  sloc = rloc = 0;
  cout << "Queue initialized.\n";
}

// This is the destructor.
queue::~queue()
{
  cout << "Queue destroyed.\n";
}

// Put an integer into the queue.
void queue::qput(int i)
{
  if(sloc==100) {
    cout << "Queue is full.\n";
    return;
  }
  sloc++;
  q[sloc] = i;
}

// Get an integer from the queue.
int queue::qget()
{
  if(rloc == sloc) {
    cout << "Queue Underflow.\n";
    return 0;
  }
  rloc++;
  return q[rloc];
}

int main()
{
  queue a, b;  // create two queue objects

  a.qput(10);
  b.qput(19);

  a.qput(20);
  b.qput(1);

  cout << a.qget() << " ";
  cout << a.qget() << " ";
  cout << b.qget() << " ";
  cout << b.qget() << "\n";

  return 0;
}

listing 12
// This creates the class queue.
class queue {
  int q[100];
  int sloc, rloc;
  int who; // holds the queue's ID number
public:
  queue(int id);  // parameterized constructor
  ~queue(); // destructor
  void qput(int i); 
  int qget();
};

listing 13
// This is the constructor.
queue::queue(int id)
{
  sloc = rloc = 0;
  who = id;
  cout << "Queue " << who << " initialized.\n";
}

listing 14
queue a = queue(101);

listing 15
queue a(101);

listing 16
// Use a parameterized constructor.
#include <iostream>
using namespace std;

// This creates the class queue.
class queue {
  int q[100];
  int sloc, rloc;
  int who; // holds the queue's ID number
public:
  queue(int id);  // parameterized constructor
  ~queue(); // destructor
  void qput(int i); 
  int qget();
};

// This is the constructor.
queue::queue(int id)
{
  sloc = rloc = 0;
  who = id;
  cout << "Queue " << who << " initialized.\n";
}

// This is the destructor.
queue::~queue()
{
  cout << "Queue " << who << " destroyed.\n";
}

// Put an integer into the queue.
void queue::qput(int i)
{
  if(sloc==100) {
    cout << "Queue is full.\n";
    return;
  }
  sloc++;
  q[sloc] = i;
}

// Get an integer from the queue.
int queue::qget()
{
  if(rloc == sloc) {
    cout << "Queue underflow.\n";
    return 0;
  }
  rloc++;
  return q[rloc];
}

int main()
{
  queue a(1), b(2);  // create two queue objects

  a.qput(10);
  b.qput(19);

  a.qput(20);
  b.qput(1);

  cout << a.qget() << " ";
  cout << a.qget() << " ";
  cout << b.qget() << " ";
  cout << b.qget() << "\n";

  return 0;
}

listing 17
#include <iostream>
using namespace std;

class widget {
  int i;
  int j;
public:
  widget(int a, int b);
  void put_widget();
} ;

// Pass 2 arguments to widget().
widget::widget(int a, int b)
{
  i = a;
  j = b;
}

void widget::put_widget()
{
  cout << i << " " << j << "\n";
}

int main()
{
  widget x(10, 20), y(0, 0);

  x.put_widget();
  y.put_widget();

  return 0;
}

listing 18
#include <iostream>
using namespace std;

class myclass {
  int a;
public:
  myclass(int x);
  int get_a();
};

myclass::myclass(int x)
{  
  a = x;
}

int myclass::get_a()
{
  return a;
}

int main()
{
  myclass ob = 4; // calls myclass(4)

  cout << ob.get_a();

  return 0;
}

listing 19
myclass ob = myclass(4);

listing 20
// Use struct to create a class.
#include <iostream>
using namespace std;

struct cl {
  int get_i();       // these are public
  void put_i(int j); // by default
private:
  int i;   
};

int cl::get_i()
{
  return i;
}

void cl::put_i(int j)
{
  i = j;
}

int main()
{
  cl s;

  s.put_i(10);
  cout << s.get_i();

  return 0;
}

listing 21
// Now, use class, instead.
#include <iostream>
using namespace std;

class cl {
  int i; // private by default
public:
  int get_i();
  void put_i(int j);
};

int cl::get_i()
{
  return i;
}

void cl::put_i(int j)
{
  i = j;
}

int main()
{
  cl s;

  s.put_i(10);
  cout << s.get_i();

  return 0;
}

listing 22
// Create union-based class.
#include <iostream>
using namespace std;

union u_type {
  u_type(short int a);  // public by default
  void showchars();
  short int i;
  char ch[2];
};

// constructor
u_type::u_type(short int a)
{
  i = a;
}

// Show the characters that comprise a short int.
void u_type::showchars()
{
  cout << ch[0] << " ";
  cout << ch[1] << "\n";
}

int main()
{
  u_type u(1000);

  u.showchars();

  return 0;
}

listing 23
#include <iostream>
using namespace std;

class cl {
  int i; // private by default
public:
  int get_i();
  void put_i(int j);
} ;

inline int cl::get_i()
{
  return i;
}

inline void cl::put_i(int j)
{
  i = j;
}

int main()
{
  cl s;

  s.put_i(10);
  cout << s.get_i();

  return 0;
}

listing 24
#include <iostream>
using namespace std;

class cl {
  int i; // private by default
public:
  // automatic inline functions
  int get_i() { return i; }
  void put_i(int j) { i = j; }
} ;

int main()
{
  cl s;

  s.put_i(10);
  cout << s.get_i();

  return 0;
}

listing 25
class cl {
  int i; // private by default
public:
  // inline functions
  int get_i()
  {
    return i;
  }

  void put_i(int j)
  {
     i = j;
  }
};

listing 26
// An example of arrays of objects

#include <iostream>
using namespace std;

enum resolution {low, medium, high};

class display {
  int width;
  int height;
  resolution res; 
public:
  void set_dim(int w, int h) {width = w; height = h;}
  void get_dim(int &w, int &h) {w = width; h = height;}
  void set_res(resolution r) {res = r;}
  resolution get_res() {return res;}
};

char names[3][7] = {
  "low",
  "medium",
  "high",
} ;

int main()
{
  display display_mode[3];
  int i, w, h;
  
  display_mode[0].set_res(low);
  display_mode[0].set_dim(640, 480);

  display_mode[1].set_res(medium);
  display_mode[1].set_dim(800, 600);

  display_mode[2].set_res(high);
  display_mode[2].set_dim(1600, 1200);

  cout << "Available display modes:\n\n";

  for(i=0; i<3; i++) {
    cout << names[display_mode[i].get_res()] << ": ";
    display_mode[i].get_dim(w, h);
    cout << w << " by " << h << "\n";
  }

  return 0;
}


listing 27
// Initialize an array of objects.
#include <iostream>
using namespace std;
 
class samp {
  int a;
public:
  samp(int n) { a = n; }
  int get_a() { return a; }
};

int main()
{
  samp sampArray[4] = { -1, -2, -3, -4 };
  int i;

  for(i=0; i<4; i++) cout << sampArray[i].get_a() << ' ';

  cout << "\n";

  return 0;
}

listing 28
samp sampArray[4] = { samp(-1), samp(-2), samp(-3), samp(-4) };

listing 29
#include <iostream>
using namespace std;

class samp {
  int a, b;
public:
  samp(int n, int m) { a = n; b = m; }
  int get_a() { return a; }
  int get_b() { return b; }
};

int main()
{
  samp sampArray[4][2] = {
    samp(1, 2), samp(3, 4), 
    samp(5, 6), samp(7, 8),
    samp(9, 10), samp(11, 12),
    samp(13, 14), samp(15, 16)
  };

  int i;

  for(i=0; i<4; i++) {
    cout << sampArray[i][0].get_a() << ' ';
    cout << sampArray[i][0].get_b() << "\n";
    cout << sampArray[i][1].get_a() << ' ';
    cout << sampArray[i][1].get_b() << "\n";
  }

  cout << "\n";

  return 0;
}

listing 30
// A simple example using an object pointer.

#include <iostream>
using namespace std;

class P_example {
  int num;
public:
  void set_num(int val) {num = val;}
  void show_num();
};

void P_example::show_num()
{
  cout << num << "\n";
}

int main()
{
  P_example ob, *p; // declare an object and pointer to it

  ob.set_num(1); // access ob directly

  ob.show_num();

  p = &ob; // assign p the address of ob
  p->show_num();  // access ob using pointer

  return 0;
}

listing 31
// Incrementing and decrementing an object pointer.
#include <iostream>
using namespace std;

class P_example {
  int num;
public:
  void set_num(int val) {num = val;}
  void show_num();
};

void P_example::show_num()
{
  cout << num << "\n";
}

int main()
{
  P_example ob[2], *p;

  ob[0].set_num(10);  // access objects directly
  ob[1].set_num(20);

  p = &ob[0];  // obtain pointer to first element
  p->show_num(); // show value of ob[0] using pointer

  p++;  // advance to next object
  p->show_num(); // show value of ob[1] using pointer

  p--;  // retreat to previous object
  p->show_num(); // again show value of ob[0]

  return 0;
}


listing 1
class cl {
  // ...
public:
  friend void frnd(cl ob);
 // ...
 };

listing 2
// Demonstrate a friend function.
#include <iostream>
using namespace std;

class myclass {
  int a, b;
public:
  myclass(int i, int j) { a=i; b=j; }
  friend int sum(myclass x); // sum() is a friend of myclass
};

// Note: sum() is not a member function of any class.
int sum(myclass x)
{
  /* Because sum() is a friend of myclass, it can
     directly access a and b. */

  return x.a + x.b;
}

int main()
{
  myclass n(3, 4);

  cout << sum(n);

  return 0;
}

listing 3
// Use a friend function.
#include <iostream>
using namespace std;

const int IDLE=0;
const int INUSE=1;

class C2;  // forward declaration

class C1 {
  int status;  // IDLE if off, INUSE if on screen
  // ...
public:
  void set_status(int state);
  friend int idle(C1 a, C2 b);
};

class C2 {
  int status; // IDLE if off, INUSE if on screen
  // ...
public:
  void set_status(int state);
  friend int idle(C1 a, C2 b);
};

void C1::set_status(int state)
{
  status = state;
}

void C2::set_status(int state)
{
  status = state;
}

// idle( ) is a friend of C1 and C2.
int idle(C1 a, C2 b)
{
  if(a.status || b.status) return 0;
  else return 1;
}

int main()
{
  C1 x;
  C2 y;

  x.set_status(IDLE);
  y.set_status(IDLE);

  if(idle(x, y)) cout << "Screen Can Be Used.\n";
  else cout << "Pop-up In Use.\n";

  x.set_status(INUSE);

  if(idle(x, y)) cout << "Screen Can Be Used.\n";
  else cout << "Pop-up In Use.\n";

  return 0;
}

listing 4
/* A function can be a member of one class and
   a friend of another. */
#include <iostream>
using namespace std;

const int IDLE=0;
const int INUSE=1;

class C2;  // forward declaration

class C1 {
  int status;  // IDLE if off, INUSE if on screen
  // ...
public:
  void set_status(int state);
  int idle(C2 b);  // now a member of C1
};

class C2 {
  int status;  // IDLE if off, INUSE if on screen
  // ...
public:
  void set_status(int state);
  friend int C1::idle(C2 b);
};

void C1::set_status(int state)
{
  status = state;
}

void C2::set_status(int state)
{
  status = state;
}

// idle() is member of C1, but friend of C2.
int C1::idle(C2 b)
{
  if(status || b.status) return 0;
  else return 1;
}

int main()
{
  C1 x;
  C2 y;

  x.set_status(IDLE);
  y.set_status(IDLE);

  if(x.idle(y)) cout << "Screen Can Be Used.\n";
  else cout << "Pop-up In Use.\n";

  x.set_status(INUSE);

  if(x.idle(y)) cout << "Screen Can Be Used.\n";
  else cout << "Pop-up In Use.\n";

  return 0;
}

listing 5
// Use overloaded constructors.
#include <iostream>
#include <cstdlib>
#include <ctime>
using namespace std;

class timer{
  int seconds;
public:
  // seconds specified as a string
  timer(char *t) { seconds = atoi(t); }

  // seconds specified as integer
  timer(int t) { seconds = t; }

  // time specified in minutes and seconds
  timer(int min, int sec) { seconds = min*60 + sec; }

  void run();
} ;

void timer::run()
{
  clock_t t1;

  t1 = clock();

  while((clock()/CLOCKS_PER_SEC - t1/CLOCKS_PER_SEC) < seconds);

  cout << "\a"; // ring the bell
}

int main()
{
  timer a(10), b("20"), c(1, 10);

  a.run(); // count 10 seconds
  b.run(); // count 20 seconds
  c.run(); // count 1 minute, 10 seconds

  return 0;
}

listing 6
int n = strlen(str);

double arc = sin(theta);

float d = 1.02 * count / deltax;

listing 7
// Demonstrate dynamic initialization.
#include <iostream>
#include <cstdlib>
#include <ctime>
using namespace std;

class timer{
  int seconds;
public:
  // seconds specified as a string
  timer(char *t) { seconds = atoi(t); }

  // seconds specified as integer
  timer(int t) { seconds = t; }

  // time specified in minutes and seconds
  timer(int min, int sec) { seconds = min*60 + sec; }

  void run();
} ;

void timer::run()
{
  clock_t t1;

  t1 = clock();

  while((clock()/CLOCKS_PER_SEC - t1/CLOCKS_PER_SEC) < seconds);

  cout << "\a"; // ring the bell
}

int main()
{
  timer a(10);

  a.run();

  cout << "Enter number of seconds: ";
  char str[80];
  cin >> str;
  timer b(str);  // initialize at run time
  b.run();

  cout << "Enter minutes and seconds: ";
  int min, sec;
  cin >> min >> sec;
  timer c(min, sec);  // initialize at run time
  c.run();

  return 0;
}

listing 8
// Demonstrate object assignment.
#include <iostream>
using namespace std;

class myclass {
  int a, b;
public:
  void setab(int i, int j) { a = i, b = j; }
  void showab();
};

void myclass::showab()
{
  cout << "a is " << a << '\n';
  cout << "b is " << b << '\n';
}

int main()
{
  myclass ob1, ob2;

  ob1.setab(10, 20);
  ob2.setab(0, 0);
  cout << "ob1 before assignment: \n";
  ob1.showab();
  cout << "ob2 before assignment: \n";
  ob2.showab();
  cout << '\n';

  ob2 = ob1; // assign ob1 to ob2

  cout << "ob1 after assignment: \n";
  ob1.showab();
  cout << "ob2 after assignment: \n";
  ob2.showab();

  return 0;
}

listing 9
#include <iostream>
using namespace std;

class OBJ {
  int i;
public:
  void set_i(int x) { i = x; }
  void out_i() { cout << i << " "; }
};

void f(OBJ x)
{
  x.out_i();  // outputs 10
  x.set_i(100);  // this affects only local copy
  x.out_i();  // outputs 100
}

int main()
{
  OBJ o;

  o.set_i(10);
  f(o);
  o.out_i();  // still outputs 10, value of i unchanged

  return 0;
}

listing 10
// Constructors, destructors, and passing objects.
#include <iostream>
using namespace std;

class myclass {
  int val;
public:
  myclass(int i) { val = i; cout << "Constructing\n"; }
  ~myclass() { cout << "Destructing\n"; }
  int getval() { return val; }
};

void display(myclass ob)
{
  cout << ob.getval() << '\n';
}

int main()
{
  myclass a(10);

  display(a);

  return 0;
}

listing 11
// Demonstrate a problem when passing objects.
#include <iostream>
#include <cstdlib>
using namespace std;

class myclass {
  int *p;
public:
  myclass(int i);
  ~myclass();
  int getval() { return *p; }
};

myclass::myclass(int i)
{
  cout << "Allocating p\n";
  p = new int;

  *p = i;
}

myclass::~myclass()
{
  cout << "Freeing p\n";
  delete p;
}

// This will cause a problem.
void display(myclass ob)
{
  cout << ob.getval() << '\n';
}

int main()
{
  myclass a(10);

  display(a);

  return 0;
}

listing 12
// One solution to the problem of passing objects.
#include <iostream>
#include <cstdlib>
using namespace std;

class myclass {
  int *p;
public:
  myclass(int i);
  ~myclass();
  int getval() { return *p; }
};

myclass::myclass(int i)
{
  cout << "Allocating p\n";
  p = new int;

  *p = i;
}

myclass::~myclass()
{
  cout << "Freeing p\n";
  delete p;
}

/* This will NOT cause a problem.

   Because ob is now passed by reference, no
   copy of the calling argument is made and thus,
   no object goes out-of-scope when display()
   terminates.
*/
void display(myclass &ob)
{
  cout << ob.getval() << '\n';
}

int main()
{
  myclass a(10);

  display(a);

  return 0;
}

listing 13
// Returning an object.
#include <iostream>
#include <cstring>
using namespace std;

class sample {
  char s[80];
public:
  void show() { cout << s << "\n"; }
  void set(char *str) { strcpy(s, str); }
};

// Return an object of type sample.
sample input()
{
  char instr[80];
  sample str;

  cout << "Enter a string: ";
  cin >> instr;

  str.set(instr);

  return str;
}

int main()
{
  sample ob;

  // assign returned object to ob
  ob = input();
  ob.show();

  return 0;
}

listing 14
// An error generated by returning an object.
#include <iostream>
#include <cstring>
#include <cstdlib>
using namespace std;

class sample {
  char *s;
public:
  sample() { s = 0; }
  ~sample() { if(s) delete [] s; cout << "Freeing s\n"; }
  void show() { cout << s << "\n"; }
  void set(char *str);
};

// Load a string.
void sample::set(char *str)
{
  s = new char[strlen(str)+1];

  strcpy(s, str);
}

// Return an object of type sample.
sample input()
{
  char instr[80];
  sample str;

  cout << "Enter a string: ";
  cin >> instr;

  str.set(instr);
  return str;
}

int main()
{
  sample ob;

  // assign returned object to ob
  ob = input();  // This causes an error!!!!
  ob.show();

  return 0;
}

listing 15
myclass x = y; // y explicitly initializing x
func1(y);      // y passed as a parameter
y = func2();   // y receiving a returned object

listing 16
// Use a copy constructor to construct a parameter.
#include <iostream>
#include <cstdlib>
using namespace std;

class myclass {
  int *p;
public:
  myclass(int i); // normal constructor
  myclass(const myclass &ob); // copy constructor
  ~myclass();
  int getval() { return *p; }
};

// Copy constructor.
myclass::myclass(const myclass &obj)
{
  p = new int;

  *p = *obj.p; // copy value
  cout << "Copy constructor called.\n";
}

// Normal Constructor.
myclass::myclass(int i)
{
  cout << "Allocating p\n";
  p = new int;

  *p = i;
}

myclass::~myclass()
{
  cout << "Freeing p\n";
  delete p;
}

// This function takes one object parameter.
void display(myclass ob)
{
  cout << ob.getval() << '\n';
}

int main()
{
  myclass a(10);

  display(a);

  return 0;
}

listing 17
// The copy constructor is called for initialization.
#include <iostream>
#include <cstdlib>
using namespace std;

class myclass {
  int *p;
public:
  myclass(int i); // normal constructor
  myclass(const myclass &ob); // copy constructor
  ~myclass();
  int getval() { return *p; }
};

// Copy constructor.
myclass::myclass(const myclass &ob)
{
  p = new int;

  *p = *ob.p; // copy value
  cout << "Copy constructor allocating p.\n";
}

// Normal constructor.
myclass::myclass(int i)
{
  cout << "Normal constructor allocating p.\n";
  p = new int;

  *p = i;
}

myclass::~myclass()
{
  cout << "Freeing p\n";
  delete p;
}

int main()
{
  myclass a(10); // calls normal constructor

  myclass b = a; // calls copy constructor

  return 0;
}

listing 18
myclass a(2), b(3);
// ...
b = a;

listing 19
/* Copy constructor is called when a temporary object
   is created as a function return value.
*/
#include <iostream>
using namespace std;

class myclass {
public:
  myclass() { cout << "Normal constructor.\n"; }
  myclass(const myclass &obj) { cout << "Copy constructor.\n"; }
};

myclass f()
{
  myclass ob; // invoke normal constructor

  return ob; // implicitly invoke copy constructor
}

int main()
{
  myclass a; // invoke normal constructor

  a = f(); // invoke copy constructor

  return 0;
}

listing 20
class cl {
  int i;
  void f() { ... };
.
.
.
};

listing 21
i = 10;

listing 22
this->i = 10;

listing 23
#include <iostream>
using namespace std;

class cl {
  int i;
public:
  void load_i(int val) { this->i = val; } // same as i = val
  int get_i() { return this->i; } // same as return i
} ;

int main()
{
  cl o;

  o.load_i(100);
  cout << o.get_i();

  return 0;
}



listing 1
// Overload operators using member functions.
#include <iostream>
using namespace std;

class three_d {
  int x, y, z; // 3-D coordinates
public:
  three_d() { x = y = z = 0; }
  three_d(int i, int j, int k) {x = i; y = j; z = k; }

  three_d operator+(three_d op2); // op1 is implied
  three_d operator=(three_d op2); // op1 is implied

  void show() ;
};

// Overload +.
three_d three_d::operator+(three_d op2)
{
  three_d temp;

  temp.x = x + op2.x; // These are integer additions
  temp.y = y + op2.y; // and the + retains is original
  temp.z = z + op2.z; // meaning relative to them.
  return temp;
}

// Overload assignment.
three_d three_d::operator=(three_d op2)
{
  x = op2.x; // These are integer assignments
  y = op2.y; // and the = retains its original
  z = op2.z; // meaning relative to them.
  return *this;
}

// Show X, Y, Z coordinates.
void three_d::show()
{
  cout << x << ", ";
  cout << y << ", ";
  cout << z << "\n";
}

int main()
{
  three_d a(1, 2, 3), b(10, 10, 10), c;

  a.show();
  b.show();

  c = a + b; // add a and b together
  c.show();

  c = a + b + c; // add a, b and c together
  c.show();

  c = b = a; // demonstrate multiple assignment
  c.show();
  b.show();

  return 0;
}

listing 2
temp.x = x + op2.x;

listing 3
a = b = c = d;

listing 4
// Overload a unary operator.
#include <iostream>
using namespace std;

class three_d {
  int x, y, z; // 3-D coordinates
public:
  three_d() { x = y = z = 0; }
  three_d(int i, int j, int k) {x = i; y = j; z = k; }

  three_d operator+(three_d op2); // op1 is implied
  three_d operator=(three_d op2); // op1 is implied
  three_d operator++(); // prefix version of ++

  void show() ;
} ;

// Overload +.
three_d three_d::operator+(three_d op2)
{
  three_d temp;

  temp.x = x + op2.x; // These are integer additions
  temp.y = y + op2.y; // and the + retains is original
  temp.z = z + op2.z; // meaning relative to them.
  return temp;
}

// Overload assignment.
three_d three_d::operator=(three_d op2)
{
  x = op2.x; // These are integer assignments
  y = op2.y; // and the = retains its original
  z = op2.z; // meaning relative to them.
  return *this;
}

// Overload the prefix version of ++.
three_d three_d::operator++()
{
  x++; // increment x, y, and z 
  y++; 
  z++;
  return *this;
}

// Show X, Y, Z coordinates.
void three_d::show()
{
  cout << x << ", ";
  cout << y << ", ";
  cout << z << "\n";
}

int main()
{
  three_d a(1, 2, 3), b(10, 10, 10), c;
  a.show();
  b.show();

  c = a + b; // add a and b together
  c.show();

  c = a + b + c; // add a, b and c together
  c.show();

  c = b = a; // demonstrate multiple assignment
  c.show();
  b.show();

  ++c;  // increment c
  c.show();

  return 0;
}

listing 5
++O;

listing 6
O++;

listing 7
three_d three_d::operator++(int notused);

listing 8
// Overload the postfix version of ++.
three_d three_d::operator++(int notused)
{
  three_d temp = *this; // save original value

  x++;  // increment x, y, and z
  y++;
  z++;
  return temp; // return original value
}

listing 9
three_d temp = *this;

listing 10
// Demonstrate prefix and postfix ++.
#include <iostream>
using namespace std;

class three_d {
  int x, y, z; // 3-D coordinates
public:
  three_d() { x = y = z = 0; }
  three_d(int i, int j, int k) {x = i; y = j; z = k; }

  three_d operator+(three_d op2); // op1 is implied
  three_d operator=(three_d op2); // op1 is implied
  three_d operator++(); // prefix version of ++
  three_d operator++(int notused); // postfix version of ++

  void show() ;
};

// Overload +.
three_d three_d::operator+(three_d op2)
{
  three_d temp;

  temp.x = x + op2.x; // These are integer additions
  temp.y = y + op2.y; // and the + retains its original
  temp.z = z + op2.z; // meaning relative to them.
  return temp;
}

// Overload assignment.
three_d three_d::operator=(three_d op2)
{
  x = op2.x; // These are integer assignments
  y = op2.y; // and the = retains its original
  z = op2.z; // meaning relative to them.
  return *this;
}

// Overload the prefix version of ++.
three_d three_d::operator++()
{
  x++;  // increment x, y, and z
  y++;
  z++;
  return *this; // return altered value
}

// Overload the postfix version of ++.
three_d three_d::operator++(int notused)
{
  three_d temp = *this; // save original value

  x++; // increment x, y, and z
  y++;
  z++;
  return temp; // return original value
}

// Show X, Y, Z coordinates.
void three_d::show( )
{
  cout << x << ", ";
  cout << y << ", ";
  cout << z << "\n";
}

int main()
{
  three_d a(1, 2, 3), b(10, 10, 10), c;
  a.show();
  b.show();

  c = a + b; // add a and b together
  c.show();

  c = a + b + c; // add a, b and c together
  c.show();

  c = b = a; // demonstrate multiple assignment
  c.show();
  b.show();

  ++c; // prefix increment
  c.show();

  c++; // postfix increment
  c.show();

  a = ++c; // a receives c's value after increment
  a.show(); // a and c
  c.show(); // are the same

  a = c++; // a receives c's value prior to increment
  a.show(); // a and c
  c.show(); // now differ

  return 0;
}

listing 11
// Overload subtraction.
three_d three_d::operator-(three_d op2)
{
  three_d temp;

  temp.x = x - op2.x;
  temp.y = y - op2.y;
  temp.z = z - op2.z;
  return temp;
}

listing 12
// Overload + using a friend.
#include <iostream>
using namespace std;

class three_d {
  int x, y, z; // 3-D coordinates
public:
  three_d() { x = y = z = 0; }
  three_d(int i, int j, int k) { x = i; y = j; z = k;}

  friend three_d operator+(three_d op1, three_d op2);
  three_d operator=(three_d op2); // op2 is implied

  void show() ;
} ;

// This is now a friend function.
three_d operator+(three_d op1, three_d op2)
{
  three_d temp;

  temp.x = op1.x + op2.x; 
  temp.y = op1.y + op2.y; 
  temp.z = op1.z + op2.z; 
  return temp;
}

// Overload assignment.
three_d three_d::operator=(three_d op2)
{
  x = op2.x; 
  y = op2.y; 
  z = op2.z; 
  return *this;
}

// Show X, Y, Z coordinates.
void three_d::show()
{
  cout << x << ", ";
  cout << y << ", ";
  cout << z << "\n";
}

int main()
{
  three_d a(1, 2, 3), b(10, 10, 10), c;

  a.show();
  b.show();

  c = a + b; // add a and b together
  c.show();

  c = a + b + c; // add a, b and c together
  c.show();

  c = b = a;  // demonstrate multiple assignment
  c.show();
  b.show();

  return 0;
}

listing 13
O = O + 10; // will work

listing 14
O = 10 + O; // won't work

listing 15
#include <iostream>
using namespace std;

class CL {
public:
  int count;
  CL operator=(CL obj);
  friend CL operator+(CL ob, int i);
  friend CL operator+(int i, CL ob);
};

CL CL::operator=(CL obj)
{
  count = obj.count;
  return *this;
}

// This handles ob + int.
CL operator+(CL ob, int i)
{
  CL temp;

  temp.count = ob.count + i;
  return temp;
}

// This handles int + ob.
CL operator+(int i, CL ob)
{
  CL temp;

  temp.count = ob.count + i;
  return temp;
}

int main()
{
  CL O;

  O.count = 10;
  cout << O.count << " "; // outputs 10

  O = 10 + O; // add object to integer
  cout << O.count << " "; // outputs 20

  O = O + 12; // add integer to object
  cout << O.count;        // outputs 32

  return 0;
}

listing 16
// Overload the prefix form of ++.
three_d three_d::operator++()
{
  x++;
  y++;
  z++;
  return *this;
}

listing 17
// THIS WILL NOT WORK
three_d operator++(three_d op1)
{
  op1.x++;
  op1.y++;
  op1.z++;
  return op1;
}

listing 18
// This program uses friend operator++() functions.
#include <iostream>
using namespace std;

class three_d {
  int x, y, z; // 3-D coordinates
public:
  three_d() { x = y = z = 0; }
  three_d(int i, int j, int k) {x = i; y = j; z = k; }

  friend three_d operator+(three_d op1, three_d op2);
  three_d operator=(three_d op2); 

  // use a reference to overload the ++
  friend three_d operator++(three_d &op1);
  friend three_d operator++(three_d &op1, int notused);

  void show() ;
} ;

// This is now a friend function.
three_d operator+(three_d op1, three_d op2)
{
  three_d temp;

  temp.x = op1.x + op2.x; 
  temp.y = op1.y + op2.y; 
  temp.z = op1.z + op2.z; 
  return temp;
}

// Overload the =.
three_d three_d::operator=(three_d op2)
{
  x = op2.x; 
  y = op2.y; 
  z = op2.z; 
  return *this;
}

/* Overload prefix ++ using a friend function.
   This requires the use of a reference parameter. */
three_d operator++(three_d &op1)
{
  op1.x++;
  op1.y++;
  op1.z++;
  return op1;
}

/* Overload postfix ++ using a friend function.
   This requires the use of a reference parameter. */
three_d operator++(three_d &op1, int notused)
{
  three_d temp = op1;

  op1.x++;
  op1.y++;
  op1.z++;
  return temp;
}

// Show X, Y, Z coordinates.
void three_d::show()
{
  cout << x << ", ";
  cout << y << ", ";
  cout << z << "\n";
}

int main()
{
  three_d a(1, 2, 3), b(10, 10, 10), c;

  a.show();
  b.show();

  c = a + b; // add a and b together
  c.show();

  c = a + b + c; // add a, b and c together
  c.show();

  c = b = a; // demonstrate multiple assignment
  c.show();
  b.show();

  ++c; // prefix increment
  c.show();

  c++; // postfix increment
  c.show();

  a = ++c; // a receives c's value after increment
  a.show( ); // a and c
  c.show( ); // are the same

  a = c++; // a receives c's value prior to increment
  a.show( ); // a and c
  c.show( ); // now differ

  return 0;
}

listing 19
// Overload ==.
bool three_d::operator==(three_d op2)
{
  if((x == op2.x) && (y == op2.y) && (z == op2.z))
    return true;
  else
    return false;
}

listing 20
three_d a, b;

// ...

if(a == b) cout << "a equals b\n";
else cout << "a does not equal b\n";

listing 21
// An error generated by returning an object.
#include <iostream>
#include <cstring> 
#include <cstdlib>
using namespace std;

class sample {
  char *s;
public:
  sample() { s = 0; }
  sample(const sample &ob); // copy constructor
  ~sample( ) { if(s) delete [] s; cout << "Freeing s\n"; }
  void show() { cout << s << "\n"; }
  void set(char *str);
};

// Copy constructor.
sample::sample(const sample &ob)
{
  s = new char[strlen(ob.s)+1];

  strcpy(s, ob.s);
}

// Load a string.
void sample::set(char *str)
{
  s = new char[strlen(str)+1];

  strcpy(s, str);
}

// Return an object of type sample.
sample input()
{
  char instr[80];
  sample str;

  cout << "Enter a string: ";
  cin >> instr;

  str.set(instr);
  return str;
}

int main()
{
  sample ob;

  // assign returned object to ob
  ob = input();  // This causes an error!!!!
  ob.show();

  return 0;
}

listing 22
// This program is now fixed.
#include <iostream>
#include <cstring>
#include <cstdlib>
using namespace std;

class sample {
  char *s;
public:
  sample(); // normal constructor
  sample(const sample &ob); // copy constructor
  ~sample( ) { if(s) delete [] s; cout << "Freeing s\n"; }
  void show() { cout << s << "\n"; }
  void set(char *str);
  sample operator=(sample &ob); // overload assignment
};

// Normal constructor.
sample::sample()
{
  s = new char('\0'); // s points to a null string.
} 

// Copy constructor.
sample::sample(const sample &ob)
{
  s = new char[strlen(ob.s)+1];

  strcpy(s, ob.s);
}

// Load a string.
void sample::set(char *str)
{
  s = new char[strlen(str)+1];

  strcpy(s, str);
}

// Overload assignment operator.
sample sample::operator=(sample &ob)
{
  /* If the target string is not large enough
     then allocate a new string. */
  if(strlen(ob.s) > strlen(s)) {
    delete [] s;
    s = new char[strlen(ob.s)+1];
  }
  strcpy(s, ob.s);
  return *this;
}

// Return an object of type sample.
sample input()
{
  char instr[80];
  sample str;

  cout << "Enter a string: ";
  cin >> instr;

  str.set(instr);
  return str;
}

int main()
{
  sample ob;

  // assign returned object to ob
  ob = input();  // This is now OK
  ob.show();

  return 0;
}

listing 23
O[3]

listing 24
O.operator[](3)

listing 25
// Overload [].
#include <iostream>
using namespace std;

const int SIZE = 3;

class atype {
  int a[SIZE];
public:
  atype() {
    register int i;

    for(i=0; i<SIZE; i++) a[i] = i;
  }
  int operator[](int i) {return a[i];}
};

int main()
{
  atype ob;

  cout << ob[2];  // displays 2

  return 0;
}

listing 26
// Return a reference from [].
#include <iostream>
using namespace std;

const int SIZE = 3;

class atype {
  int a[SIZE];
public:
  atype() {
    register int i;

    for(i=0; i<SIZE; i++) a[i] = i;
  }
  int &operator[](int i) {return a[i];}
};

int main()
{
  atype ob;

  cout << ob[2];  // displays 2
  cout << " ";

  ob[2] = 25;  // [] on left of =

  cout << ob[2];  // now displays 25

  return 0;
}

listing 27
// A safe array example.
#include <iostream>
#include <cstdlib>
using namespace std;

const int SIZE = 3;

class atype {
  int a[SIZE];
public:
  atype() {
    register int i;

    for(i=0; i<SIZE; i++) a[i] = i;
  }
  int &operator[](int i);
};

// Provide range checking for atype.
int &atype::operator[](int i)
{
  if(i<0 || i> SIZE-1) {
    cout << "\nIndex value of ";
    cout << i << " is out-of-bounds.\n";
    exit(1);
  }
  return a[i];
}

int main()
{
  atype ob;

  cout << ob[2];  // displays 2
  cout << " ";

  ob[2] = 25;  // [] appears on left

  cout << ob[2];  // displays 25

  ob[3] = 44; // generates runtime error, 3 out-of-range
  return 0;
}

listing 28
ob[3] = 44;

listing 29
int operator()(float f, char *p);

listing 30
O(99.57, "overloading");

listing 31
operator()(99.57, "overloading");

listing 32
// Overload ().
#include <iostream>
using namespace std;

class three_d {
  int x, y, z; // 3-D coordinates
public:
  three_d() { x = y = z = 0; }
  three_d(int i, int j, int k) {x = i; y = j; z = k; }
  three_d operator()(int a, int b, int c);
  void show() ;
};

// Overload ().
three_d three_d::operator()(int a, int b, int c)
{
  three_d temp;

  temp.x = x + a;
  temp.y = y + b;
  temp.z = z + c;

  return temp;
}

// Show X, Y, Z coordinates.
void three_d::show()
{
  cout << x << ", ";
  cout << y << ", ";
  cout << z << "\n";
}

int main()
{
  three_d ob1(1, 2, 3), ob2;

  ob2 = ob1(10, 11, 12); // invoke operator()

  cout << "ob1: ";
  ob1.show();

  cout << "ob2: ";
  ob2.show();

  return 0;
}

listing 33
#include <iostream>
#include <cstring>
using namespace std;

class str_type {
  char string[80];
public:
  str_type(char *str = "") { strcpy(string, str); }

  str_type operator+(str_type str); // concatenate
  str_type operator=(str_type str); // assign

  // output the string
  void show_str() { cout << string; }
};

listing 34
// Concatenate two strings.
str_type str_type::operator+(str_type str) {
  str_type temp;

  strcpy(temp.string, string);
  strcat(temp.string, str.string);
  return temp;
}

// Assign one string to another.
str_type str_type::operator=(str_type str) {
  strcpy(string, str.string);
  return *this;
}

listing 35
int main()
{
  str_type a("Hello "), b("There"), c;

  c = a + b;

  c.show_str();

  return 0;
}

listing 36
a = "this is currently wrong";

listing 37
class str_type {
  char string[80];
public:
  str_type(char *str = "") { strcpy(string, str); }

  str_type operator+(str_type str); // concatenate str_type objects
  str_type operator+(char *str); /* concatenate str_type object 
                                    with a null-terminated string */

  str_type operator=(str_type str); /* assign one str_type object
                                       to another */
  char *operator=(char *str); /* assign null-terminated string
                                 to str_type object */

  void show_str() { cout << string; }
};

listing 38
// Assign a null-terminated string to an str_type object.
str_type str_type::operator=(char *str)
{
  str_type temp;

  strcpy(string, str);
  strcpy(temp.string, string);
  return temp;
}

// Add a null-terminated string to an str_type object.
str_type str_type::operator+(char *str)
{
  str_type temp;

  strcpy(temp.string, string);
  strcat(temp.string, str);
  return temp;
}

listing 39
str_type a, b, c;
a = "hi there"; // assign a null-terminated string to an object

c = a + " George"; /* concatenate an object with a
                      null-terminated string */

listing 40
// Expanding the string type.
#include <iostream>
#include <cstring>
using namespace std;

class str_type {
  char string[80];
public:
  str_type(char *str = "") { strcpy(string, str); }

  str_type operator+(str_type str);
  str_type operator+(char *str);

  str_type operator=(str_type str);
  str_type operator=(char *str);

  void show_str() { cout << string; }
} ;

str_type str_type::operator+(str_type str) {
  str_type temp;

  strcpy(temp.string, string);
  strcat(temp.string, str.string);
  return temp;
}

str_type str_type::operator=(str_type str) {
  strcpy(string, str.string);
  return *this;
}

str_type str_type::operator=(char *str)
{
  str_type temp;

  strcpy(string, str);
  strcpy(temp.string, string);
  return temp;
}

str_type str_type::operator+(char *str)
{
  str_type temp;

  strcpy(temp.string, string);
  strcat(temp.string, str);
  return temp;
}

int main()
{
  str_type a("Hello "), b("There"), c;

  c = a + b;

  c.show_str();
  cout << "\n";

  a = "to program in because";
  a.show_str();
  cout << "\n";

  b = c = "C++ is fun";

  c = c+" "+a+" "+b;
  c.show_str();

  return 0;
}



listing 1
class road_vehicle {
  int wheels;
  int passengers;
public:
  void set_wheels(int num) { wheels = num; }
  int get_wheels() { return wheels; }
  void set_pass(int num) { passengers = num; }
  int get_pass() { return passengers; }
};

listing 2
class truck : public road_vehicle {
  int cargo;
public:
  void set_cargo(int size) { cargo = size; }
  int get_cargo() { return cargo; }
  void show();
};

listing 3
// Demonstrate inheritance.
#include <iostream>
using namespace std;

class road_vehicle {
  int wheels;
  int passengers;
public:
  void set_wheels(int num) { wheels = num; }
  int get_wheels() { return wheels; }
  void set_pass(int num) { passengers = num; }
  int get_pass() { return passengers; }
};

class truck : public road_vehicle {
  int cargo;
public:
  void set_cargo(int size) { cargo = size; }
  int get_cargo() { return cargo; }
  void show();
};

enum type {car, van, wagon};

class automobile : public road_vehicle {
  enum type car_type;
public:
  void set_type(type t) { car_type = t; }
  enum type get_type() { return car_type; }
  void show();
};

void truck::show()
{
  cout << "wheels: " << get_wheels() << "\n";
  cout << "passengers: " << get_pass() << "\n";
  cout << "cargo capacity in cubic feet: " << cargo << "\n";
}

void automobile::show()
{
  cout << "wheels: " << get_wheels() << "\n";
  cout << "passengers: " << get_pass() << "\n";
  cout << "type: ";
  switch(get_type()) {
    case van: cout << "van\n";
      break;
    case car: cout << "car\n";
      break;
    case wagon: cout << "wagon\n";
  }
}

int main()
{
  truck t1, t2;
  automobile c;

  t1.set_wheels(18);
  t1.set_pass(2);
  t1.set_cargo(3200);

  t2.set_wheels(6);
  t2.set_pass(3);
  t2.set_cargo(1200);

  t1.show();
  cout << "\n";
  t2.show();
  cout << "\n";

  c.set_wheels(4);
  c.set_pass(6);
  c.set_type(van);

  c.show();

  return 0;
}

listing 4
#include <iostream>
using namespace std;

class base {
  int i, j;
public:
  void set(int a, int b) { i = a; j = b; }
  void show() { cout << i << " " << j << "\n"; }
};

class derived : public base {
  int k;
public:
  derived(int x) { k = x; }
  void showk() { cout << k << "\n"; }
};

int main()
{
  derived ob(3);

  ob.set(1, 2); // access member of base
  ob.show();    // access member of base

  ob.showk();   // uses member of derived class

  return 0;
}

listing 5
// This program won't compile.
#include <iostream>
using namespace std;

class base {
  int i, j;
public:
  void set(int a, int b) { i = a; j = b; }
  void show() { cout << i << " " << j << "\n"; }
};

// Public elements of base are private in derived.
class derived : private base {
  int k;
public:
  derived(int x) { k = x; }
  void showk() { cout << k << "\n"; }
};

int main()
{
  derived ob(3);

  ob.set(1, 2); // Error, can't access set()
  ob.show();    // Error, can't access show()

  return 0;
}

listing 6
#include <iostream>
using namespace std;

class base {
protected:
  int i, j; // private to base, but accessible to derived
public:
  void set(int a, int b) { i = a; j = b; }
  void show() { cout << i << " " << j << "\n"; }
};

class derived : public base {
  int k;
public:
  // derived may access base's i and j
  void setk() { k = i*j; }

  void showk() { cout << k << "\n"; }
};

int main()
{
  derived ob;

  ob.set(2, 3); // OK, known to derived
  ob.show();    // OK, known to derived

  ob.setk();
  ob.showk();

  return 0;
}

listing 7
#include <iostream>
using namespace std;

class base {
protected:
  int i, j;
public:
  void set(int a, int b) { i = a; j = b; }
  void show() { cout << i << " " << j << "\n"; }
};

// i and j inherited as protected.
class derived1 : public base {
  int k;
public:
  void setk() { k = i*j; } // legal
  void showk() { cout << k << "\n"; }
};

// i and j inherited indirectly through derived1.
class derived2 : public derived1 {
  int m;
public:
  void setm() { m = i-j; } // legal
  void showm() { cout << m << "\n"; }
};

int main()
{
  derived1 ob1;
  derived2 ob2;

  ob1.set(2, 3);
  ob1.show();
  ob1.setk();
  ob1.showk();

  ob2.set(3, 4);
  ob2.show();
  ob2.setk();
  ob2.setm();
  ob2.showk();
  ob2.showm();

  return 0;
}

listing 8
// This program won't compile.
#include <iostream>
using namespace std;

class base {
protected:
  int i, j;
public:
  void set(int a, int b) { i = a; j = b; }
  void show() { cout << i << " " << j << "\n"; }
};

// Now, all elements of base are private in derived1.
class derived1 : private base {
  int k;
public:
  // This is legal because i and j are private to derived1.
  void setk() { k = i*j; }  // OK
  void showk() { cout << k << "\n"; }
};

// Access to i, j, set(), and show() not inherited.
class derived2 : public derived1 {
  int m;
public:
  // Illegal because i and j are private to derived1.
  void setm() { m = i-j; }  // error
  void showm() { cout << m << "\n"; }
};

int main()
{
  derived1 ob1;
  derived2 ob2;

  ob1.set(1, 2); // Error, can't use set()
  ob1.show();    // Error, can't use show()

  ob2.set(3, 4); // Error, can't use set()
  ob2.show();    // error, can't use show()

  return 0;
}

listing 9
// Demonstrate inheriting a protected base class.
#include <iostream>
using namespace std;

class base {
  int i;
protected:
  int j;
public:
  int k;
  void seti(int a) { i = a; }
  int geti() { return i; }
};

// Inherit base as protected.
class derived : protected base {
public:
  void setj(int a) { j = a; } // j is protected here
  void setk(int a) { k = a; } // k is also protected
  int getj() { return j; }
  int getk() { return k; }
};

int main()
{
  derived ob;

  /* This next line is illegal because seti() is
     a protected member of derived, which makes it
     inaccessible outside of derived. */
//  ob.seti(10);

//  cout << ob.geti(); // illegal -- geti() is protected
//  ob.k = 10; // also illegal because k is protected

  // these next statements are OK
  ob.setk(10);
  cout << ob.getk() << ' ';
  ob.setj(12);
  cout << ob.getj() << ' ';

  return 0;
}

listing 10
// An example of multiple base classes.
#include <iostream>
using namespace std;

class base1 {
protected:
  int x;
public:
  void showx() { cout << x << "\n"; }
};

class base2 {
protected:
  int y;
public:
  void showy() { cout << y << "\n"; }
};

// Inherit multiple base classes.
class derived: public base1, public base2 {
public:
  void set(int i, int j) { x = i; y = j; }
};

int main()
{
  derived ob;

  ob.set(10, 20); // provided by derived
  ob.showx();     // from base1
  ob.showy();     // from base2

  return 0;
}

listing 11
#include <iostream>
using namespace std;

class base {
public:
  base() { cout << "Constructing base\n"; }
  ~base() { cout << "Destructing base\n"; }
};

class derived: public base {
public:
  derived() { cout << "Constructing derived\n"; }
  ~derived() { cout << "Destructing derived\n"; }
};

int main()
{
  derived ob;

  // do nothing but construct and destruct ob

  return 0;
}

listing 12
#include <iostream>
using namespace std;

class base {
public:
  base() { cout << "Constructing base\n"; }
  ~base() { cout << "Destructing base\n"; }
};

class derived1 : public base {
public:
  derived1() { cout << "Constructing derived1\n"; }
  ~derived1() { cout << "Destructing derived1\n"; }
};

class derived2: public derived1 {
public:
  derived2() { cout << "Constructing derived2\n"; }
  ~derived2() { cout << "Destructing derived2\n"; }
};

int main()
{
  derived2 ob;

  // construct and destruct ob

  return 0;
}

listing 13
#include <iostream>
using namespace std;

class base1 {
public:
  base1() { cout << "Constructing base1\n"; }
  ~base1() { cout << "Destructing base1\n"; }
};

class base2 {
public:
  base2() { cout << "Constructing base2\n"; }
  ~base2() { cout << "Destructing base2\n"; }
};

class derived: public base1, public base2 {
public:
  derived() { cout << "Constructing derived\n"; }
  ~derived() { cout << "Destructing derived\n"; }
};

int main()
{
  derived ob;

  // construct and destruct ob

  return 0;
}

listing 14
class derived: public base2, public base1 {

listing 15
#include <iostream>
using namespace std;

class base {
protected:
  int i;
public:
  base(int x) { i = x; cout << "Constructing base\n"; }
  ~base() { cout << "Destructing base\n"; }
};

class derived: public base {
  int j;
public:
  // derived uses x; y is passed along to base.
  derived(int x, int y): base(y)
    { j = x; cout << "Constructing derived\n"; }

  ~derived() { cout << "Destructing derived\n"; }
  void show() { cout << i << " " << j << "\n"; }
};

int main()
{
  derived ob(3, 4);

  ob.show();  // displays 4 3

  return 0;
}

listing 16
#include <iostream>
using namespace std;

class base1 {
protected:
  int i;
public:
  base1(int x) { i = x; cout << "Constructing base1\n"; }
  ~base1() { cout << "Destructing base1\n"; }
};

class base2 {
protected:
  int k;
public:
  base2(int x) { k = x; cout << "Constructing base2\n"; }
  ~base2() { cout << "Destructing base2\n"; }
};

class derived: public base1, public base2 {
  int j;
public:
  derived(int x, int y, int z): base1(y), base2(z)
    { j = x; cout << "Constructing derived\n"; }

  ~derived() { cout << "Destructing derived\n"; }
  void show() { cout << i << " " << j << " " << k << "\n"; }
};

int main()
{
  derived ob(3, 4, 5);

  ob.show();  // displays 4 3 5

  return 0;
}

listing 17
#include <iostream>
using namespace std;

class base1 {
protected:
  int i;
public:
  base1(int x) { i=x; cout << "Constructing base1\n"; }
  ~base1() { cout << "Destructing base1\n"; }
};

class base2 {
protected:
  int k;
public:
  base2(int x) { k = x; cout << "Constructing base2\n"; }
  ~base2() { cout << "Destructing base2\n"; }
};

class derived: public base1, public base2 {
public:
  /* Derived constructor uses no parameters,
     but still must be declared as taking them to
     pass them along to base classes.
  */
  derived(int x, int y): base1(x), base2(y)
    { cout << "Constructing derived\n"; }

  ~derived() { cout << "Destructing derived\n"; }
  void show() { cout << i << " " << k << "\n"; }
};

int main()
{
  derived ob(3, 4);

  ob.show();  // displays 3 4

  return 0;
}

listing 18
class derived: public base {
  int j;
public:
  // derived uses both x and y and then passes them to base.
  derived(int x, int y): base(x, y)
    { j = x*y; cout << "Constructing derived\n"; }
// ...

listing 19
class base {
public:
  int j;  // public in base
};

// Inherit base as private.
class derived: private base {
public:

  // here is access declaration
  base::j; // make j public again
  // ...
};

listing 20
base::j;

listing 21
#include <iostream>
using namespace std;

class base {
  int i;  // private to base
public:
  int j, k;
  void seti(int x) { i = x; }
  int geti() { return i; }
};

// Inherit base as private.
class derived: private base {
public:
  /* The next three statements override
    base's inheritance as private
    and restore j, seti() and geti() to
    public access. */
  base::j;    // make j public again - but not k
  base::seti; // make seti() public
  base::geti; // make geti() public

//  base::i;  // illegal, you cannot elevate access

  int a; // public
};

int main()
{
  derived ob;

//ob.i = 10;  // illegal because i is private in derived

  ob.j = 20;  // legal because j is made public in derived
//ob.k = 30;  // illegal because k is private in derived

  ob.a = 40;  // legal because a is public in derived
  ob.seti(10);

  cout << ob.geti() << " " << ob.j << " " << ob.a;

  return 0;
}

listing 22
// This program contains an error and will not compile.
#include <iostream>
using namespace std;

class base {
public:
  int i;
};

// derived1 inherits base.
class derived1 :  public base {
public:
  int j;
};

// derived2 inherits base.
class derived2 : public base {
public:
  int k;
};

/* derived3 inherits both derived1 and derived2.
   This means that there are two copies of base
   in derived3! */
class derived3 : public derived1, public derived2 {
public:
  int sum;
};

int main()
{
  derived3 ob;

  ob.i = 10;  // this is ambiguous; which i???
  ob.j = 20;
  ob.k = 30;

  // i ambiguous here, too
  ob.sum = ob.i + ob.j + ob.k;

  // also ambiguous, which i?
  cout << ob.i << " ";

  cout << ob.j << " " << ob.k << " ";
  cout << ob.sum;

  return 0;
}

listing 23
ob.i = 20;

listing 24
// This program uses explicit scope resolution to select i.
#include <iostream>
using namespace std;

class base {
public:
  int i;
};

// derived1 inherits base.
class derived1 :  public base {
public:
  int j;
};

// derived2 inherits base.
class derived2 : public base {
public:
  int k;
};

/* derived3 inherits both derived1 and derived2.
   This means that there are two copies of base
   in derived3! */
class derived3 : public derived1, public derived2 {
public:
  int sum;
};

int main()
{
  derived3 ob;

  ob.derived1::i = 10;  // scope resolved, use derived1's i
  ob.j = 20;
  ob.k = 30;

  // scope resolved
  ob.sum = ob.derived1::i + ob.j + ob.k;

  // also resolved here
  cout << ob.derived1::i << " ";

  cout << ob.j << " " << ob.k << " ";
  cout << ob.sum;

  return 0;
}

listing 25
// This program uses virtual base classes.
#include <iostream>
using namespace std;

class base {
public:
  int i;
};

// derived1 inherits base as virtual.
class derived1 : virtual public base {
public:
  int j;
};

// derived2 inherits base as virtual.
class derived2 : virtual public base {
public:
  int k;
};

/* derived3 inherits both derived1 and derived2.
   This time, there is only one copy of base class. */
class derived3 : public derived1, public derived2 {
public:
  int sum;
};

int main()
{
  derived3 ob;

  ob.i = 10;  // now unambiguous
  ob.j = 20;
  ob.k = 30;

  // unambiguous
  ob.sum = ob.i + ob.j + ob.k;

  // unambiguous
  cout << ob.i << " ";

  cout << ob.j << " " << ob.k << " ";
  cout << ob.sum;

  return 0;
}

listing 26
// Define a class of type derived1.
derived1 myclass;

myclass.i = 88;



listing 1
B_class *p;   // pointer to object of type B_class
B_class B_ob; // object of type B_class
D_class D_ob; // object of type D_class

listing 2
p = &B_ob; // p points to object of type B_class
p = &D_ob; /* p points to object of type D_class,
               which is an object derived from B_class. */

listing 3
// Using base pointers on derived class objects.
#include <iostream>
#include <cstring> // for older compilers, use <string.h>
using namespace std;

class B_class {
  char author[80];
public:
  void put_author(char *s) { strcpy(author, s); }
  void show_author() { cout << author << "\n"; }
} ;

class D_class : public B_class {
  char title[80];
public:
  void put_title(char *num) {
    strcpy(title, num);
  }
  void show_title() {
    cout << "Title: ";
    cout <<  title << "\n";
  }
};

int main()
{
  B_class *p;
  B_class B_ob;

  D_class *dp;
  D_class D_ob;

  p = &B_ob;  // address of base

  // Access B_class via pointer.
  p->put_author("Tom Clancy");

  // Access D_class via base pointer.
  p = &D_ob;
  p->put_author("William Shakespeare");

  // Show that each author went into proper object.
  B_ob.show_author();
  D_ob.show_author();
  cout << "\n";

  /* Since put_title() and show_title() are not part
     of the base class, they are not accessible via
     the base pointer p and must be accessed either
     directly, or, as shown here, through a pointer to the
     derived type.
  */
  dp = &D_ob;
  dp->put_title("The Tempest");
  p->show_author(); // either p or dp can be used here.
  dp->show_title( );

  return 0;
}

listing 4
((D_class *)p)->show_title();

listing 5
// A short example that uses virtual functions.
#include <iostream>
using namespace std;

class base {
public:
  virtual void who() { // specify a virtual
    cout << "Base\n";
  }
};

class first_d : public base {
public:
  void who() { // redefine who() relative to first_d
    cout << "First derivation\n";
  }
};

class second_d : public base {
public:
  void who() { // redefine who() relative to second_d
    cout << "Second derivation\n";
  }
};

int main()
{
  base base_obj;
  base *p;
  first_d first_obj;
  second_d second_obj;

  p = &base_obj;
  p->who();  // access base's who

  p = &first_obj;
  p->who(); // access first_d's who

  p = &second_obj;
  p->who();  // access second_d's who
  
  return 0;
}

listing 6
first_obj.who();

listing 7
// Derive from first_d, not base.
class second_d : public first_d {
public:
  void who() { // define who() relative to second_d
    cout << "Second derivation\n";
  }
};

listing 8
#include <iostream>
using namespace std;

class base {
public:
  virtual void who() {
    cout << "Base\n";
  }
};

class first_d : public base {
public:
  void who() {
    cout << "First derivation\n";
  }
};

class second_d : public base {
// who() not defined
};

int main()
{
  base base_obj;
  base *p;
  first_d first_obj;
  second_d second_obj;

  p = &base_obj;
  p->who();  // access base's who()

  p = &first_obj;
  p->who(); // access first_d's who()

  p = &second_obj;
  p->who(); /* access base's who() because
               second_d does not redefine it */

  return 0;
}

listing 9
#include <iostream>
using namespace std;

class base {
public:
  virtual void who() {
    cout << "Base\n";
  }
};

class first_d : public base {
public:
  void who() {
    cout << "First derivation\n";
  }
};

// second_d now inherited first_d -- not base.
class second_d : public first_d {
// who() not defined
};

int main()
{
  base base_obj;
  base *p;
  first_d first_obj;
  second_d second_obj;

  p = &base_obj;
  p->who();  // access base's who()

  p = &first_obj;
  p->who(); // access first_d's who()

  p = &second_obj;
  p->who(); /* access first_d's who() because
               second_d does not redefine it */

  return 0;
}

listing 10
#include <iostream>
using namespace std;

class figure {
protected:
  double x, y;
public:
  void set_dim(double i, double j) {
    x = i;
    y = j;
  }
  virtual void show_area() {
    cout << "No area computation defined ";
    cout << "for this class.\n";
  }
} ;

class triangle : public figure {
  public:
    void show_area() {
      cout << "Triangle with height ";
      cout << x << " and base " << y;
      cout << " has an area of ";
      cout << x * 0.5 * y << ".\n";
    }
};

class rectangle : public figure {
  public:
    void show_area() {
      cout << "Rectangle with dimensions ";
      cout << x << "x" << y;
      cout << " has an area of ";
      cout << x *  y << ".\n";
    }
};

int main()
{
  figure *p; // create a pointer to base type

  triangle t; // create objects of derived types
  rectangle s;

  p = &t;
  p->set_dim(10.0, 5.0);
  p->show_area();

  p = &s;
  p->set_dim(10.0, 5.0);
  p->show_area();  
  
  return 0;
}

listing 11
class circle : public figure {
  public:
    void show_area() {
      cout << "Circle with radius ";
      cout << x;
      cout << " has an area of ";
      cout <<  3.14 * x * x;
    }
};

listing 12
#include <iostream>
using namespace std;

class figure {
protected:
  double x, y;
public:
  void set_dim(double i, double j=0) {
    x = i;
    y = j;
  }
  virtual void show_area() {
    cout << "No area computation defined ";
    cout << "for this class.\n";
  }
} ;

class triangle : public figure {
  public:
    void show_area() {
      cout << "Triangle with height ";
      cout << x << " and base " << y;
      cout << " has an area of ";
      cout << x * 0.5 * y << ".\n";
    }
};

class rectangle : public figure {
  public:
    void show_area() {
      cout << "Rectangle with dimensions ";
      cout << x << "x" << y;
      cout << " has an area of ";
      cout << x *  y << ".\n";
    }
};

class circle : public figure {
  public:
    void show_area() {
      cout << "Circle with radius ";
      cout << x;
      cout << " has an area of ";
      cout << 3.14 * x * x << ".\n";
    }
} ;
  
int main()
{
  figure *p; // create a pointer to base type

  triangle t; // create objects of derived types
  rectangle s;
  circle c;

  p = &t;
  p->set_dim(10.0, 5.0);
  p->show_area();

  p = &s;
  p->set_dim(10.0, 5.0);
  p->show_area();  

  p = &c;
  p->set_dim(9.0);
  p->show_area(); 

  return 0;
}

listing 13
class figure {
  double x, y;
public:
  void set_dim(double i, double j=0) {
    x = i;
    y = j;
  }
  virtual void show_area() = 0; // pure
};

listing 14
/* 
   This program will not compile because the class
   circle does not override show_area().
*/
#include <iostream>
using namespace std;

class figure {
protected:
  double x, y;
public:
  void set_dim(double i, double j) {
    x = i;
    y = j;
  }
  virtual void show_area() = 0; // pure
} ;

class triangle : public figure {
  public:
    void show_area() {
      cout << "Triangle with height ";
      cout << x << " and base " << y;
      cout << " has an area of ";
      cout << x * 0.5 * y << ".\n";
    }
};

class rectangle : public figure {
  public:
    void show_area() {
      cout << "Rectangle with dimensions ";
      cout << x << "x" << y;
      cout << " has an area of ";
      cout << x *  y << ".\n";
    }
};

class circle : public figure {
// no definition of show_area() will cause an error
};

int main()
{
  figure *p; // create a pointer to base type

  triangle t; // create objects of derived types
  rectangle s;

  circle c; // Illegal -- can't create!

  p = &t;
  p->set_dim(10.0, 5.0);
  p->show_area();

  p = &s;
  p->set_dim(10.0, 5.0);
  p->show_area();  

  return 0;
}


listing 1
// Function template example.
#include <iostream>
using namespace std;

// This is a function template.
template <class X> void swapargs(X &a, X &b)
{
  X temp;

  temp = a;
  a = b;
  b = temp;
}

int main()
{
  int i=10, j=20;
  double x=10.1, y=23.3;
  char a='x', b='z';

  cout << "Original i, j: " << i << ' ' << j << '\n';
  cout << "Original x, y: " << x << ' ' << y << '\n';
  cout << "Original a, b: " << a << ' ' << b << '\n';

  swapargs(i, j); // swap integers
  swapargs(x, y); // swap floats
  swapargs(a, b); // swap chars

  cout << "Swapped i, j: " << i << ' ' << j << '\n';
  cout << "Swapped x, y: " << x << ' ' << y << '\n';
  cout << "Swapped a, b: " << a << ' ' << b << '\n';

  return 0;
}

listing 2
template <class X> void swapargs(X &a, X &b)

listing 3
template <class X>
void swapargs(X &a, X &b)
{
  X temp;

  temp = a;
  a = b;
  b = temp;
}

listing 4
// This will not compile.
template <class X>
int i; // this is an error
void swapargs(X &a, X &b)
{
  X temp;

  temp = a;
  a = b;
  b = temp;
}

listing 5
#include <iostream>
using namespace std;

template <class type1, class type2>
void myfunc(type1 x, type2 y)
{
  cout << x << ' ' << y << '\n';
}

int main()
{
  myfunc(10, "hi");

  myfunc(0.23, 10L);

  return 0;
}

listing 6
// Overriding a template function.
#include <iostream>
using namespace std;

template <class X> void swapargs(X &a, X &b)
{
  X temp;

  temp = a;
  a = b;
  b = temp;
  cout << "Inside template swapargs.\n";
}

// This overrides the generic version of swapargs() for ints.
void swapargs(int &a, int &b)
{
  int temp;

  temp = a;
  a = b;
  b = temp;
  cout << "Inside swapargs int specialization.\n";
}

int main()
{
  int i=10, j=20;
  double x=10.1, y=23.3;
  char a='x', b='z';

  cout << "Original i, j: " << i << ' ' << j << '\n';
  cout << "Original x, y: " << x << ' ' << y << '\n';
  cout << "Original a, b: " << a << ' ' << b << '\n';

  swapargs(i, j); // calls explicitly overloaded swapargs()
  swapargs(x, y); // calls generic swapargs()
  swapargs(a, b); // calls generic swapargs()

  cout << "Swapped i, j: " << i << ' ' << j << '\n';
  cout << "Swapped x, y: " << x << ' ' << y << '\n';
  cout << "Swapped a, b: " << a << ' ' << b << '\n';

  return 0;
}


listing 7
// Use new-style specialization syntax.
template<> void swapargs<int>(int &a, int &b)
{
  int temp;

  temp = a;
  a = b;
  b = temp;
  cout << "Inside swapargs int specialization.\n";

}

listing 8
// Overload a function template declaration.
#include <iostream>
using namespace std;

// First version of f() template.
template <class X> void f(X a)
{
  cout << "Inside f(X a)\n";
}

// Second version of f() template.
template <class X, class Y> void f(X a, Y b)
{
  cout << "Inside f(X a, Y b)\n";
}

int main()
{
  f(10);     // calls f(X)
  f(10, 20); // calls f(X, Y)

  return 0;
}


listing 9
// Using standard parameters in a template function.
#include <iostream>
using namespace std;

// Display data specified number of times.
template<class X> void repeat(X data, int times)
{
  do {
    cout << data << "\n";
    times--;
  } while(times);
}

int main()
{
  repeat("This is a test", 3);
  repeat(100, 5);
  repeat(99.0/2, 4);

  return 0;
}

listing 10
void outdata(int i)
{
  cout << i;
}

void outdata(double d)
{
  cout << d * 3.1416;
}

listing 11
// A generic version of myabs().
#include <iostream>
using namespace std;

template <class X> X myabs(X val)
{
  return val < 0 ? -val : val;
}

int main()
{
  cout << myabs(-10) << '\n';    // integer abs

  cout << myabs(-10.0) << '\n';  // double abs

  cout << myabs(-10L) << '\n';   // long abs

  cout << myabs(-10.0F) << '\n'; // float abs

  return 0;
}

listing 12
// Demonstrate a generic queue class.
#include <iostream>
using namespace std;

const int SIZE=100;

// This creates the generic class queue.
template <class QType> class queue {
  QType q[SIZE];
  int sloc, rloc;
public:
  queue() { sloc = rloc = 0; }
  void qput(QType i);
  QType qget();
};

// Put an object into the queue.
template <class QType> void queue<QType>::qput(QType i)
{
  if(sloc==SIZE) {
    cout << "Queue is full.\n";
    return;
  }
  sloc++;
  q[sloc] = i;
}

// Get an object from the queue.
template <class QType> QType queue<QType>::qget()
{
  if(rloc == sloc) {
    cout << "Queue Underflow.\n";
    return 0;
  }
  rloc++;
  return q[rloc];
}

int main()
{
  queue<int> a, b;  // create two integer queues

  a.qput(10);
  b.qput(19);

  a.qput(20);
  b.qput(1);

  cout << a.qget() << " ";
  cout << a.qget() << " ";
  cout << b.qget() << " ";
  cout << b.qget() << "\n";

  queue<double> c, d;  // create two double queues

  c.qput(10.12);
  d.qput(19.99);

  c.qput(-20.0);
  d.qput(0.986);

  cout << c.qget() << " ";
  cout << c.qget() << " ";
  cout << d.qget() << " ";
  cout << d.qget() << "\n";

  return 0;
}

listing 13
queue<int> a, b;
queue<double> c, d;

listing 14
queue<char *> chrptrQ;

listing 15
struct addr {
  char name[40];
  char street[40];
  char city[30];
  char state[3];
  char zip[12];
};

listing 16
queue<addr> obj;

listing 17
/* This example uses two generic data types in a
   class definition.
*/
#include <iostream>
using namespace std;

template <class Type1, class Type2> class myclass
{
  Type1 i;
  Type2 j;
public:
  myclass(Type1 a, Type2 b) { i = a; j = b; }
  void show() { cout << i << ' ' << j << '\n'; }
};

int main()
{
  myclass<int, double> ob1(10, 0.23);
  myclass<char, char *> ob2('X', "This is a test");

  ob1.show(); // show int, double
  ob2.show(); // show char, char *

  return 0;
}

listing 18
// A generic safe array example.
#include <iostream>
#include <cstdlib> // for older compilers, use <stdlib.h>
using namespace std;

const int SIZE = 10;

template <class AType> class atype {
  AType a[SIZE];
public:
  atype() {
    register int i;
    for(i=0; i<SIZE; i++) a[i] = i;
  }
  AType &operator[](int i);
};

// Provide range checking for atype.
template <class AType> AType &atype<AType>::operator[](int i)
{
  if(i<0 || i> SIZE-1) {
    cout << "\nIndex value of ";
    cout << i << " is out-of-bounds.\n";
    exit(1);
  }
  return a[i];
}

int main()
{
  atype<int> intob; // integer array
  atype<double> doubleob; // double array

  int i;

  cout << "Integer array: ";
  for(i=0; i<SIZE; i++) intob[i] = i;
  for(i=0; i<SIZE; i++) cout << intob[i] << "  ";
  cout << '\n';

  cout << "Double array: ";
  for(i=0; i<SIZE; i++) doubleob[i] = (double) i/3;
  for(i=0; i<SIZE; i++) cout << doubleob[i] << "  ";
  cout << '\n';

  intob[12] = 100; // generates runtime error

  return 0;
}

listing 19
// Demonstrate non-type template arguments.
#include <iostream>
#include <cstdlib> // for older compilers, use <stdlib.h>
using namespace std;

// Here, int size is a non-type agument.
template <class AType, int size> class atype {
  AType a[size]; // length of array is passed in size
public:
  atype() {
    register int i;
    for(i=0; i<size; i++) a[i] = i;
  }
  AType &operator[](int i);
};

// Provide range checking for atype.
template <class AType, int size> 
AType &atype<AType, size>::operator[](int i)
{
  if(i<0 || i> size-1) {
    cout << "\nIndex value of ";
    cout << i << " is out-of-bounds.\n";
    exit(1);
  }
  return a[i];
}

int main()
{
  atype<int, 10> intob;       // integer array of size 10
  atype<double, 15> doubleob; // double array of size 15

  int i;

  cout << "Integer array: ";
  for(i=0; i<10; i++) intob[i] = i;
  for(i=0; i<10; i++) cout << intob[i] << "  ";
  cout << '\n';

  cout << "Double array: ";
  for(i=0; i<15; i++) doubleob[i] = (double) i/3;
  for(i=0; i<15; i++) cout << doubleob[i] << "  ";
  cout << '\n';

  intob[12] = 100; // generates runtime error

  return 0;
}

listing 20
size = 10; // Error 

listing 21
template <class X=int> class myclass { //...

listing 22
// Demonstrate default template arguments.
#include <iostream>
#include <cstdlib> // for older compilers, use <stdlib.h>
using namespace std;

// Here, AType defaults to int and size defaults to 10. 
template <class AType=int, int size=10> class atype {
  AType a[size]; // size of array is passed in size
public:
  atype() {
    register int i;
    for(i=0; i<size; i++) a[i] = i;
  }
  AType &operator[](int i);
};

// Provide range checking for atype.
template <class AType, int size> 
AType &atype<AType, size>::operator[](int i)
{
  if(i<0 || i> size-1) {
    cout << "\nIndex value of ";
    cout << i << " is out-of-bounds.\n";
    exit(1);
  }
  return a[i];
}

int main()
{
  atype<int, 100> intarray;  // integer array, size 100
  atype<double> doublearray; // double array, default size
  atype<> defarray;          // default to int array of size 10

  int i;

  cout << "int array: ";
  for(i=0; i<100; i++) intarray[i] = i;
  for(i=0; i<100; i++) cout << intarray[i] << "  ";
  cout << '\n';

  cout << "double array: ";
  for(i=0; i<10; i++) doublearray[i] = (double) i/3;
  for(i=0; i<10; i++) cout << doublearray[i] << "  ";
  cout << '\n';

  cout << "defarray array: ";
  for(i=0; i<10; i++) defarray[i] = i;
  for(i=0; i<10; i++) cout << defarray[i] << "  ";
  cout << '\n';  

  return 0;
}


listing 23
template <class AType=int, int size=10> class atype {

listing 24
// Demonstrate class specialization.
#include <iostream>
using namespace std;

template <class T> class myclass {
  T x;
public:
  myclass(T a) { 
    cout << "Inside generic myclass\n";
    x = a;
  }
  T getx() { return x; }
};

// Explicit specialization for int.
template <> class myclass<int> {
  int x;
public:
  myclass(int a) { 
    cout << "Inside myclass<int> specialization\n";
    x = a * a;
  }
  int getx() { return x; }
};

int main()
{
  myclass<double> d(10.1);
  cout << "double: " << d.getx() << "\n\n";

  myclass<int> i(5);
  cout << "int: " << i.getx() << "\n";

  return 0;
}

listing 25
template <> class myclass<int> {


listing 1
// A simple exception handling example.
#include <iostream>
using namespace std;

int main()
{
  cout << "start\n";

  try { // start a try block
    cout << "Inside try block\n";
    throw 99; // throw an error
    cout << "This will not execute";
  }
  catch (int i) { // catch an error
    cout << "Caught an exception -- value is: ";
    cout << i << "\n";
  }

  cout << "end";

  return 0;
}

listing 2
// This example will not work.
#include <iostream>
using namespace std;

int main()
{
  cout << "start\n";

  try { // start a try block
    cout << "Inside try block\n";
    throw 99; // throw an error
    cout << "This will not execute";
  }
  catch (double i) { // won't work for an int exception
    cout << "Caught an exception -- value is: ";
    cout << i << "\n";
  }

  cout << "end";

  return 0;
}

listing 3
/* Throwing an exception from a function called 
   from within a try block.
*/
#include <iostream>
using namespace std;

void Xtest(int test)
{
  cout << "Inside Xtest, test is: " << test << "\n";
  if(test) throw test;
}

int main()
{
  cout << "start\n";

  try { // start a try block
    cout << "Inside try block\n";
    Xtest(0);
    Xtest(1);
    Xtest(2);
  }
  catch (int i) { // catch an error
    cout << "Caught an exception -- value is: ";
    cout << i << "\n";
  }

  cout << "end";

  return 0;
}

listing 4
#include <iostream>
using namespace std;

// A try/catch is reset each time a function is entered.
void Xhandler(int test)
{
  try{
    if(test) throw test;
  }
  catch(int i) {
    cout << "Caught One!  Ex. #: " << i << '\n';
  }
}

int main()
{
  cout << "start\n";

  Xhandler(1);
  Xhandler(2);
  Xhandler(0);
  Xhandler(3);

  cout << "end";

  return 0;
}

listing 5
// Use an exception class.
#include <iostream>
#include <cstring>
using namespace std;

class MyException {
public:
  char str_what[80];

  MyException() { *str_what = 0; }

  MyException(char *s) {
    strcpy(str_what, s);
  }
};

int main()
{
  int a, b;

  try {
    cout << "Enter numerator and denominator: ";
    cin >> a >> b;
    if(!b)
      throw MyException("Cannot divide by zero!"); 
    else
      cout << "Quotient is " << a/b << "\n";
  }
  catch (MyException e) { // catch an error
    cout << e.str_what << "\n";
  }

  return 0;
}

listing 6
#include <iostream>
using namespace std;

// Different types of exceptions can be caught.
void Xhandler(int test)
{
  try{
    if(test) throw test;
    else throw "Value is zero";
  }
  catch(int i) {
    cout << "Caught One!  Ex. #: " << i << '\n';
  }
  catch(char *str) {
    cout << "Caught a string: ";
    cout << str << '\n';
  }
}

int main()
{
  cout << "start\n";

  Xhandler(1);
  Xhandler(2);
  Xhandler(0);
  Xhandler(3);

  cout << "end";

  return 0;
}

listing 7
// Catching derived classes.
#include <iostream>
using namespace std;

class B {
};

class D: public B {
};

int main()
{
  D derived;

  try {
    throw derived;
  }
  catch(B b) {
    cout << "Caught a base class.\n";
  }
  catch(D d) {
    cout << "This won't execute.\n";
  }

  return 0;
}

listing 8
// This example catches all exceptions.
#include <iostream>
using namespace std;

void Xhandler(int test)
{
  try{
    if(test==0) throw test; // throw int
    if(test==1) throw 'a'; // throw char
    if(test==2) throw 123.23; // throw double
  }
  catch(...) { // catch all exceptions
    cout << "Caught One!\n";
  }
}

int main()
{
  cout << "start\n";

  Xhandler(0);
  Xhandler(1);
  Xhandler(2);

  cout << "end";

  return 0;
}

listing 9
// This example uses catch(...) as a default.
#include <iostream>
using namespace std;

void Xhandler(int test)
{
  try{
    if(test==0) throw test;   // throw int
    if(test==1) throw 'a';    // throw char
    if(test==2) throw 123.23; // throw double
  }
  catch(int i) { // catch an int exception
    cout << "Caught " << i << '\n';
  }
  catch(...) { // catch all other exceptions
    cout << "Caught One!\n";
  }
}

int main()
{
  cout << "start\n";

  Xhandler(0);
  Xhandler(1);
  Xhandler(2);

  cout << "end";

  return 0;
}

listing 10
// Restricting function throw types.
#include <iostream>
using namespace std;

// This function can only throw ints, chars, and doubles.
void Xhandler(int test) throw(int, char, double)
{
  if(test==0) throw test;   // throw int
  if(test==1) throw 'a';    // throw char
  if(test==2) throw 123.23; // throw double
}

int main()
{
  cout << "start\n";

  try{
    Xhandler(0); // also, try passing 1 and 2 to Xhandler()
  }
  catch(int i) {
    cout << "Caught int\n";
  }
  catch(char c) {
    cout << "Caught char\n";
  }
  catch(double d) {
    cout << "Caught double\n";
  }

  cout << "end";

  return 0;
}

listing 11
// This function can throw NO exceptions!
void Xhandler(int test) throw()
{
  /* The following statements no longer work.  Instead,
     they will cause an abnormal program termination. */
  if(test==0) throw test;
  if(test==1) throw 'a';
  if(test==2) throw 123.23;
}

listing 12
// Example of "rethrowing" an exception.
#include <iostream>
using namespace std;

void Xhandler()
{
  try {
    throw "hello"; // throw a char *
  }
  catch(char *) { // catch a char *
    cout << "Caught char * inside Xhandler\n";
    throw ; // rethrow char * out of function
  }
}

int main()
{
  cout << "start\n";

  try{
    Xhandler();
  }
  catch(char *) {
    cout << "Caught char * inside main\n";
  }

  cout << "end";

  return 0;
}

listing 13
// Handle exceptions thrown by new.
#include <iostream>
#include <new>
using namespace std;

int main()
{
  int *p, i;

   try { 
     p = new int[32]; // allocate memory for 32-element int array
   } catch (bad_alloc xa) {
     cout << "Allocation failure.\n";
     return 1;
  }

  for(i=0; i<32; i++) p[i] = i;

  for(i=0; i<32; i++) cout << p[i] << " ";

  delete [] p; // free the memory

  return 0;
}

listing 14
// Demonstrate nothrow version of new.
#include <iostream>
#include <new>
using namespace std;

int main()
{
  int *p, i;

   p = new(nothrow) int[32]; // use nothrow option 
   if(!p) {
    cout << "Allocation failure.\n";
    return 1;
  }

  for(i=0; i<32; i++) p[i] = i;

  for(i=0; i<32; i++) cout << p[i] << " ";

  delete [] p; // free the memory

  return 0;
}

listing 15
// Allocate an object.
void *operator new(size_t size)
{
  /* Perform allocation.  Throw bad_alloc on failure.
     Constructor called automatically. */
  return pointer_to_memory;
}

// Delete an object.
void operator delete(void *p)
{
  /* Free memory pointed to by p.
     Destructor called automatically. */
}

listing 16
// Allocate an array of objects.
void *operator new[](size_t size)
{
  /* Perform allocation. Throw bad_alloc exception on failure.
      Each constructor called automatically. */
  return pointer_to_memory;
}

// Delete an array of objects.
void operator delete[](void *p)
{
  /* Free memory pointed to by p.
     Destructor for each element automatically called. */
}

listing 17
// Demonstrate overloaded new and delete.
#include <iostream>
#include <new>
#include <cstdlib>
using namespace std;

class three_d {
  int x, y, z; // 3-D coordinates
public:
  three_d() {
    x = y = z = 0;
    cout << "Constructing 0, 0, 0\n";
  }
  three_d(int i, int j, int k) {
    x = i; y = j; z = k;
    cout << "Constructing " << i << ", ";
    cout << j << ", " << k;
    cout << '\n';
  }
  ~three_d( ) { cout << "Destructing\n"; }
  void *operator new(size_t size);
  void *operator new[](size_t size);
  void operator delete(void *p);
  void operator delete[](void *p);
  void show() ;
};

// new overloaded relative to three_d.
void *three_d::operator new(size_t size)
{
  void *p;

  cout << "Allocating three_d object.\n";
  p = malloc(size);

  // throw an exception on failure
  if(!p) {
    bad_alloc ba;
    throw ba;
  }
  return p;
}
// new overloaded relative to arrays of three_d.
void *three_d::operator new[](size_t size)
{
  void *p;

  cout << "Allocating array of three_d objects.\n";

  // throw an exception on failure
  p = malloc(size);
  if(!p) {
    bad_alloc ba;
    throw ba;
  }
  return p;
}

// delete overloaded relative to three_d.
void three_d::operator delete(void *p)
{
  cout << "Deleting three_d object.\n";
  free(p);
}

// delete overloaded relative to arrays of three_d.
void three_d::operator delete[](void *p)
{
  cout << "Deleting array of three_d objects.\n";
  free(p);
}

// Show X, Y, Z coordinates.
void three_d::show()
{
  cout << x << ", ";
  cout << y << ", ";
  cout << z << "\n";
}

int main()
{
  three_d *p1, *p2;

  try {
    p1 = new three_d[3]; // allocate array
    p2 = new three_d(5, 6, 7); // allocate object
  } catch (bad_alloc ba) {
    cout << "Allocation error.\n";
    return 1;
  }

  p1[1].show();
  p2->show();

  delete [] p1; // delete array
  delete p2;    // delete object

  return 0;
}

listing 18
int *f = new int; // uses default new

listing 19
// Nothrow version of new. 
void *operator new(size_t size, const nothrow_t &n) 
{ 
  // Perform allocation.   
  if(success) return pointer_to_memory; 
  else return 0; 
} 
 
// Nothrow version of new for arrays. 
void *operator new[](size_t size, const nothrow_t &n) 
{ 
  // Perform allocation.   
  if(success) return pointer_to_memory; 
  else return 0; 
} 
 
// Nothrow version of delete. 
void operator delete(void *p, const nothrow_t &n) 
{ 
  // free memory 
} 
 
// Nothrow version of delete for arrays. 
void operator delete[](void *p, const nothrow_t &n) 
{ 
  // free memory 
}



listing 1
class three_d {
public:
  int x, y, z; // 3-D coordinates
  three_d(int a, int b, int c) { x = a; y = b; z = c; }
};

listing 2
// Display X, Y, Z coordinates - three_d inserter.
ostream &operator<<(ostream &stream, three_d obj)
{
  stream << obj.x << ", ";
  stream << obj.y << ", ";
  stream << obj.z << "\n";
  return stream;  // return the stream
}

listing 3
// Demonstrate a custom inserter.
#include <iostream>
using namespace std;

class three_d {
public:
  int x, y, z; // 3-D coordinates
  three_d(int a, int b, int c) { x = a; y = b; z = c; }
} ;

// Display X, Y, Z coordinates - three_d inserter.
ostream &operator<<(ostream &stream, three_d obj)
{
  stream << obj.x << ", ";
  stream << obj.y << ", ";
  stream << obj.z << "\n";
  return stream;  // return the stream
}

int main()
{
  three_d a(1, 2, 3), b(3, 4, 5), c(5, 6, 7);

  cout << a << b << c;

  return 0;
}

listing 4
ostream &operator<<(ostream &stream, class_type obj)
{
  // class specific code goes here
  return stream;  // return the stream
}

listing 5
// Limited version - don't use.
ostream &operator<<(ostream &stream, three_d obj)
{
  cout << obj.x << ", ";
  cout << obj.y << ", ";
  cout << obj.z << "\n";
  return stream;  // return the stream
}

listing 6
// Use a friend to overload <<.
#include <iostream>
using namespace std;

class three_d {
  int x, y, z; // 3-D coordinates - now private
public:
  three_d(int a, int b, int c) { x = a; y = b; z = c; }
  friend ostream &operator<<(ostream &stream, three_d obj);
} ;

// Display X, Y, Z coordinates - three_d inserter.
ostream &operator<<(ostream &stream, three_d obj)
{
  stream << obj.x << ", ";
  stream << obj.y << ", ";
  stream << obj.z << "\n";
  return stream;  // return the stream
}

int main()
{
  three_d a(1, 2, 3), b(3, 4, 5), c(5, 6, 7);

  cout << a << b << c;

  return 0;
}

listing 7
// Get three-dimensional values - three_d extractor.
istream &operator>>(istream &stream, three_d &obj)
{
  cout << "Enter X,Y,Z values: ";
  stream >> obj.x >> obj.y >> obj.z;
  return stream;
}

listing 8
istream &operator>>(istream &stream, object_type &obj)
{
  // put your extractor code here
  return stream;
}

listing 9
// Demonstrate a custom extractor.
#include <iostream>
using namespace std;

class three_d {
  int x, y, z; // 3-D coordinates
public:
  three_d(int a, int b, int c) { x = a; y = b; z = c; }
  friend ostream &operator<<(ostream &stream, three_d obj);
  friend istream &operator>>(istream &stream, three_d &obj);
} ;

// Display X, Y, Z coordinates - three_d inserter.
ostream &operator<<(ostream &stream, three_d obj)
{
  stream << obj.x << ", ";
  stream << obj.y << ", ";
  stream << obj.z << "\n";
  return stream; // return the stream
}

// Get three dimensional values - three_d extractor.
istream &operator>>(istream &stream, three_d &obj)
{
  cout << "Enter X,Y,Z values: ";
  stream >> obj.x >> obj.y >> obj.z;
  return stream;
}

int main()
{
  three_d a(1, 2, 3);

  cout << a;

  cin >> a;
  cout << a;

  return 0;
}

listing 10
struct my_struct {
  int count;
  char s[80];
  double balance;
} cust;

listing 11
stream.setf(ios::showbase);

listing 12
#include <iostream>
using namespace std;

int main()
{
  cout.setf(ios::showpos);
  cout.setf(ios::scientific);
  cout << 123 << " " << 123.23 << " ";

  return 0;
}

listing 13
cout.setf(ios::scientific | ios::showpos);

listing 14
#include <iostream>
using namespace std;

void showflags(ios::fmtflags f);

int main()
{
  ios::fmtflags f;

  f = cout.flags();

  showflags(f);
  cout.setf(ios::showpos);
  cout.setf(ios::scientific);

  f = cout.flags();
  showflags(f);

  cout.unsetf(ios::scientific);

  f = cout.flags();
  showflags(f);

  return 0;
}

void showflags(ios::fmtflags f)
{
  long i;

  for(i=0x4000; i; i = i >> 1)
    if(i & f) cout << "1 ";
    else cout << "0 ";

  cout << "\n";
}

listing 15
#include <iostream>
using namespace std;

int main()
{
  cout.setf(ios::showpos);
  cout.setf(ios::scientific);
  cout << 123 << " " << 123.23 << "\n";

  cout.precision(2); // two digits after decimal point
  cout.width(10);    // in a field of 10 characters
  cout << 123 << " ";
  cout.width(10);    // set width to 10
  cout << 123.23 << "\n";

  cout.fill('#');  // fill using #
  cout.width(10);  // in a field of 10 characters
  cout << 123 << " ";
  cout.width(10);  // set width to 10
  cout << 123.23;

  return 0;
}

listing 16
#include <iostream>
#include <iomanip>
using namespace std;

int main()
{
  cout << setprecision(2) << 1000.243 << endl;
  cout << setw(20) << "Hello there.";

  return 0;
}

listing 17
#include <iostream>
#include <iomanip>
using namespace std;

int main()
{
  cout << setiosflags(ios::showpos);
  cout << setiosflags(ios::scientific);
  cout << 123 << " " << 123.23;

  return 0;
}

listing 18
#include <iostream>
using namespace std;

int main()
{
  char s[80];

  cin >> ws >> s;
  cout << s;

  return 0;
}

listing 19
#include <iostream>
#include <iomanip>
using namespace std;

ostream &setup(ostream &stream)
{
  stream.setf(ios::left);
  stream << setw(10) << setfill('$');
  return stream;
}

int main()
{
  cout << 10 << " " << setup << 10;

  return 0;
}

listing 20
istream &manip_name(istream &stream)
{
  // your code here

  return stream;
}

listing 21
#include <iostream>
#include <iomanip>
using namespace std;

istream &prompt(istream &stream)
{
  cin >> hex;
  cout << "Enter number using hex format: ";

  return stream;
}

int main()
{
  int i;

  cin >> prompt >> i;
  cout << i;

  return 0;
}

listing 22
ifstream in;  // input
ofstream out; // output
fstream both; // input and output

listing 23
ofstream out;
out.open("test");

listing 24
if(!mystream) {
  cout << "Cannot open file.\n";
  // handle error
}

listing 25
if(!mystream.is_open()) {
  cout << "File is not open.\n";
  // ...

listing 26
ifstream mystream("myfile"); // open file for input

listing 27
mystream.close();

listing 28
// Write to file.
#include <iostream>
#include <fstream>
using namespace std;

int main()
{
  ofstream out("test");
  if(!out) {
    cout << "Cannot open file.\n";
    return 1;
   }

  out << 10 << " " << 123.23 << "\n";
  out << "This is a short text file.";

  out.close();

  return 0;
}

listing 29
// Read from file.
#include <iostream>
#include <fstream>
using namespace std;

int main()
{
  char ch;
  int i;
  float f;
  char str[80];

  ifstream in("test");
  if(!in) {
    cout << "Cannot open file.\n";
    return 1;
  }

  in >> i;
  in >> f;
  in >> ch;
  in >> str;

  cout << i << " " << f << " " << ch << "\n";
  cout << str;

  in.close();
  return 0;
}

listing 30
// Display a file using get().
#include <iostream>
#include <fstream>
using namespace std;

int main(int argc, char *argv[])
{
  char ch;

  if(argc!=2) {
    cout << "Usage: PR <filename>\n";
    return 1;
  }

  ifstream in(argv[1], ios::in | ios::binary);
  if(!in) {
    cout << "Cannot open file.\n";
    return 1;
  }

  while(in) { // in will be false when eof is reached
    in.get(ch);
    if(in) cout << ch;
  }

  in.close();

  return 0;
}

listing 31
while(in.get(ch))
  cout << ch;

listing 32
// Use put() to write to a file.
#include <iostream>
#include <fstream>
using namespace std;

int main()
{
  char *p = "hello there";

  ofstream out("test", ios::out | ios::binary);
  if(!out) {
    cout << "Cannot open file.\n";
    return 1;
   }

  while(*p) out.put(*p++);

  out.close();

  return 0;
}

listing 33
// Use read() and write().
#include <iostream>
#include <fstream>
using namespace std;

int main()
{
  int n[5] = {1, 2, 3, 4, 5};
  register int i;

  ofstream out("test", ios::out | ios::binary);
  if(!out) {
    cout << "Cannot open file.\n";
    return 1;
   }

  out.write((char *) &n, sizeof n);

  out.close();

  for(i=0; i<5; i++) // clear array
    n[i] = 0;

  ifstream in("test", ios::in | ios::binary);
  if(!in) {
    cout << "Cannot open file.\n";
    return 1;
  }

  in.read((char *) &n, sizeof n);

  for(i=0; i<5; i++) // show values read from file
    cout << n[i] << " ";

  in.close();

  return 0;
}

listing 34
// Detect end-of-file using eof().
#include <iostream>
#include <fstream>
using namespace std;

int main(int argc, char *argv[])
{
  char ch;

  if(argc!=2) {
    cout << "Usage: PR <filename>\n";
    return 1;
  }

  ifstream in(argv[1], ios::in | ios::binary);
  if(!in) {
    cout << "Cannot open file.\n";
    return 1;
  }

  while(!in.eof()) { // use eof()
    in.get(ch);
    if(!in.eof()) cout << ch;
  }

  in.close();

  return 0;
}

listing 35
// Compare files.
#include <iostream> 
#include <fstream> 
using namespace std; 
 
int main(int argc, char *argv[]) 
{ 
  register int i; 
 
  unsigned char buf1[1024], buf2[1024]; 
 
  if(argc!=3) { 
    cout << "Usage: compfiles <file1> <file2>\n"; 
    return 1; 
  } 
 
  ifstream f1(argv[1], ios::in | ios::binary); 
  if(!f1) { 
    cout << "Cannot open first file.\n"; 
    return 1; 
  } 
  ifstream f2(argv[2], ios::in | ios::binary); 
  if(!f2) { 
    cout << "Cannot open second file.\n"; 
    return 1; 
   } 
 
  cout << "Comparing files...\n"; 
 
  do { 
    f1.read((char *) buf1, sizeof buf1); 
    f2.read((char *) buf2, sizeof buf2); 

    if(f1.gcount() != f2.gcount()) {
      cout << "Files are of differing sizes.\n";
      f1.close(); 
      f2.close(); 
      return 0;
    }

    // compare contents of buffers 
    for(i=0; i<f1.gcount(); i++) 
      if(buf1[i] != buf2[i]) { 
        cout << "Files differ.\n"; 
        f1.close(); 
        f2.close(); 
        return 0; 
      } 
 
  } while(!f1.eof() && !f2.eof()); 
 
  cout << "Files are the same.\n"; 
 
  f1.close(); 
  f2.close(); 
 
  return 0; 
}

listing 36
// Use getline() to read a string that contains spaces.
#include <iostream>
#include <fstream>
using namespace std;

int main()
{
  char str[80];

  cout << "Enter your name: ";
  cin.get(str, 79);

  cout << str << '\n';

  return 0;
}

listing 37
// Demonstrate random access.
#include <iostream>
#include <fstream>
#include <cstdlib>
using namespace std;

int main(int argc, char *argv[])
{
  if(argc!=3) {
    cout << "Usage: CHANGE <filename> <byte>\n";
    return 1;
  }

  fstream out(argv[1], ios::in | ios::out | ios::binary);
  if(!out) {
    cout << "Cannot open file.\n";
    return 1;
  }

  out.seekp(atoi(argv[2]), ios::beg);

  out.put('X');
  out.close();

  return 0;
}

listing 38
// Display a file from a given starting point.
#include <iostream>
#include <fstream>
#include <cstdlib>
using namespace std;

int main(int argc, char *argv[])
{
  char ch;

  if(argc!=3) {
    cout << "Usage: NAME <filename> <starting location>\n";
    return 1;
  }

  ifstream in(argv[1], ios::in | ios::binary);
  if(!in) {
    cout << "Cannot open file.\n";
    return 1;
  }

  in.seekg(atoi(argv[2]), ios::beg);

  while(in.get(ch))
    cout << ch;

  return 0;
}

listing 39
/* Use overloaded inserter to write three_d
   objects to a file. */
#include <iostream>
#include <fstream>
using namespace std;

class three_d {
  int x, y, z; // 3-D coordinates -- now private
public:
  three_d(int a, int b, int c) { x = a; y = b; z = c; }
  friend ostream &operator<<(ostream &stream, three_d obj);
};

// Display X, Y, Z coordinates - three_d inserter.
ostream &operator<<(ostream &stream, three_d obj)
{
  stream << obj.x << ", ";
  stream << obj.y << ", ";
  stream << obj.z << "\n";
  return stream;  // return the stream
}

int main()
{
  three_d a(1, 2, 3), b(3, 4, 5), c(5, 6, 7);
  ofstream out("threed");

  if(!out) {
    cout << "Cannot open file.";
    return 1;
  }

  out << a << b << c;

  out.close();

  return 0;
}




listing 1
// A simple example that uses typeid.
#include <iostream>
#include <typeinfo>
using namespace std;

class myclass {
  // ...
};

int main()
{
  int i, j;
  float f;
  myclass ob;

  cout << "The type of i is: " << typeid(i).name();
  cout << endl;
  cout << "The type of f is: " << typeid(f).name();
  cout << endl;
  cout << "The type of ob is: " << typeid(ob).name();
  cout << "\n\n";

  if(typeid(i) == typeid(j))
    cout << "The types of i and j are the same\n";

  if(typeid(i) != typeid(f))
    cout << "The types of i and f are not the same\n";

  return 0;
}


listing 2
// An example that uses typeid on a polymorphic class heirarchy.
#include <iostream>
#include <typeinfo>
using namespace std;

class Base {
  virtual void f() {}; // make Base polymorphic
  // ...
};

class Derived1: public Base {
  // ...
};

class Derived2: public Base {
  // ...
};

int main()
{
  Base *p, baseob;
  Derived1 ob1;
  Derived2 ob2;

  p = &baseob;
  cout << "p is pointing to an object of type ";
  cout << typeid(*p).name() << endl;

  p = &ob1;
  cout << "p is pointing to an object of type ";
  cout << typeid(*p).name() << endl;

  p = &ob2;
  cout << "p is pointing to an object of type ";
  cout << typeid(*p).name() << endl;

  return 0;
}

listing 3
// Use a reference with typeid.
#include <iostream>
#include <typeinfo>
using namespace std;

class Base {
  virtual void f() {}; // make Base polymorphic
  // ...
};

class Derived1: public Base {
  // ...
};

class Derived2: public Base {
  // ...
};

// Demonstrate typeid with a reference parameter.
void WhatType(Base &ob)
{
  cout << "ob is referencing an object of type ";
  cout << typeid(ob).name() << endl;
}


int main()
{
  int i;
  Base baseob;
  Derived1 ob1;
  Derived2 ob2;

  WhatType(baseob);
  WhatType(ob1);
  WhatType(ob2);

  return 0;
}

listing 4
cout << typeid(int).name();

listing 5
// Demonstrating run-time type id.
#include <iostream>
using namespace std;

class figure {
protected:
  double x, y;
public:
  figure(double i, double j) {
    x = i;
    y = j;
  }
  virtual double area() = 0;
} ;

class triangle : public figure {
  public:
    triangle(double i, double j) : figure(i, j) {}
    double area() {
      return x * 0.5 * y;
    }
};

class rectangle : public figure {
  public:
    rectangle(double i, double j) : figure(i, j) {}
    double area() {
      return x * y;
    }
};

class circle : public figure {
  public:
    circle(double i, double j=0) : figure(i, j) {}
    double area() {
      return 3.14 * x * x;
    }
} ;

// A factory for objects derived from figure.
figure *factory()
{
  switch(rand() % 3 ) {
    case 0: return new circle(10.0);
    case 1: return new triangle(10.1, 5.3);
    case 2: return new rectangle(4.3, 5.7);
  }
  return 0; 
}
  
int main()
{
  figure *p; // pointer to base class
  int i;

  int t=0, r=0, c=0;

  // generate and count objects
  for(i=0; i<10; i++) {
    p = factory(); // generate an object

    cout << "Object is " << typeid(*p).name();
    cout << ".  ";

    // count it
    if(typeid(*p) == typeid(triangle)) t++;
    if(typeid(*p) == typeid(rectangle)) r++;
    if(typeid(*p) == typeid(circle)) c++;

    // display its area
    cout << "Area is " << p->area() << endl;
  }

  cout << endl;
  cout << "Objects generated:\n";
  cout << "  Triangles: " << t << endl;
  cout << "  Rectangles: " << r << endl;
  cout << "  Circles: " << c << endl;

  return 0;
}

listing 6
// Using typeid with templates.
#include <iostream>
using namespace std;

template <class T> class myclass {
  T a;
public:
  myclass(T i) { a = i; }
  // ...
};

int main()
{
  myclass<int> o1(10), o2(9);
  myclass<double> o3(7.2);

  cout << "Type of o1 is ";
  cout << typeid(o1).name() << endl;

  cout << "Type of o2 is ";
  cout << typeid(o2).name() << endl;

  cout << "Type of o3 is ";
  cout << typeid(o3).name() << endl;

  cout << endl;

  if(typeid(o1) == typeid(o2)) 
    cout << "o1 and o2 are the same type\n";
 
  if(typeid(o1) == typeid(o3))
    cout << "Error\n";
  else
    cout << "o1 and o3 are different types\n";

  return 0;
}

listing 7
// Template version of the figure heirarchy.
#include <iostream>
using namespace std;

template <class T> class figure {
protected:
  T x, y;
public:
  figure(T i, T j) {
    x = i;
    y = j;
  }
  virtual T area() = 0;
} ;

template <class T> class triangle : public figure<T> {
  public:
    triangle(T i, T j) : figure<T>(i, j) {}
    T area() {
      return x * 0.5 * y;
    }
};

template <class T> class rectangle : public figure<T> {
  public:
    rectangle(T i, T j) : figure<T>(i, j) {}
    T area() {
      return x * y;
    }
};

template <class T> class circle : public figure<T> {
  public:
    circle(T i, T j=0) : figure<T>(i, j) {}
    T area() {
      return 3.14 * x * x;
    }
} ;

// A factory for objects derived from figure.
figure<double> *generator()
{
  switch(rand() % 3 ) {
    case 0: return new circle<double>(10.0);
    case 1: return new triangle<double>(10.1, 5.3);
    case 2: return new rectangle<double>(4.3, 5.7);
  }
  return 0; 
}
  
int main()
{
  figure<double> *p; 
  int i;
  int t=0, c=0, r=0;

  // generate and count objects
  for(i=0; i<10; i++) {
    p = generator();

    cout << "Object is " << typeid(*p).name();
    cout << ".  ";

    // count it
    if(typeid(*p) == typeid(triangle<double>)) t++;
    if(typeid(*p) == typeid(rectangle<double>)) r++;
    if(typeid(*p) == typeid(circle<double>)) c++;

    cout << "Area is " << p->area() << endl;
  }

  cout << endl;
  cout << "Objects generated:\n";
  cout << "  Triangles: " << t << endl;
  cout << "  Rectangles: " << r << endl;
  cout << "  Circles: " << c << endl;

  return 0;
}


listing 8
Base *bp, b_ob;
Derived *dp, d_ob;

bp = &d_ob; // base pointer points to Derived object
dp = dynamic_cast<Derived *> (bp); // cast to derived pointer OK
if(dp) cout << "Cast OK";

listing 9
bp = &b_ob; // base pointer points to Base object
dp = dynamic_cast<Derived *> (bp); // error
if(!dp) cout << "Cast Fails";

listing 10
// Demonstrate dynamic_cast.
#include <iostream>
using namespace std;

class Base {
public:
  virtual void f() { cout << "Inside Base\n"; } 
  // ...
};

class Derived : public Base {
public:
  void f() { cout << "Inside Derived\n"; }
};

int main()
{
  Base *bp, b_ob;
  Derived *dp, d_ob;

  dp = dynamic_cast<Derived *> (&d_ob);
  if(dp) {
    cout << "Cast from Derived * to Derived * OK.\n";
    dp->f();
  } else
    cout << "Error\n";

  cout << endl;

  bp = dynamic_cast<Base *> (&d_ob);
  if(bp) {
    cout << "Cast from Derived * to Base * OK.\n";
    bp->f();
  } else 
    cout << "Error\n"; 

  cout << endl;

  bp = dynamic_cast<Base *> (&b_ob);
  if(bp) {
    cout << "Cast from Base * to Base * OK.\n";
    bp->f();
  } else 
    cout << "Error\n"; 

  cout << endl;

  dp = dynamic_cast<Derived *> (&b_ob);
  if(dp) 
    cout << "Error\n";
  else
    cout << "Cast from Base * to Derived * not OK.\n";

  cout << endl;

  bp = &d_ob; // bp points to Derived object
  dp = dynamic_cast<Derived *> (bp);
  if(dp) {
    cout << "Casting bp to a Derived * OK\n" <<
      "because bp is really pointing\n" <<
      "to a Derived object.\n";
    dp->f();
  } else 
    cout << "Error\n";

  cout << endl;

  bp = &b_ob; // bp points to Base object
  dp = dynamic_cast<Derived *> (bp);
  if(dp)
    cout << "Error";
  else {
    cout << "Now casting bp to a Derived *\n" <<
      "is not OK because bp is really \n" <<
      "pointing to a Base object.\n";
  }  
  
  cout << endl;

  dp = &d_ob; // dp points to Derived object
  bp = dynamic_cast<Base *> (dp);
  if(bp) {
    cout << "Casting dp to a Base * is OK.\n";
    bp->f();
  } else
    cout << "Error\n";  
  
  return 0;
}

listing 11
Base *bp;
Derived *dp;
// ...
if(typeid(*bp) == typeid(Derived)) dp = (Derived *) bp;

listing 12
dp = dynamic_cast<Derived *> (bp);

listing 13
// Use dynamic_cast to replace typeid.
#include <iostream>
#include <typeinfo>
using namespace std;

class Base {
public:
  virtual void f() {} 
};

class Derived : public Base {
public:
  void derivedOnly() {
    cout << "Is a Derived Object\n";
  }
};

int main()
{
  Base *bp, b_ob;
  Derived *dp, d_ob;

  // ************************************
  // use typeid
  // ************************************
  bp = &b_ob;
  if(typeid(*bp) == typeid(Derived)) {
    dp = (Derived *) bp;
    dp->derivedOnly();
  }
  else 
    cout << "Cast from Base to Derived failed.\n";

  bp = &d_ob;
  if(typeid(*bp) == typeid(Derived)) {
    dp = (Derived *) bp;
    dp->derivedOnly();
  }
  else
    cout << "Error, cast should work!\n";

  // ************************************
  // use dynamic_cast
  // ************************************
  bp = &b_ob;
  dp = dynamic_cast<Derived *> (bp);
  if(dp) dp->derivedOnly();
  else 
    cout << "Cast from Base to Derived failed.\n";

  bp = &d_ob; 
  dp = dynamic_cast<Derived *> (bp);
  if(dp) dp->derivedOnly();
  else
    cout << "Error, cast should work!\n";

  return 0;
}

listing 14
// Demonstrate const_cast.
#include <iostream>
using namespace std;

void f(const int *p)
{
  int *v;

  // cast away const-ness.
  v = const_cast<int *> (p);

  *v = 100; // now, modify object through v
}

int main()
{
  int x = 99;

  cout << "x before call: " << x << endl;
  f(&x);
  cout << "x after call: " << x << endl;

  return 0;
}

listing 15
// Use static_cast.
#include <iostream>
using namespace std;

int main()
{
  int i;
  float f;

  f = 199.22F;

  i = static_cast<int> (f);

  cout << i;

  return 0;
}

listing 16
// An example that uses reinterpret_cast.
#include <iostream>
using namespace std;

int main()
{
  int i;
  char *p = "This is a string";

  i = reinterpret_cast<int> (p); // cast pointer to integer

  cout << i;

  return 0;
}



listing 1
namespace CounterNameSpace {
  int upperbound;
  int lowerbound;

  class counter {
     int count;
   public:
     counter(int n) { 
       if(n <= upperbound) count = n;
       else count = upperbound;
     }

     void reset(int n) {
       if(n <= upperbound) count = n;
     }

     int run() {
       if(count > lowerbound) return count--;
       else return lowerbound;
     }
  };
}

listing 2
if(count > lowerbound) return count--;

listing 3
CounterNameSpace::upperbound = 10;

listing 4
CounterNameSpace::counter ob;

listing 5
// Demonstrate a namespace.
#include <iostream>
using namespace std;

namespace CounterNameSpace {
  int upperbound;
  int lowerbound;

  class counter {
     int count;
   public:
     counter(int n) { 
       if(n <= upperbound) count = n;
       else count = upperbound;
     }

     void reset(int n) {
       if(n <= upperbound) count = n;
     }

     int run() {
       if(count > lowerbound) return count--;
       else return lowerbound;
     }
  };
}

int main()
{
  CounterNameSpace::upperbound = 100;
  CounterNameSpace::lowerbound = 0;

  CounterNameSpace::counter ob1(10);
  int i;

  do {
    i = ob1.run();
    cout << i << " ";
  } while(i > CounterNameSpace::lowerbound);
  cout << endl;

  CounterNameSpace::counter ob2(20);

  do {
    i = ob2.run();
    cout << i << " ";
  } while(i > CounterNameSpace::lowerbound);
  cout << endl;

  ob2.reset(100);
  CounterNameSpace::lowerbound = 90;
  do {
    i = ob2.run();
    cout << i << " ";
  } while(i > CounterNameSpace::lowerbound);

  return 0;
}

listing 6
namespace NS {
  int i;
}

// ...

namespace NS {
  int j;
}

listing 7
using CounterNameSpace::lowerbound; // only lowerbound is visible
lowerbound = 10; // OK because lowerbound is visible

using namespace CounterNameSpace; // all members are visible
upperbound = 100; // OK because all members are now visible

listing 8
// Demonstrate using.
#include <iostream>
using namespace std;

namespace CounterNameSpace {
  int upperbound;
  int lowerbound;

  class counter {
     int count;
   public:
     counter(int n) { 
       if(n <= upperbound) count = n;
       else count = upperbound;
     }

     void reset(int n) {
       if(n <= upperbound) count = n;
     }

     int run() {
       if(count > lowerbound) return count--;
       else return lowerbound;
     }
  };
}

int main()
{
  // use only upperbound from CounterNameSpace
  using CounterNameSpace::upperbound; 

  // now, no qualification needed to set upperbound 
  upperbound = 100;

  // qualification still needed for lowerbound, etc.
  CounterNameSpace::lowerbound = 0;

  CounterNameSpace::counter ob1(10);
  int i;

  do {
    i = ob1.run();
    cout << i << " ";
  } while(i > CounterNameSpace::lowerbound);
  cout << endl;

  // Now, use entire CounterNameSpace
  using namespace CounterNameSpace;

  counter ob2(20);

  do {
    i = ob2.run();
    cout << i << " ";
  } while(i > lowerbound);
  cout << endl;

  ob2.reset(100);
  lowerbound = 90;
  do {
    i = ob2.run();
    cout << i << " ";
  } while(i > lowerbound);

  return 0;
}

listing 9
using namespace std;

listing 10
// Use explicit std:: qualification.
#include <iostream>

int main()
{
  double val;

  std::cout << "Enter a number: ";

  std::cin >> val;

  std::cout << "This is your number: ";
  std::cout << val;

  return 0;
}

listing 11
// Bring only a few names into the global namespace.
#include <iostream>

// gain access to cout and cin
using std::cout;
using std::cin;

int main()
{
  double val;

  cout << "Enter a number: ";

  cin >> val;
  cout << "This is your number: ";
  cout << val;

  return 0;
}

listing 12
#include <iostream>
using namespace std;

void vline(int i), hline(int i);

int main()
{
  void (*p)(int i);

  p = vline; // point to vline()

  (*p)(4); // call vline()

  p = hline; // point to hline()

  (*p)(3); // call hline()

  return 0;
}

void hline(int i)
{
   for( ;i; i--) cout << "-";
   cout << "\n";
}

void vline(int i)
{
  for( ; i; i--) cout << "|\n";
}

listing 13
(*p)(4);

listing 14
p(4); 


listing 15
#include <iostream>
#include <cstdlib>
#include <cstring>
using namespace std;

int comp(const void *a, const void *b);

int main()
{
  char str[] = "Function pointers provide flexibility.";

  qsort(str, strlen(str), 1, comp);
  cout << "sorted string: " << str;

  return 0;
}

int comp(const void *a, const void *b)
{
  return * (char *) a - * (char *) b;
}

listing 16
#include <iostream>
#include <cstdlib>
using namespace std;

int comp(const void *a, const void *b);

int main()
{
  int num[] = {10, 4, 3, 6, 5 ,7 ,8};
  int i;

  qsort(num, 7, sizeof(int), comp);

  for(i=0; i<7; i++)
    cout << num[i] << ' ';

  return 0;
}

int comp(const void *a, const void *b)
{
  return * (int *) a - * (int *) b;
}

listing 17
/* Illustrate assigning function pointers to
   overloaded functions. */
#include <iostream>
using namespace std;

// Output count number of spaces.
void space(int count)
{
  for( ; count; count--) cout << ' ';
}

// Output count number of chs.
void space(int count, char ch)
{
  for( ; count; count--) cout << ch;
}

int main()
{
  /* Create a pointer to void function with
     one int parameter. */
  void (*fp1)(int);

  /* Create a pointer to void function with
     one int parameter and one character parameter. */
  void (*fp2)(int, char);

  fp1 = space; // gets address of space(int)

  fp2 = space; // gets address of space(int, char)

  fp1(22);  // output 22 spaces - same as (*fp1)(22)
  cout << "|\n";

  fp2(30, 'x'); // output 30 xs - same as (*fp2)(30, 'x')
  cout << "|\n";

  return 0;
}

listing 18
#include <iostream>
using namespace std;

class ShareVar {
  static int num;
public:
  void setnum(int i) { num = i; };
  void shownum() { cout << num << " "; }
};

int ShareVar::num; // define num

int main()
{
  ShareVar a, b;

  a.shownum(); // prints 0
  b.shownum(); // prints 0

  a.setnum(10); // set static num to 10

  a.shownum(); // prints 10
  b.shownum(); // also prints 10

  return 0;
}

listing 19
class X {
  int some_var;
public:
  int f1() const; // const member function
};

listing 20
/*
   Demonstrate const member functions.
   This program won't compile.
*/
#include <iostream>
using namespace std;

class Demo {
  int i;
public:
  int geti() const {
    return i; // ok
  }

  void seti(int x) const {
    i = x; // error!
  }
};

int main()
{
  Demo ob;

  ob.seti(1900); 
  cout << ob.geti();

  return 0;
}

listing 21
// Demonstrate mutable.
#include <iostream>
using namespace std;

class Demo {
  mutable int i;
  int j;
public:
  int geti() const {
    return i; // ok
  }

  void seti(int x) const {
    i = x; // now, OK.
  }

/* The following function won't compile.
  void setj(int x) const {
    j = x; // Still Wrong!
  }
*/
};

int main()
{
  Demo ob;

  ob.seti(1900); 
  cout << ob.geti();

  return 0;
}

listing 22
#include <iostream>
using namespace std;

class myclass {
  int a;
public:
  myclass(int x) { a = x; } 
  int geta() { return a; }
};
 
int main()
{
  myclass ob(4);

  cout << ob.geta();

  return 0;
}

listing 23
myclass ob = 4; // automatically converts into myclass(4)

listing 24
myclass ob(4);

listing 25
#include <iostream>
using namespace std;

class myclass {
  int a;
public:
  explicit myclass(int x) { a = x; } 
  int geta() { return a; }
};

listing 26
myclass ob(110); 

listing 27
#include <iostream>
using namespace std;

class myclass {
  int num;
public:
  myclass(int i) { num = i; }
  int getnum() { return num; }
};

int main()
{
  myclass o(10);

  cout << o.getnum() << endl; // displays 10

  // now, use implicit conversion to assign new value
  o = 1000;

  cout << o.getnum() << endl; // displays 1000

  return 0;
}
  
listing 28
o = 1000;

listing 29
#include <iostream> 
using namespace std; 
 
class myclass { 
  int numA; 
  int numB; 
public: 
  /* Initialize numA and numB inside the myclass constructor 
     using normal syntax. */ 
  myclass(int x, int y) { 
    numA = x; 
    numB = y; 
  } 
 
  int getNumA() { return numA; } 
  int getNumB() { return numB; } 
}; 
 
int main() 
{ 
  myclass ob1(7, 9), ob2(5, 2); 
 
  cout << "Values in ob1 are " << ob1.getNumB() <<
          " and " << ob1.getNumA() << endl; 
 
  cout << "Values in ob2 are " << ob2.getNumB() <<
          " and " << ob2.getNumA() << endl;
  
  return 0; 
}

listing 30
#include <iostream> 
using namespace std; 
 
class myclass { 
  const int numA; // const member
  const int numB; // const member
public: 
  // Initialize numA and numB using initialization syntax.
  myclass(int x, int y) : numA(x), numB(y) { } 
 
  int getNumA() { return numA; } 
  int getNumB() { return numB; } 
}; 
 
int main() 
{ 
  myclass ob1(7, 9), ob2(5, 2); 
 
  cout << "Values in ob1 are " << ob1.getNumB() <<
          " and " << ob1.getNumA() << endl; 
 
  cout << "Values in ob2 are " << ob2.getNumB() <<
          " and " << ob2.getNumA() << endl;
  
  return 0; 
}

listing 31
#include <iostream>
using namespace std;

extern "C" void myCfunc();

int main()
{
  myCfunc();

  return 0;
}

// This will link as a C function.
void myCfunc()
{
  cout << "This links as a C function.\n";
}

listing 32
// Pointer-to-member example.
#include <iostream>
using namespace std;

class myclass {
public:
  int sum;
  void myclass::sum_it(int x);
};

void myclass::sum_it(int x) {
  int i;

  sum = 0;
  for(i=x; i; i--) sum += i;
}

int main()
{
  int myclass::*dp;  // pointer to an integer class member
  void (myclass::*fp)(int x); // pointer to member function
  myclass c;

  dp = &myclass::sum;  // get address of data
  fp = &myclass::sum_it; // get address of function

  (c.*fp)(7);  // compute summation of 7
  cout << "summation of 7 is " << c.*dp;

  return 0;
}

listing 33
#include <iostream>
using namespace std;

class myclass {
public:
  int sum;
  void myclass::sum_it(int x);
};

void myclass::sum_it(int x) {
  int i;

  sum = 0;
  for(i=x; i; i--) sum += i;
}

int main()
{
  int myclass::*dp;  // pointer to an integer class member
  void (myclass::*fp)(int x); // pointer to member function
  myclass *c, d; // c is now a pointer to an object

  c = &d; // give c the address of an object

  dp = &myclass::sum;  // get address of data
  fp = &myclass::sum_it; // get address of function

  (c->*fp)(7);  // now, use ->* to call function
  cout << "summation of 7 is " << c->*dp; // use ->*

  return 0;
}

listing 34
operator int() { return x * y * z; }

listing 35
#include <iostream>
using namespace std;

class three_d {
  int x, y, z; // 3-D coordinates
public:
  three_d(int a, int b, int c) { x = a; y = b; z = c; }

  three_d operator+(three_d op2) ;
  friend ostream &operator<<(ostream &stream, three_d &obj);

  operator int() {return x * y * z; }
} ;

// Display X, Y, Z coordinates - three_d inserter.
ostream &operator<<(ostream &stream, three_d &obj)
{
  stream << obj.x << ", ";
  stream << obj.y << ", ";
  stream << obj.z << "\n";
  return stream;  // return the stream
}

three_d three_d::operator+(three_d op2)
{
  three_d temp(0, 0, 0);

  temp.x = x+op2.x;
  temp.y = y+op2.y;
  temp.z = z+op2.z;
  return temp;
}

int main()
{
  three_d a(1, 2, 3), b(2, 3, 4);

  cout << a << b;

  cout <<  b+100;  // displays 124 because of conversion to int
  cout << "\n";

  a = a + b; // add two three_d objects - no conversion

  cout << a;  // displays 3, 5, 7 

  return 0;
}








listing 1
vector<int> iv;           // create zero-length int vector
vector<char> cv(5);       // create 5-element char vector
vector<char> cv(5,  'x'); // initialize a 5-element char vector 
vector<int> iv2(iv);      // create int vector from an int vector

listing 2
// Vector basics.
#include <iostream>
#include <vector>
using namespace std;

int main()
{
  vector<int> v; // create zero-length vector
  unsigned int i;

  // display original size of v
  cout << "Size = " << v.size() << endl;

  /* put values onto end of vector --
     vector will grow as needed */
  for(i=0; i<10; i++) v.push_back(i);

  // display current size of v
  cout << "Current contents:\n";
  cout << "Size now = " << v.size() << endl;

  // display contents of vector
  for(i=0; i<v.size(); i++) cout << v[i] << " ";
  cout << endl;

  /* put more values onto end of vector --
     again, vector will grow as needed */
  for(i=0; i<10; i++) v.push_back(i+10);

  // display current size of v
  cout << "Size now = " << v.size() << endl;

  // display contents of vector
  cout << "Current contents:\n";
  for(i=0; i<v.size(); i++) cout << v[i] << " ";
  cout << endl;

  // change contents of vector
  for(i=0; i<v.size(); i++) v[i] = v[i] + v[i];

  // display contents of vector
  cout << "Contents doubled:\n";
  for(i=0; i<v.size(); i++) cout << v[i] << " ";
  cout << endl;

  return 0;
}

listing 3
// Access a vector using an iterator.
#include <iostream>
#include <vector>
using namespace std;

int main()
{
  vector<char> v; // create zero-length vector
  int i;

  // put values into a vector
  for(i=0; i<10; i++) v.push_back('A' + i);

  // can access vector contents using subscripting
  for(i=0; i<10; i++) cout << v[i] << " ";
  cout << endl;

  // access via iterator
  vector<char>::iterator p = v.begin();
  while(p != v.end()) {
    cout << *p << " ";
    p++;
  }

  return 0;
}

listing 4
// Demonstrate insert and erase.
#include <iostream>
#include <vector>
using namespace std;

int main()
{
  vector<char> v;
  unsigned int i;

  for(i=0; i<10; i++) v.push_back('A' + i);

  // display original contents of vector
  cout << "Size = " << v.size() << endl;
  cout << "Original contents:\n";
  for(i=0; i<v.size(); i++) cout << v[i] << " ";
  cout << endl << endl;

  vector<char>::iterator p = v.begin();
  p += 2; // point to 3rd element

  // insert 10 X's into v
  v.insert(p, 10, 'X');

  // display contents after insertion
  cout << "Size after insert = " << v.size() << endl;
  cout << "Contents after insert:\n";
  for(i=0; i<v.size(); i++) cout << v[i] << " ";
  cout << endl << endl;

  // remove those elements
  p = v.begin();
  p += 2; // point to 3rd element
  v.erase(p, p+10); // remove next 10 elements

  // display contents after deletion
  cout << "Size after erase = " << v.size() << endl;
  cout << "Contents after erase:\n";
  for(i=0; i<v.size(); i++) cout << v[i] << " ";
  cout << endl;

  return 0;
}


listing 5
// Store a class object in a vector. 
#include <iostream>
#include <vector>
using namespace std;

class three_d {
  int x, y, z; 
public:
  three_d() { x = y = z = 0; }
  three_d(int a, int b, int c) { x = a; y = b; z = c; }

  three_d &operator+(int a) {
    x += a;
    y += a;
    z += a;
    return *this;
  }

  friend ostream &operator<<(ostream &stream, three_d obj);
  friend bool operator<(three_d a, three_d b);
  friend bool operator==(three_d a, three_d b);
} ;

// Display X, Y, Z coordinates - three_d inserter.
ostream &operator<<(ostream &stream, three_d obj)
{
  stream << obj.x << ", ";
  stream << obj.y << ", ";
  stream << obj.z << "\n";
  return stream;  // return the stream
}

bool operator<(three_d a, three_d b)
{
  return (a.x + a.y + a.z) < (b.x + b.y + b.z);
}

bool operator==(three_d a, three_d b)
{
  return (a.x + a.y + a.z) == (b.x + b.y + b.z);
}

int main()
{
  vector<three_d> v;
  unsigned int i;

  // add objects to a vector
  for(i=0; i<10; i++)
    v.push_back(three_d(i, i+2, i-3));

  // display contents of vector
  for(i=0; i<v.size(); i++)
    cout << v[i];

  cout << endl;

  // modify objects in a vector
  for(i=0; i<v.size(); i++)
    v[i] = v[i] + 10;

  // display modified vector
  for(i=0; i<v.size(); i++)
    cout << v[i];

  return 0;
}

listing 6
// Insert one vector into another.
#include <iostream>
#include <vector>
using namespace std;

int main()
{
  vector<char> v, v2;
  unsigned int i;

  for(i=0; i<10; i++) v.push_back('A' + i);

  // display original contents of vector
  cout << "Original contents:\n";
  for(i=0; i<v.size(); i++) cout << v[i] << " ";
  cout << endl << endl;

  // initialize second vector
  char str[] = "-STL Power-";
  for(i = 0; str[i]; i++) v2.push_back(str[i]);

  /* get iterators to the middle of v and
     the start and end of v2 */
  vector<char>::iterator p = v.begin()+5;
  vector<char>::iterator p2start = v2.begin();
  vector<char>::iterator p2end = v2.end();  

  // insert v2 into v
  v.insert(p, p2start, p2end);

  // display result
  cout << "Contents of v after insertion:\n";
  for(i=0; i<v.size(); i++) cout << v[i] << " ";

  return 0;
}

listing 7
// List basics.
#include <iostream>
#include <list>
using namespace std;

int main()
{
  list<char> lst; // create an empty list
  int i;

  for(i=0; i<10; i++) lst.push_back('A'+i);

  cout << "Size = " << lst.size() << endl;

  cout << "Contents: ";
  list<char>::iterator p = lst.begin();
  while(p != lst.end()) {
    cout << *p;
    p++;
  }

  return 0;
}

listing 8
list<char>::iterator p = lst.begin();
while(p != lst.end()) {
  cout << *p;
  p++;
}

listing 9
// Elements can be put on the front or end of a list.
#include <iostream>
#include <list>
using namespace std;

int main()
{
  list<char> lst;
  list<char> revlst;
  int i;

  for(i=0; i<10; i++) lst.push_back('A'+i);

  cout << "Size of lst = " << lst.size() << endl;
  cout << "Original contents: ";

  list<char>::iterator p;
  
  /* Remove elements from lst and put them
     into revlst in reverse order. */
  while(!lst.empty()) {
    p = lst.begin();
    cout << *p;
    lst.pop_front();
    revlst.push_front(*p);
  }
  cout << endl << endl;
  
  cout << "Size of revlst = ";
  cout << revlst.size() << endl;
  cout << "Reversed contents: ";
  p = revlst.begin();
  while(p != revlst.end()) {
    cout << *p;
    p++;
  }
    
  return 0;
}

listing 10
// Sort a list.
#include <iostream>
#include <list>
#include <cstdlib>
using namespace std;

int main()
{
  list<int> lst;
  int i;

  // create a list of random integers
  for(i=0; i<10; i++)
    lst.push_back(rand());

  cout << "Original contents:\n";
  list<int>::iterator p = lst.begin();
  while(p != lst.end()) {
    cout << *p << " ";
    p++;
  }
  cout << endl << endl;

  // sort the list
  lst.sort();

  cout << "Sorted contents:\n";
  p = lst.begin();
  while(p != lst.end()) {
    cout << *p << " ";
    p++;
  }
  
  return 0;
}

listing 11
// Merge two lists.
#include <iostream>
#include <list>
using namespace std;

int main()
{
  list<char> lst1, lst2;
  int i;

  for(i=0; i<10; i+=2) lst1.push_back('A'+i);
  for(i=1; i<11; i+=2) lst2.push_back('A'+i);

  cout << "Contents of lst1: ";
  list<char>::iterator p = lst1.begin();
  while(p != lst1.end()) {
    cout << *p;
    p++;
  }
  cout << endl << endl;

  cout << "Contents of lst2: ";
  p = lst2.begin();
  while(p != lst2.end()) {
    cout << *p;
    p++;
  }
  cout << endl << endl;

  // now, merge the two lists
  lst1.merge(lst2);
  if(lst2.empty())
    cout << "lst2 is now empty\n";

  cout << "Contents of lst1 after merge:\n";
  p = lst1.begin();
  while(p != lst1.end()) {
    cout << *p;
    p++;
  }

  return 0;
}

listing 12
// Store class objects in a list.
#include <iostream>
#include <list>
#include <cstring>
using namespace std;

class myclass {
  int a, b;
  int sum;
public:
  myclass() { a = b = 0; }
  myclass(int i, int j) {
    a = i;
    b = j;
    sum = a + b;
  }
  int getsum() { return sum; }

  friend bool operator<(const myclass &o1,
                        const myclass &o2);
  friend bool operator>(const myclass &o1,
                        const myclass &o2);
  friend bool operator==(const myclass &o1,
                        const myclass &o2);
  friend bool operator!=(const myclass &o1,
                        const myclass &o2);
};

bool operator<(const myclass &o1, const myclass &o2)
{
  return o1.sum < o2.sum;
}

bool operator>(const myclass &o1, const myclass &o2)
{
  return o1.sum > o2.sum;
}

bool operator==(const myclass &o1, const myclass &o2)
{
  return o1.sum == o2.sum;
}

bool operator!=(const myclass &o1, const myclass &o2)
{
  return o1.sum != o2.sum;
}

int main()
{
  int i;

  // create first list
  list<myclass> lst1;
  for(i=0; i<10; i++) lst1.push_back(myclass(i, i));

  cout << "First list: ";
  list<myclass>::iterator p = lst1.begin();
  while(p != lst1.end()) {
    cout << p->getsum() << " ";
    p++;
  }
  cout << endl;

  // create a second list
  list<myclass> lst2;
  for(i=0; i<10; i++) lst2.push_back(myclass(i*2, i*3));

  cout << "Second list: ";
  p = lst2.begin();
  while(p != lst2.end()) {
    cout << p->getsum() << " ";
    p++;
  }
  cout << endl;

  // now, merget lst1 and lst2
  lst1.merge(lst2);

  // display merged list
  cout << "Merged list: ";
  p = lst1.begin();
  while(p != lst1.end()) {
    cout << p->getsum() << " ";
    p++;
  }

  return 0;
}


listing 13
// A simple map demonstration.
#include <iostream>
#include <map>
using namespace std;

int main()
{
  map<char, int> m;
  int i;

  // put pairs into map
  for(i=0; i<10; i++) {
    m.insert(pair<char, int>('A'+i, i));
  }

  char ch;
  cout << "Enter key: ";
  cin >> ch;

  map<char, int>::iterator p;
  
  // find value given key
  p = m.find(ch);
  if(p != m.end()) 
    cout << p->second;
  else
    cout << "Key not in map.\n";

  return 0;
}

listing 14
m.insert(make_pair((char)('A'+i), i));

listing 15
// Use a map to create a dictionary.
#include <iostream>
#include <map>
#include <cstring>
using namespace std;

class word {
  char str[20];
public:
  word() { strcpy(str, ""); }
  word(char *s) { strcpy(str, s); }
  char *get() { return str; }

};

// must define less than relative to word objects
bool operator<(word a, word b)
{
   return strcmp(a.get(), b.get()) < 0;
}

class meaning {
  char str[80];
public:
  meaning() { strcmp(str, ""); }
  meaning(char *s) { strcpy(str, s); }
  char *get() { return str; }
};


int main()
{
  map<word, meaning> dictionary;

 // put words and meanings into map
  dictionary.insert(pair<word, meaning>(word("house"),
                    meaning("A place of dwelling.")));
  dictionary.insert(pair<word, meaning>(word("keyboard"),
                    meaning("An input device.")));
  dictionary.insert(pair<word, meaning>(word("programming"),
             meaning("The act of writing a program.")));
  dictionary.insert(pair<word, meaning>(word("STL"),
                    meaning("Standard Template Library")));

  // given a word, find meaning
  char str[80];
  cout << "Enter word: ";
  cin >> str;

  map<word, meaning>::iterator p;
  
  p = dictionary.find(word(str));
  if(p != dictionary.end()) 
    cout << "Definition: " <<  p->second.get();
  else
    cout << "Word not in dictionary.\n";

  return 0;
}

listing 16
// Demonstrate count and count_if.
#include <iostream>
#include <vector>
#include <algorithm>
#include <cctype>
using namespace std;

/* This is a unary predicate that determines 
   if character is isvowel. */
bool isvowel(char ch) 
{
  ch = tolower(ch);
  if(ch=='a' || ch=='e' || ch=='i'
     || ch=='o' || ch=='u' || ch=='y') return true;

  return false;
}

int main()
{
  char str[] = "STL programming is powerful.";
  vector<char> v;
  unsigned int i;

  for(i=0; str[i]; i++) v.push_back(str[i]);

  cout << "Sequence: ";
  for(i=0; i<v.size(); i++) cout << v[i];
  cout << endl;

  int n;
  n = count(v.begin(), v.end(), 'p');
  cout << n << " characters are p\n";

  n = count_if(v.begin(), v.end(), isvowel);
  cout << n << " characters are vowels.\n";

  return 0;
}

listing 17
// Demonstrate remove_copy and replace_copy.
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main()
{
  char str[] = "This is a test.";
  vector<char> v, v2(20); 
  unsigned int i;

  for(i=0; str[i]; i++) v.push_back(str[i]);

  // **** demonstrate remove_copy ****

  cout << "Input sequence: ";
  for(i=0; i<v.size(); i++) cout << v[i];
  cout << endl;

  // Remove all i's
  remove_copy(v.begin(), v.end(), v2.begin(), 'i');

  cout << "Result after removing i's: ";
  for(i=0; i<v2.size(); i++) cout << v2[i];
  cout << endl << endl;

  // **** now, demonstrate replace_copy ****

  cout << "Input sequence: ";
  for(i=0; i<v.size(); i++) cout << v[i];
  cout << endl;

  // Remove replace s's with X's
  replace_copy(v.begin(), v.end(), v2.begin(), 's', 'X');

  cout << "Result after repacing s's with X's: ";
  for(i=0; i<v2.size(); i++) cout << v2[i];
  cout << endl << endl;

  return 0;
}


listing 18
// Demonstrate reverse.
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main()
{
  vector<int> v;
  unsigned int i;

  for(i=0; i<10; i++) v.push_back(i);

  cout << "Initial: ";
  for(i=0; i<v.size(); i++) cout << v[i] << " ";
  cout << endl;

  reverse(v.begin(), v.end());

  cout << "Reversed: ";
  for(i=0; i<v.size(); i++) cout << v[i] << " ";

  return 0;
}

listing 19
// An example of the transform algorithm.
#include <iostream>
#include <list>
#include <algorithm>
using namespace std;

// A simple transformation function.
int xform(int i) {
  return i * i; // square original value
}

int main()
{
  list<int> xl;
  int i;

  // put values into list
  for(i=0; i<10; i++) xl.push_back(i);

  cout << "Original contents of xl: ";
  list<int>::iterator p = xl.begin();
  while(p != xl.end()) {
    cout << *p << " ";
    p++;
  }

  cout << endl;
 
  // transform xl
  p = transform(xl.begin(), xl.end(), xl.begin(), xform);

  cout << "Transformed contents of xl: ";
  p = xl.begin();
  while(p != xl.end()) {
    cout << *p << " ";
    p++;
  }

  return 0;
}

listing 20
char s1[80], s2[80], s3[80];

s1 = "one"; // can't do
s2 = "two"; // can't do 
s3 = s1 + s2; // error, not allowed

listing 21
strcpy(s1, "one");
strcpy(s2, "two");
strcpy(s3, s1);
strcat(s3, s2);

listing 22
// A short string demonstration.
#include <iostream>
#include <string>
using namespace std;

int main()
{
  string str1("The string class gives ");
  string str2("C++ high-powered string handling.");
  string str3;

  // assign a string
  str3 = str1; 
  cout << str1 << "\n" << str3 << "\n";

  // concatenate two strings
  str3 = str1 + str2; 
  cout << str3 << "\n";

  // compare strings
  if(str3 > str1) cout << "str3 > str1\n";
  if(str3 == str1+str2)
    cout << "str3 == str1+str2\n";

  /* A string object can also be 
     assigned a normal string. */
  str1 = "This is a null-terminated string.\n";
  cout << str1;

  // create a string object using another string object
  string str4(str1);
  cout << str4;

  // input a string
  cout << "Enter a string: ";
  cin >> str4;
  cout << str4;

  return 0;
}

listing 23
// Demonstrate insert(), erase(), and replace().
#include <iostream>
#include <string>
using namespace std;

int main()
{
  string str1("This is a test");
  string str2("ABCDEFG");

  cout << "Initial strings:\n";
  cout << "str1: " << str1 << endl;
  cout << "str2: " << str2 << "\n\n";

  // demonstrate insert()
  cout << "Insert str2 into str1:\n";
  str1.insert(5, str2);
  cout << str1 << "\n\n";

  // demonstrate erase()
  cout << "Remove 7 characters from str1:\n";
  str1.erase(5, 7);
  cout << str1 <<"\n\n";

  // demonstrate replace 
  cout << "Replace 2 characters in str1 with str2:\n";
  str1.replace(5, 2, str2);
  cout << str1 << endl;
  
  return 0;
}

listing 24
#include <iostream>
#include <string>
using namespace std;

int main()
{
  int i;
  string s1 =
    "The string class makes string handling easy.";
  string s2;

   i = s1.find("class");
   if(i!=string::npos) {
     cout << "Match found at " << i << endl;
     cout << "Remaining string is: ";
     s2.assign(s1, i, s1.size());
     cout << s2;
  }

  return 0;
}

listing 25
// Use a map of strings to create a dictionary.
#include <iostream>
#include <map>
#include <string>
using namespace std;

int main()
{
  map<string, string> dictionary;

  dictionary.insert(pair<string, string>("house",
                    "A place of dwelling."));
  dictionary.insert(pair<string, string>("keyboard",
                    "An input device."));
  dictionary.insert(pair<string, string>("programming",
                    "The act of writing a program."));
  dictionary.insert(pair<string, string>("STL",
                    "Standard Template Library"));

  string s;
  cout << "Enter word: ";
  cin >> s;

  map<string, string>::iterator p;
  
  p = dictionary.find(s);
  if(p != dictionary.end()) 
    cout << "Definition: " << p->second;
  else
    cout << "Word not in dictionary.\n";

  return 0;
}







listing 1
#define UP 1
#define DOWN 0

listing 2
cout << UP << ' ' << DOWN << ' ' << UP + UP;

listing 3
#define ONE   1
#define TWO   ONE+ONE
#define THREE ONE+TWO

listing 4
#define GETFILE "Enter File Name"

.
.
.

cout << GETFILE;

listing 5
cout << "Enter File Name";

listing 6
#define GETFILE "Enter File Name"
.
.
.
cout << "GETFILE is a macro name\n";

listing 7
#define LONG_STRING "this is a very long \
string that is used as an example"

listing 8
#define MAX_SIZE 100
// ...
float balance[MAX_SIZE];
double indexMAX_SIZE;
int num_emp[MAX_SIZE]; 

listing 9
// Use a function-like macro.
#include <iostream>
using namespace std;

#define MIN(a,b)  (((a)<(b)) ? a : b)

int main()
{
  int x, y;

  x = 10;
  y = 20;
  cout << "The minimum is " << MIN(x, y);

  return 0;
}

listing 10
cout << "The minimum is: " << ((x)<(y)) ? x : y);

listing 11
// This program will give the wrong answer.
#include <iostream>
using namespace std;

#define EVEN(a) a%2==0 ? 1 : 0

int main()
{
  if(EVEN(9+1)) cout << "is even";
  else cout << "is odd";

  return 0;
}

listing 12
9+1%2==0 ? 1 : 0

listing 13
// This program is now fixed.
#include <iostream>
using namespace std;

#define EVEN(a) (a)%2==0 ? 1 : 0

int main()
{
  if(EVEN(9+1)) cout << "is even";
  else cout << "is odd";

  return 0;
}

listing 14
#include <vector>

listing 15
#include <sample.h>
#include "sample.h"

listing 16
// A simple #if example.
#include <iostream>
using namespace std;

#define MAX 100
int main()
{
#if MAX>10
  cout << "Extra memory required.\n";
#endif

  // ...
  return 0;
}

listing 17
// A simple #if/#else example.
#include <iostream>
using namespace std;

#define MAX 6
int main()
{
#if MAX>10
  cout << "Extra memory required.\n");
#else
  cout << "Current memory OK.\n";
#endif

  // ...

  return 0;
}

listing 18
#define JOHN 0
#define BOB 1
#define TOM 2

#define COMPILED_BY JOHN

#if COMPILED_BY == JOHN
  char who[] = "John";
#elif COMPILED_BY == BOB
  char who[] = "Bob";
#else
  char who[] = "Tom";
#endif

listing 19
#if COMPILED_BY == BOB
   #if DEBUG == FULL
      int port = 198;
   #elif DEBUG == PARTIAL
      int port = 200;
   #endif
#else
   cout << "Bob must compile for debug output.\n";
#endif

listing 20
#include <iostream>
using namespace std;

#define TOM

int main()
{
#ifdef TOM
  cout << "Programmer is Tom.\n";
#else
  cout << "Programmer is unknown.\n";
#endif
#ifndef RALPH
  cout << "RALPH not defined.\n";
#endif
  return 0;
}

listing 21
#define TIMEOUT 100
#define WAIT 0

// ...

#undef TIMEOUT
#undef WAIT

listing 22
#if defined MYFILE

listing 24
#if !defined DEBUG
  cout << "Final version!\n";
#endif

listing 25
#include <iostream>
using namespace std;

#line 200            // set line counter to 200
int main()           // now this is line 200
{                    // this is line 201
  cout <<  __LINE__; // prints 202

  return 0;
}

listing 26
#include <iostream>
using namespace std;

#define mkstr(s)  # s

int main()
{
  cout << mkstr(I like C++);

  return 0;
}

listing 27
cout << mkstr(I like C++);

listing 28
cout << "I like C++";

listing 29
#include <iostream>
using namespace std;

#define concat(a, b)  a ## b

int main()
{
  int xy = 10;

  cout << concat(x, y);

  return 0;
}

listing 30
cout << concat(x, y);

listing 31
cout << xy;







************************************************************


listing 1
// Create a Triangle class. 
 
#include <iostream>  
#include <cmath> 
using namespace std;  
 
class Triangle { 
  double height; 
  double base; 
public: 
  Triangle(double h, double b) { 
    height = h; 
    base = b; 
  } 
 
  double hypot() { 
    return sqrt(height*height + base*base); 
  } 
 
  double area() { 
    return base * height / 2.0; 
  } 
}; 
 
int main() 
{ 
  Triangle t1(3.0, 4.0); 
  Triangle t2(4.5, 6.75); 
 
  cout << "Hypotenuse of t1: " << 
    t1.hypot() << "\n"; 
  cout << "Area of t1: " << 
    t1.area() << "\n"; 
 
  cout << "Hypotenuse of t2: " << 
    t2.hypot() << "\n"; 
  cout << "Area of t2: " << 
    t2.area() << "\n"; 
 
  return 0; 
}

listing 2
/*  
   Enhanced Project 8-1  
  
   Add user ID to Help class. 
*/  
  
#include <iostream>  
using namespace std;  
 
// A class that encapsulates a help system.   
class Help { 
  int userID; 
public: 
  Help(int id) { userID = id; } 
 
  ~Help() { cout << "Terminating help for #" << 
            userID << ".\n"; } 
 
  int getID() { return userID; } 
 
  void helpon(char what); 
  void showmenu(); 
  bool isvalid(char ch); 
}; 
 
// Display help information. 
void Help::helpon(char what) { 
  switch(what) {  
    case '1':  
      cout << "The if:\n\n";  
      cout << "if(condition) statement;\n";  
      cout << "else statement;\n";  
      break;  
    case '2':  
      cout << "The switch:\n\n";  
      cout << "switch(expression) {\n";  
      cout << "  case constant:\n";  
      cout << "    statement sequence\n";  
      cout << "    break;\n";  
      cout << "  // ...\n";  
      cout << "}\n";  
      break;  
    case '3':  
      cout << "The for:\n\n";  
      cout << "for(init; condition; iteration)";  
      cout << " statement;\n";  
      break;  
    case '4':  
      cout << "The while:\n\n";  
      cout << "while(condition) statement;\n";  
      break;  
    case '5':  
      cout << "The do-while:\n\n";  
      cout << "do {\n";  
      cout << "  statement;\n";  
      cout << "} while (condition);\n";  
      break;  
    case '6':  
      cout << "The break:\n\n";  
      cout << "break;\n";  
      break;  
    case '7':  
      cout << "The continue:\n\n";  
      cout << "continue;\n";  
      break;  
    case '8':  
      cout << "The goto:\n\n";  
      cout << "goto label;\n";  
      break;  
  }  
  cout << "\n";  
}  
 
// Show the help menu. 
void Help::showmenu() { 
  cout << "Help on:\n";  
  cout << "  1. if\n";  
  cout << "  2. switch\n";  
  cout << "  3. for\n";  
  cout << "  4. while\n";  
  cout << "  5. do-while\n";  
  cout << "  6. break\n";  
  cout << "  7. continue\n";  
  cout << "  8. goto\n";  
  cout << "Choose one (q to quit): ";  
} 
 
// Return true if a selection is valid. 
bool Help::isvalid(char ch) {  
  if(ch < '1' || ch > '8' && ch != 'q') 
    return false; 
  else 
    return true; 
} 
 
int main() 
{ 
  char choice; 
  Help hlpob(27); // create an instance of the Help class. 
   
  cout << "User ID is " << hlpob.getID() << 
          ".\n"; 
 
  // Use the Help object to display information. 
  for(;;) { 
    do { 
      hlpob.showmenu(); 
      cin >> choice; 
    } while(!hlpob.isvalid(choice)); 
  
    if(choice == 'q') break; 
    cout << "\n"; 
 
    hlpob.helpon(choice); 
  } 
  
  return 0;  
}


listing 2
// Set intersection. 
Set Set::operator &(Set ob2) {  
  Set newset; 
 
  // Add elements common to both sets. 
  for(int i=0; i < len; i++) 
    if(ob2.find(members[i]) != -1) // add if element in both sets 
      newset = newset + members[i]; 
 
  return newset; // return set 
}





listing 1
// Use static to count function invocations. 
 
#include <iostream> 
using namespace std; 
 
int counter(); 
 
int main() 
{ 
  int result; 
 
  for(int i=0; i<10; i++) 
    result = counter(); 
 
  cout << "Function called " <<  
       result << " times." << "\n"; 
 
  return 0; 
} 
 
int counter() 
{ 
  static count = 0; 
 
  count++; 
  
  return count; 
}

listing 2
// Use rotations to encode a message. 
 
#include <iostream> 
#include <cstring> 
using namespace std; 
 
unsigned char rrotate(unsigned char val, int n); 
unsigned char lrotate(unsigned char val, int n); 
void show_binary(unsigned int u); 
 
int main() 
{ 
  char msg[] = "This is a test."; 
  char *key = "xanadu"; 
  int klen = strlen(key); 
  int rotnum; 
 
  cout << "Original message: " << msg << "\n"; 
 
  // Encode the message by left-rotating. 
  for(int i = 0 ; i < strlen(msg); i++) { 
    /* Left-rotate each letter by a value 
       derived from the key string. */ 
    rotnum = key[i%klen] % 8; 
    msg[i] = lrotate(msg[i], rotnum); 
  } 
 
  cout << "Encoded message: " << msg << "\n"; 
 
  // Decode the message by right-rotating. 
  for(int i = 0 ; i < strlen(msg); i++) { 
    /* Right-rotate each letter by a value 
       derived from the key string. */ 
    rotnum = key[i%klen] % 8; 
 
    msg[i] = rrotate(msg[i], rotnum); 
  } 
 
  cout << "Decoded message: " << msg << "\n"; 
 
  return 0; 
} 
 
// Left-rotate a byte n places. 
unsigned char lrotate(unsigned char val, int n) 
{ 
  unsigned int t; 
 
  t = val; 
 
  for(int i=0; i < n; i++) { 
    t = t << 1; 
 
    /* If a bit shifts out, it will be in bit 8 
       of the integer t. If this is the case, 
       put that bit on the right side. */ 
    if(t & 256) 
      t = t | 1; // put a 1 on the right end 
  } 
 
  return t; // return the lower 8 bits. 
} 
 
// Right-rotate a byte n places. 
unsigned char rrotate(unsigned char val, int n) 
{ 
  unsigned int t; 
 
  t = val; 
 
  // First, move the value 8 bits higher. 
  t = t << 8; 
 
  for(int i=0; i < n; i++) { 
    t = t >> 1; 
 
    /* If a bit shifts out, it will be in bit 7 
       of the integer t. If this is the case, 
       put that bit on the left side. */ 
    if(t & 128)  
      t = t | 32768; // put a 1 on left end 
  } 
 
  /* Finally, move the result back to the 
     lower 8 bits of t. */ 
  t = t >> 8; 
 
  return t; 
} 
 
// Display the bits within a byte. 
void show_binary(unsigned int u) 
{ 
  int t; 
 
  for(t=128; t>0; t = t/2) 
    if(u & t) cout << "1 "; 
    else cout << "0 "; 
 
  cout << "\n"; 
}


listing 1
#include <iostream> 
#include <cmath> 
using namespace std; 
 
void round(double &num); 
 
int main() 
{ 
  double i = 100.4; 
 
  cout << i << " rounded is "; 
  round(i); 
  cout << i << "\n"; 
 
  i = -10.9; 
  cout << i << " rounded is "; 
  round(i); 
  cout << i << "\n"; 
 
  return 0; 
} 
 
void round(double &num) 
{ 
  double frac; 
  double val; 
 
  // decompose num into whole and fractional parts 
  frac =  modf(num, &val); 
 
  if(frac < 0.5) num = val; 
  else num = val+1.0; 
}

listing 2
#include <iostream>  
using namespace std;  
  
// Swap args and return minimum. 
int & min_swap(int &x, int &y);  
  
int main()  
{  
  int i, j, min;  
  
  i = 10;  
  j = 20;  
  
  cout << "Initial values of i and j: ";  
  cout << i << ' ' << j << '\n';  
  
  min = min_swap(j, i);  
  
  cout << "Swapped values of i and j: ";  
  cout << i << ' ' << j << '\n';  
  
 
  cout << "Minimum value is " << min << "\n"; 
  return 0;  
}  
  
// Swap args and return minimum. 
int &min_swap(int &x, int &y)  
{  
  int temp;  
  
  // use references to exchange the values of the arguments  
  temp = x;   
  x = y;      
  y = temp;   
 
  // return reference to minimum arg 
  if(x < y) return x; 
  else return y; 
}

listing 3
/*  
   Project 6-1 -- updated for Mastery Check 
 
   Create overloaded println() functions 
   that display various types of data. 
 
   This version includes an indentation parameter. 
*/ 
 
#include <iostream> 
using namespace std; 
 
// These output a newline. 
void println(bool b, int ident=0); 
void println(int i, int ident=0); 
void println(long i, int ident=0); 
void println(char ch, int ident=0); 
void println(char *str, int ident=0); 
void println(double d, int ident=0); 
 
// These functions do not output a newline. 
void print(bool b, int ident=0); 
void print(int i, int ident=0); 
void print(long i, int ident=0); 
void print(char ch, int ident=0); 
void print(char *str, int ident=0); 
void print(double d, int ident=0); 
 
int main() 
{ 
  println(true, 10); 
  println(10, 5); 
  println("This is a test"); 
  println('x'); 
  println(99L, 10); 
  println(123.23, 10); 
 
  print("Here are some values: "); 
  print(false); 
  print(88, 3); 
  print(100000L, 3); 
  print(100.01); 
 
  println(" Done!"); 
 
  return 0; 
} 
 
// Here are the println() functions. 
void println(bool b, int ident) 
{ 
  if(ident) 
    for(int i=0; i < ident; i++) cout << ' '; 
 
  if(b) cout << "true\n"; 
  else cout << "false\n"; 
} 
 
void println(int i, int ident) 
{ 
  if(ident) 
    for(int i=0; i < ident; i++) cout << ' '; 
 
  cout << i << "\n"; 
} 
 
void println(long i, int ident) 
{ 
  if(ident) 
    for(int i=0; i < ident; i++) cout << ' '; 
 
  cout << i << "\n"; 
} 
 
void println(char ch, int ident) 
{ 
  if(ident) 
    for(int i=0; i < ident; i++) cout << ' '; 
 
  cout << ch << "\n"; 
} 
 
void println(char *str, int ident) 
{ 
  if(ident) 
    for(int i=0; i < ident; i++) cout << ' '; 
 
  cout << str << "\n"; 
} 
 
void println(double d, int ident) 
{ 
  if(ident) 
    for(int i=0; i < ident; i++) cout << ' '; 
 
  cout << d << "\n"; 
} 
 
// Here are the print() functions. 
void print(bool b, int ident) 
{ 
  if(ident) 
    for(int i=0; i < ident; i++) cout << ' '; 
 
  if(b) cout << "true"; 
  else cout << "false"; 
} 
 
void print(int i, int ident) 
{ 
  if(ident) 
    for(int i=0; i < ident; i++) cout << ' '; 
 
  cout << i; 
} 
 
void print(long i, int ident) 
{ 
  if(ident) 
    for(int i=0; i < ident; i++) cout << ' '; 
 
  cout << i; 
} 
 
void print(char ch, int ident) 
{ 
  if(ident) 
    for(int i=0; i < ident; i++) cout << ' '; 
 
  cout << ch; 
} 
 
void print(char *str, int ident) 
{ 
  if(ident) 
    for(int i=0; i < ident; i++) cout << ' '; 
 
  cout << str; 
} 
 
void print(double d, int ident) 
{ 
  if(ident) 
    for(int i=0; i < ident; i++) cout << ' '; 
 
  cout << d; 
}

listing 1
#include <iostream> 
#include <cmath> 
using namespace std; 
 
double hypot(double a, double b); 
 
int main() { 
   
  cout << "Hypotenuse of a 3 by 4 right triangle: "; 
  cout << hypot(3.0, 4.0) << "\n"; 
 
  return 0; 
} 
 
double hypot(double a, double b) 
{ 
  return sqrt((a*a) + (b*b)); 
}

listing 2
// A custom version of strlen(). 
#include <iostream> 
using namespace std; 
 
int mystrlen(char *str); 
 
int main() 
{ 
  cout << "Length of Hello There is: "; 
  cout << mystrlen("Hello There"); 
 
  return 0; 
} 
 
// A custom version of strlen(). 
int mystrlen(char *str) 
{ 
  int i; 
 
  for(i=0; str[i]; i++) ; // find the end of the string 
 
  return i; 
}

listing 3
#include <iostream> 
using namespace std; 
 
int seriesnum = 0; 
 
int byThrees(); 
void reset(); 
 
int main() { 
 
  for(int i=0; i < 10; i++)    
    cout << byThrees() << " "; 
 
  cout << "\n"; 
 
  reset(); 
 
  for(int i=0; i < 10; i++)    
    cout << byThrees() << " "; 
 
  cout << "\n"; 
 
  return 0; 
} 
 
 
int byThrees() 
{ 
  int t; 
 
  t = seriesnum; 
  seriesnum += 3; 
 
  return t; 
} 
 
void reset() 
{ 
  seriesnum = 0; 
}

listing 4
#include <iostream>  
#include <cstring> 
using namespace std;  
  
int main(int argc, char *argv[])  
{  
  if(argc != 2) { 
    cout << "Password required!\n"; 
    return 0; 
  } 
 
  if(!strcmp("mypassword", argv[1])) 
    cout << "Access permitted.\n"; 
  else 
    cout << "Access denied.\n"; 
  
  return 0;  
}

listing 5
#include <iostream>  
using namespace std;  
 
void printnum(int n); 
  
int main()  
{  
  printnum(10); 
  
  return 0;  
} 
 
void printnum(int n) 
{ 
  if(n > 1) printnum(n-1); 
  cout << n << " "; 
}


listing 1
// Find duplicates 
 
#include <iostream> 
using namespace std; 
 
int main() 
{ 
  int nums[] = {1, 1, 2, 3, 4, 2, 5, 4, 7, 7}; 
 
  for(int i=0; i < 10; i++) 
    for(int j=i+1; j < 10; j++)  
      if(nums[i] == nums[j])  
         cout << "Duplicate: " << nums[i] << "\n"; 
 
  return 0; 
}

listing 2
// Ignore case when comparing strings. 
 
#include <iostream> 
#include <cctype> 
using namespace std; 
 
int main() 
{ 
  char str1[80]; 
  char str2[80]; 
  char *p1, *p2; 
 
  cout << "Enter first string: "; 
  cin >> str1; 
  cout << "Enter second string: "; 
  cin >> str2; 
 
  p1 = str1; 
  p2 = str2; 
 
  // loop as long as p1 and p2 point to non-null characters 
  while(*p1 && *p2) { 
    if(tolower(*p1) != tolower(*p2)) break; 
    else { 
      p1++; 
      p2++; 
    } 
  } 
 
  /* strings are the same if both p1 and p2 point 
     to the null terminator. 
  */ 
  if(!*p1 && !*p2) 
    cout << "Strings are the same except for " << 
         "possible case differences.\n"; 
  else 
    cout << "Strings differ\n"; 
     
  return 0; 
}

listing 3
// Count uppercase letters. 
#include <iostream> 
#include <cstring> 
#include <cctype> 
using namespace std; 
 
int main() 
{ 
  char str[80]; 
  int i; 
  int count; 
 
  strcpy(str, "This Is A Test"); 
 
  count = 0; 
  for(i=0; str[i]; i++) 
    if(isupper(str[i])) count++; 
 
  cout << str << " contains " << count << " uppercase letters."; 
 
  return 0; 
}

listing 1
// Count periods. 
 
#include <iostream> 
using namespace std; 
 
int main() { 
  char ch; 
  int periods = 0; 
 
  cout << "Enter a $ to stop.\n"; 
 
  do { 
    cin >> ch; 
    if(ch == '.') periods++; 
  } while(ch != '$'); 
 
  cout << "Periods: " << periods << "\n"; 
 
  return 0; 
}

listing 2
/*  
   Use a for loop to generate the progression 
 
   1 2 4 8 16, ... 
*/ 
 
#include <iostream> 
using namespace std; 
 
int main() { 
 
  for(int i = 1; i < 100; i += i) 
    cout << i << " "; 
 
  cout << "\n"; 
 
  return 0; 
}

listing 3
// Change case.  
  
#include <iostream>  
using namespace std;  
  
int main() {  
  char ch;  
  int changes = 0;  
  
  cout << "Enter period to stop.\n";  
  
  do {  
    cin >> ch;  
    if(ch >= 'a' && ch <= 'z') {  
      ch -= (char) 32;  
      changes++;  
      cout << ch;  
    }  
    else if(ch >= 'A' && ch <= 'Z') {  
      ch += (char) 32;  
      changes++;  
      cout << ch;  
    }  
  } while(ch != '.');  
 
  cout << "\nCase changes: " << changes << "\n";  
  
  return 0;  
}

listing 1
// Find prime numbers between 1 and 100. 
 
#include <iostream> 
using namespace std; 
 
int main() {    
  int i, j; 
  bool isprime; 
 
  for(i=1; i < 100; i++) { 
    isprime = true;  
 
    // see if the number is evenly divisible 
    for(j=2; j <= i/2; j++) 
      // if it is, then its not prime 
      if((i%j) == 0) isprime = false; 
 
    if(isprime) 
      cout << i << " is prime.\n"; 
  } 
 
  return 0; 
}

listing 1
// Show a table of Earth to Moon weights. 
 
#include <iostream> 
using namespace std; 
 
int main() {    
  double earthweight; // weight on earth  
  double moonweight;  // weight on moon   
  int counter; 
 
  counter = 0; 
  for(earthweight = 1.0; earthweight <= 100.0; earthweight++) { 
    moonweight = earthweight * 0.17;  
    cout << earthweight << " earth-pounds is equivalent to " <<  
                       moonweight << " moon-pounds.\n";    
    counter++; 
    if(counter == 25) { 
       cout << "\n"; 
       counter = 0; 
    } 
  } 
 
  return 0; 
} 


listing 2
// Convert Jovian years to Earth years. 
 
#include <iostream> 
using namespace std; 
 
int main() {    
  double e_years; // earth years 
  double j_years;  // Jovian years 
 
  cout << "Enter number of Jovian years: "; 
  cin >> j_years; 
 
  e_years = j_years * 12.0; 
 
  cout << "Equivalent Earth years: " << e_years; 
 
  return 0; 
}

listing 3
// Average the absolute values of 5 numbers. 
 
#include <iostream> 
#include <cstdlib>  
using namespace std; 
 
int main() 
{ 
  int i; 
  double avg, val; 
 
  avg = 0.0; 
 
  for(i=0; i<5; i++) { 
    cout << "Enter a value: "; 
    cin >> val; 
 
    avg = avg + abs(val); 
  } 
  avg = avg / 5; 
     
 
  cout << "Average of absolute values: " << avg; 
 
  return 0; 
}

listing 1
// A circle class. 
class Circle : public TwoDShape { 
public: 
  Circle(double r) : TwoDShape(r) { } 
 
  double area() {  
    return getWidth() * getHeight() * 3.1416;  
  }  
};
 
listing 1
// Copy a file. 
   
#include <iostream>  
#include <fstream>  
using namespace std;  
  
int main(int argc, char *argv[])  
{  
  char ch; 
  
  if(argc!=3) {  
    cout << "Usage: copy <source> <target>\n";  
    return 1;  
  }  
  
  ifstream src(argv[1], ios::in | ios::binary);  
  if(!src) {  
    cout << "Cannot open source file.\n";  
    return 1;  
  }  
 
  ofstream targ(argv[2], ios::out | ios::binary);  
  if(!targ) {  
    cout << "Cannot open target file.\n";  
    return 1;  
  }  
 
  do { 
    src.get(ch); 
    if(!src.eof()) targ.put(ch); 
  } while(!src.eof()); 
 
  src.close();  
  targ.close();  
  
  return 0;  
}

listing 2
// Merge two files. 
   
#include <iostream>  
#include <fstream>  
using namespace std;  
  
int main(int argc, char *argv[])  
{  
  char ch; 
  
  if(argc != 4) {  
    cout << "Usage: merge <source1> <source2> <target>\n";  
    return 1;  
  }  
  
  ifstream src1(argv[1], ios::in | ios::binary);  
  if(!src1) {  
    cout << "Cannot open 1st source file.\n";  
    return 1;  
  }  
 
  ifstream src2(argv[2], ios::in | ios::binary);  
  if(!src2) {  
    cout << "Cannot open 2nd source file.\n";  
    return 1;  
  }  
 
  ofstream targ(argv[3], ios::out | ios::binary);  
  if(!targ) {  
    cout << "Cannot open target file.\n";  
    return 1;  
  }  
 
  // Copy first source file. 
  do { 
    src1.get(ch); 
    if(!src1.eof()) targ.put(ch); 
  } while(!src1.eof()); 
 
  // Copy second source file. 
  do { 
    src2.get(ch); 
    if(!src2.eof()) targ.put(ch); 
  } while(!src2.eof()); 
 
  src1.close();  
  src2.close();  
  targ.close();  
  
  return 0;  
}

listing 1
/*  
   Add an exception to Project 12-1  
  
   A template queue class.  
*/  
#include <iostream>  
#include <cstring> 
using namespace std;  
 
// This is the exception thrown by Queue on error. 
class QExcpt { 
public: 
  char msg[80]; 
}; 
   
const int maxQsize = 100;  
  
// This creates a generic queue class.  
template <class QType> class Queue {  
  QType q[maxQsize]; // this array holds the queue  
  int size; // maximum number of elements that the queue can store  
  int putloc, getloc; // the put and get indices  
  QExcpt Qerr; // add an exception field 
public:  
  
  // Construct a queue of a specific length.  
  Queue(int len) {  
    // Queue must be less than max and positive.  
    if(len > maxQsize) len = maxQsize;  
    else if(len <= 0) len = 1;   
  
    size = len;  
    putloc = getloc = 0;  
  }  
  
  // Put a data into the queue.  
  void put(QType data) {  
    if(putloc == size) {  
      strcpy(Qerr.msg, "Queue is full.\n"); 
      throw Qerr; 
    }  
      
    putloc++;  
    q[putloc] = data;  
  }  
  
  // Get data from the queue.  
  QType get() {  
    if(getloc == putloc) {  
      strcpy(Qerr.msg, "Queue is empty.\n");  
      throw Qerr; 
    }  
    
    getloc++;  
    return q[getloc];  
  }  
};  
  
// Demonstrate the generic Queue.  
int main()  
{  
  // notice that iQa is only 2 elements long 
  Queue<int> iQa(2), iQb(10); 
 
  try {  
    iQa.put(1);  
    iQa.put(2);  
    iQa.put(3); // this will overflow! 
  
    iQb.put(10);  
    iQb.put(20);  
    iQb.put(30);  
  
    cout << "Contents of integer queue iQa: ";  
    for(int i=0; i < 3; i++) // this will underflow! 
      cout << iQa.get() << " ";  
    cout << endl;  
  
    cout << "Contents of integer queue iQb: ";  
    for(int i=0; i < 3; i++)  
      cout << iQb.get() << " ";  
    cout << endl;  
  
    Queue<double> dQa(10), dQb(10);  // create two double queues  
  
    dQa.put(1.01);  
    dQa.put(2.02);  
    dQa.put(3.03);  
  
    dQb.put(10.01);  
    dQb.put(20.02);  
    dQb.put(30.03);  
  
    cout << "Contents of double queue dQa: ";  
    for(int i=0; i < 3; i++)  
      cout << dQa.get() << " ";  
    cout << endl;  
  
    cout << "Contents of double queue dQb: ";  
    for(int i=0; i < 3; i++)  
      cout << dQb.get() << " ";  
    cout << endl;  
 
  } catch(QExcpt exc) { 
    cout << exc.msg; 
  } 
 
  return 0;  
}

listing 2
// A generic Quicksort. 
 
#include <iostream> 
#include <cstring> 
 
using namespace std; 
 
 
// Set up a call to the actual sorting function. 
template <class X> void quicksort(X *items, int len) 
{ 
  qs(items, 0, len-1); 
} 
 
// A generic version of Quicksort. 
template <class X> void qs(X *items, int left, int right)  
{  
  int i, j;  
  X x, y;  
  
  i = left; j = right;  
  x = items[( left+right) / 2 ];  
  
  do {  
    while((items[i] < x) && (i < right)) i++;  
    while((x < items[j]) && (j > left)) j--;  
  
    if(i <= j) {  
      y = items[i];  
      items[i] = items[j];  
      items[j] = y;  
      i++; j--;  
    }  
  } while(i <= j);  
  
  if(left < j) qs(items, left, j);  
  if(i < right) qs(items, i, right);  
} 
 
int main() { 
 
  // sort characters. 
  char str[] = "jfmckldoelazlkper"; 
  int i; 
 
  cout << "Original order: " << str << "\n"; 
 
  quicksort(str, strlen(str)); 
 
  cout << "Sorted order: " << str << "\n"; 
 
  // sort integers 
  int nums[] = { 4, 3, 7, 5, 9, 8, 1, 3, 5, 4 }; 
 
  cout << "Original order: "; 
  for(int i=0; i < 10; i++) 
    cout << nums[i] << " "; 
  cout << endl; 
 
  quicksort(nums, 10); 
 
  cout << "Sorted order: "; 
  for(int i=0; i < 10; i++) 
    cout << nums[i] << " "; 
  cout << endl; 
     
 
  return 0; 
}

listing 3
/*  
   Use Project 12-1 to store Sample objects. 
  
   A template queue class.  
*/  
#include <iostream>  
using namespace std;  
 
class Sample { 
  int id; 
public: 
  Sample() { id = 0; } 
  Sample(int x) { id = x; } 
  void show() { cout << id << endl; } 
}; 
  
const int maxQsize = 100;  
  
// This creates a generic queue class.  
template <class QType> class Queue {  
  QType q[maxQsize]; // this array holds the queue  
  int size; // maximum number of elements that the queue can store  
  int putloc, getloc; // the put and get indices  
public:  
  
  // Construct a queue of a specific length.  
  Queue(int len) {  
    // Queue must be less than max and positive.  
    if(len > maxQsize) len = maxQsize;  
    else if(len <= 0) len = 1;   
  
    size = len;  
    putloc = getloc = 0;  
  }  
  
  // Put a data into the queue.  
  void put(QType data) {  
    if(putloc == size) {  
      cout << " -- Queue is full.\n";  
      return;  
    }  
      
    putloc++;  
    q[putloc] = data;  
  }  
  
  // Get data from the queue.  
  QType get() {  
    if(getloc == putloc) {  
      cout << " -- Queue is empty.\n";  
      return 0;   
    }  
    
    getloc++;  
    return q[getloc];  
  }  
};  
  
// Demonstrate the generic Queue.  
int main()  
{  
  Queue<Sample> sampQ(3); 
 
  Sample o1(1), o2(2), o3(3); 
  
  sampQ.put(o1); 
  sampQ.put(o2); 
  sampQ.put(o3); 
 
  cout << "Contents of sampQ:\n";  
  for(int i=0; i < 3; i++)  
    sampQ.get().show(); 
  cout << endl;  
  
  return 0;  
}

listing 4
/*  
   Use Project 12-1 to store Sample objects. 
 
   Allocate the Sample objects dyamically. 
  
   A template queue class.  
*/  
#include <iostream>  
using namespace std;  
 
class Sample { 
  int id; 
public: 
  Sample() { id = 0; } 
  Sample(int x) { id = x; } 
  void show() { cout << id << endl; } 
}; 
  
const int maxQsize = 100;  
  
// This creates a generic queue class.  
template <class QType> class Queue {  
  QType q[maxQsize]; // this array holds the queue  
  int size; // maximum number of elements that the queue can store  
  int putloc, getloc; // the put and get indices  
public:  
  
  // Construct a queue of a specific length.  
  Queue(int len) {  
    // Queue must be less than max and positive.  
    if(len > maxQsize) len = maxQsize;  
    else if(len <= 0) len = 1;   
  
    size = len;  
    putloc = getloc = 0;  
  }  
  
  // Put a data into the queue.  
  void put(QType data) {  
    if(putloc == size) {  
      cout << " -- Queue is full.\n";  
      return;  
    }  
      
    putloc++;  
    q[putloc] = data;  
  }  
  
  // Get data from the queue.  
  QType get() {  
    if(getloc == putloc) {  
      cout << " -- Queue is empty.\n";  
      return 0;   
    }  
    
    getloc++;  
    return q[getloc];  
  }  
};  
  
// Demonstrate the generic Queue.  
int main()  
{  
  Queue<Sample> sampQ(3); 
 
  Sample *p1, *p2, *p3; 
 
  p1 = new Sample(1); 
  p2 = new Sample(2); 
  p3 = new Sample(3); 
  
  sampQ.put(*p1); 
  sampQ.put(*p2); 
  sampQ.put(*p3); 
 
  cout << "Contents of sampQ:\n";  
  for(int i=0; i < 3; i++)  
    sampQ.get().show(); 
  cout << endl;  
  
  delete(p1); 
  delete(p2); 
  delete(p3); 
 
  return 0;  
}





 ****************************


listing 1
const int a;

listing 2
const int count = 100;

listing 3
const volatile unsigned char *port=0x30;

listing 4
int i, j, l;

short int si;

unsigned int ui;

double balance, profit, loss;

listing 5
void func1(void)
{
  int x;

  x = 10;
}

void func2(void)
{
  int x;

  x = -199;
}

listing 6
void f(void)
{
  int t;

  scanf("%d", &t);

  if(t==1) {
    char s[80];  /* s exists only inside this block */
    printf("enter name:");
    gets(s);
    process(s);
  }
  /* s is not known here */
}

listing 7
/* return 1 if c is part of string s; 0 otherwise */
int is_in(char *s, char c)
{
  while(*s)
    if(*s==c) return 1;
    else s++;

  return 0;
}

listing 8
#include <stdio.h>

void func1(void), func2(void);

int count;  /* count is global  */

int main(void)
{
  count = 100;
  func1();
  return 0; /* return success to the system */
}

void func1(void)
{
  func2();
  printf("count is %d", count); /* will print 100 */
}

void func2(void)
{
  int count;

  for(count=1; count<10; count++)
    putchar(' ');
}

listing 9
int first, last;  /* global definition of first and last */

int main(void)
{
  extern int first;  /* optional use of the
                        extern declaration */
  /* ... */
}

listing 10
#include <stdio.h>
#include <conio.h>

int count(int i);

int main(void)
{
  do {
    count(0);
  } while(!kbhit());
  printf("count called %d times", count(1));
  return 0;
}

int count(int i)
{
  static int c=0;

  if(i) return c;
  else c++;
  return 0;
}

listing 11
int series(void)
{
  static int series_num;

  series_num = series_num+23;
  return(series_num);
}

listing 12
/* This must all be in one file - preferably by itself */

static int series_num;

int series(void);
void series_start(int seed);

series(void)
{
  series_num = series_num + 23;
  return(series_num);
}

/* initialize series_num */
void series_start(int seed)
{
  series_num = seed;
}

listing 13
int int_pwr(register int m, register int e)
{
  register int temp;

  temp = 1;

  for(; e; e--) temp *= m;
   return temp;
}

listing 14
x = y = z = 0;

listing 15
int x;
char ch;
float  f;
void func(void)
{
  ch = x;    /* 1 */
  x = f;     /* 2 */
  f = ch;    /* 3 */
  f = x;     /* 4 */
}

listing 16
char ch = 'a';

int first = 0;

float balance = 123.23;

listing 17
ch = '\t';
printf("this is a test\n");

listing 18
int x, y;

x = 10;
y = 3;

printf("%d", x/y);   /* will display 3 */
printf("%d", x%y);   /* will display 1, the remainder of
                        the integer division */

x = 1;
y = 2;

printf("%d %d", x/y, x%y); /*  will display 0 1 */

listing 19
x = x + 1;

listing 20
++x;

listing 21
x = x - 1;

listing 22
--x;

listing 23
x = x + 1;

listing 24
++x;

listing 26
x = 10;
y = ++x;

listing 27
x = 10;
y = x++;

listing 28
int x;

x = 100;
printf("%d", x>10);

listing 29
char get_char_from_modem(void)
{
  char ch;

  ch = read_modem(); /* get a character from the
                        modem port */
  return(ch & 127);
}

listing 30
/* A simple cipher function. */
char encode(char ch)
{
  return(~ch); /* complement it */
}

listing 31
x = 10;
y = x>9 ? 100 : 200;

listing 32
x = 10;
if(x>9) y = 100;
else y = 200;

listing 33
m = &count;

listing 34
q = *m;

listing 35
char *ch;

listing 36
int x, *y, count;

listing 37
#include <stdio.h>

/* Assignment with * and &. */
int main(void)
{
  int target, source;
  int *m;

  source = 10;
  m = &source;
  target = *m;

  printf("%d", target);

  return 0;
}

listing 38
float f;

printf("%f ", sizeof f);
printf("%d", sizeof(int));

listing 39
/* write a record to a disk file */
void put_rec(FILE *fp, int rec[6])
{
  int size, num;

  size = sizeof(int) * 6;
  num = fwrite(rec, size, 1, fp);
  if(num!=1) printf("write error");
}

listing 41
y = 10;
x = (y=y-5, 25/y);

listing 42
struct employee {
  char name[80];
  int age;
  float wage;
} emp;

struct tom *p = &emp; /* address of emp into p */

listing 43
emp.wage = 123.23;

listing 44
p->wage = 123.23;

listing 45
#include <stdio.h>

char s[80];

int main(void)
{
   s[3] = 'X';
   printf("%c", s[3]);

  return 0;
}

listing 46
(float) x/2

listing 47
#include <stdio.h>

/* Print i and i/2 with fractions. */
int main(void)
{
  int i;

  for(i=1; i<=100; ++i )
    printf("%d / 2 is: %f\n", i, (float) i/2);
  return 0;
}

listing 48
x=10/y~(127/x);

x = 10 / y ~(127/x);

listing 49
x=y/3-34*temp&127;

x = (y/3) - (34*(temp & 127));


listing 50
x = x + 10;

listing 51
x += 10;

listing 52
x = x - 100;

listing 53
x -= 100;


listing 1
#include <stdio.h>

/* Magic number program. */
int main(void)
{
  int magic = 123;  /* magic number */
  int guess;

  printf("Enter your guess: ");
  scanf("%d", &guess);

  if(guess == magic) printf("** Right **");

  return 0;
}

listing 2
#include <stdio.h>

/* Magic number program - improvement 1. */
int main(void)
{
  int magic = 123;  /* magic number */
  int guess;

  printf("Enter your guess: ");
  scanf("%d",&guess);

  if(guess == magic) printf("** Right **");
  else printf(".. Wrong ..");

  return 0;
}

listing 3
if(x)
  if(y) printf("1");
  else printf("2");

listing 4
if(x) {
  if(y) printf("1");
}
else printf("2");

listing 5
#include <stdio.h>

/* Magic number program - improvement 2. */
int main(void)
{
  int magic = 123;  /* magic number */
  int guess;

  printf("Enter your guess: ");
  scanf("%d", &guess);

  if(guess == magic) {
    printf("** Right ** ");
    printf("%d is the magic number", magic);
  }
  else {
    printf(".. Wrong .. ");
    if(guess > magic) printf("Too high");
    else printf("Too low");
  }
  return 0;
}

listing 6
#include <stdio.h>

/* Magic number program - improvement 3. */
int main(void)
{
  int magic = 123;  /* magic number */
  int guess;

  printf("Enter your guess: ");
  scanf("%d", &guess);

  if(guess == magic) {
    printf("** Right ** ");
    printf("%d is the magic number", magic);
  }
  else if(guess > magic)
    printf(".. Wrong .. Too High");
  else printf(".. Wrong .. Too low");

  return 0;
}

listing 7
x = 10;
y = x>9 ? 100 : 200;

listing 8
x = 10;
if(x>9) y = 100;
else y = 200;

listing 9
#include <stdio.h>

int f1(int n), f2(void);

int main(void)
{
  int t;

  printf(": ");
  scanf("%d", &t);
  /* print proper message */
  t ? f1(t)+f2() : printf("Zero Entered");

  return 0;
}

int f1(int n)
{
  printf("%d ",n);
  return 0;
}

int f2(void)
{
  printf("entered");
  return 0;
}

listing 10
#include <stdio.h>

/* Magic number program - improvement 4. */
int main(void)
{
  int magic = 123;  /* magic number */
  int guess;

  printf("Enter your guess: ");
  scanf("%d", &guess);
  if(guess == magic) {
    printf("** Right ** ");
    printf("%d is the magic number", magic);
  }
  else
    guess > magic ? printf("High") : printf("Low");

  return 0;
}

listing 11
void menu(void)
{
  char ch;

  printf("1. Check Spelling\n");
  printf("2. Correct Spelling Errors\n");
  printf("3. Display Spelling Errors\n");
  printf("Strike Any Other Key to Skip\n");
  printf("      Enter your choice: ");

  ch = getche();  /* read the selection from the keyboard */

  switch(ch) {
    case '1':
      check_spelling();
      break;
    case '2':
      correct_errors();
      break;
    case '3':
      display_errors();
      break;
    default :
      printf("No option selected");
  }
}

listing 12
void inp_handler(void)
{
  int ch, flag;

  ch = read_device(); /* read some sort of device */
  flag = -1;

  switch(ch) {
    case 1:  /* these cases have common statement */
    case 2:  /* sequences */
    case 3:
      flag = 0;
      break;
    case 4:
      flag = 1;
    case 5:
      error(flag);
      break;
    default:
      process(ch);
  }
}

listing 13
flag = 0;
break;

listing 14
/* This is incorrect. */
switch(c) {
  case 1:
    int t;
    .
    .
    .

listing 15
/* This is correct. */
switch(c) {
  int t;
  case 1:
    .
    .
    .

listing 16
/* This is also correct. */
switch(c) {
  case 1:
    { /* create a block */
      int t;
      .
      .
      .
    }
    .
    .
    .

listing 17
switch(x) {
  case 1:
    switch(y) {
      case 0: printf("Divide by zero error.");
              break;
      case 1: process(x,y);
    }
    break;
  case 2:
   .
   .
   .

listing 18
#include <stdio.h>

int main(void)
{
  int x;

  for(x=1; x<=100; x++) printf("%d ", x);

  return 0;
}

listing 19
for(x=100; x!=65; x-=5) {
  z = sqrt(x);
  printf("The square root of %d, %f", x, z);
}

listing 20
x = 10;
for(y=10; y!=x; ++y) printf("%d", y);
printf("%d", y);

listing 21
for(x=0, y=0; x+y<10; ++x) {
  scanf("%d", &y);
    .
    .
    .
}

listing 22
/* Copy s into r backwards. */
void reverse(char *s, char *r)
{
  int i, j;

  for(i=strlen(s)-1, j=0; i>=0; j++,i--) r[i] = s[j];
  r[j] = '\0'; /* append null terminator */
}

listing 23
void sign_on(void)
{
  char str[20];
  int x;

  for(x=0; x<3 && strcmp(str,"password"); ++x) {
    printf("enter password please:");
    gets(str);
  }
  if(x==3) hang_up();
}

listing 24
#include <stdio.h>

int readnum(void), prompt(void);
int sqrnum(int num);

int main(void)
{
  int t;

  for(prompt(); t=readnum(); prompt()) sqrnum(t);
  return 0;
}

int prompt(void)
{
  printf(": ");
  return 0;
}

int readnum(void)
{
  int t;

  scanf("%d", &t);
  return t;
}

int sqrnum(int num)
{
  printf("%d\n", num*num);
  return 0;
}

listing 25
for(x=0; x!=123; ) scanf("%d", &x);

listing 26
gets(s);  /* read a string into s */
if(*s) x = strlen(s); /* get the string's length */

for( ;x<10; ) {
  printf("%d", x);
  ++x;
}

listing 27
for(;;) printf(" this loop will run forever.\n");

listing 28
ch = '\0';

for(;;) {
  ch = getchar();  /* get a character */
  if(ch=='A') break;  /* exit the loop */
}

printf("you typed an A");

listing 29
for( ; *str==' '; str++) ;

listing 30
for(t=0; t<SOME_VALUE; t++) ;

listing 31
void wait_for_char(void)
{
  char ch;

  ch = '\0';  /* initialize ch */
  while(ch!='A')  ch = getchar();
}

listing 32
/* Add spaces to the end of a string. */
void pad(char *s, int length)
{
  int l;
  l = strlen(s);  /* find out how long it is */

  while(l<length) {
    s[l] = ' ';   /* insert a space */
    l++;
  }

  s[l] = '\0';  /* strings need to be
                   terminated in a null */
}

listing 33
void func1(void)
{
  int working;

  working = 1;   /* i.e., true */

  while(working) {
    working=process1();
    if(working)
      working=process2();
    if(working)
      working=process3();
  }
}

listing 34
while((ch=getchar()) != 'A') ;

listing 35
do {
  scanf("%d", &num);
} while(num>100);

listing 36
void menu(void)
{
  char ch;

  printf("1. Check Spelling\n");
  printf("2. Correct Spelling Errors\n");
  printf("3. Display Spelling Errors\n");
  printf("      Enter your choice: ");

  do {
    ch = getche();  /* read the selection from the keyboard */
    switch(ch) {
      case '1':
        check_spelling();
        break;
      case '2':
        correct_errors();
        break;
      case '3':
        display_errors();
        break;
    }
  } while(ch!='1' && ch!='2' && ch!='3');
}

listing 37
#include <stdio.h>

int main(void)
{
  int t;

  for(t=0; t<100; t++) {
    printf("%d ", t);
    if(t==10) break;
  }
  return 0;
}

listing 38
int look_up(char *name)
{
  char tname[40];
  int loc;

  loc = -1;
  do {
    loc = read_next_name(tname);
    if(kbhit()) break;
  } while(!strcmp(tname, name));
  return loc;
}

listing 39
for(t=0; t<100; ++t) {
  count = 1;
  for(;;) {
    printf("%d ", count);
    count++;
    if(count==10) break;
  }
}

listing 40
#include <stdlib.h>

int main(void)
{
  if(!special_adaptor()) exit(1);
  play();
  return 0;
}

listing 41
void menu(void)
{
  char ch;

  printf("1. Check Spelling\n");
  printf("2. Correct Spelling Errors\n");
  printf("3. Display Spelling Errors\n");
  printf("4. Quit\n");
  printf("      Enter your choice: ");

  do {
    ch = getchar();  /* read the selection from the keyboard */

    switch(ch) {
      case '1':
        check_spelling();
        break;
      case '2':
        correct_errors();
        break;
      case '3':
        display_errors();
        break;
      case '4':
        exit(0);  /* return to OS */
    }
  } while(ch!='1' && ch!='2' && ch!='3');
}

listing 42
do {
  scanf("%d", &x);
  if(x<0) continue;
  printf("%d ", x);
} while(x!=100);

listing 43
for(t=0; t<100; ++t) {
  scanf("%d", &x);
  if(x<0) continue;
  printf("%d ", x);
}

listing 44
void code(void)
{
  char done, ch;

  done = 0;
  while(!done) {
    ch = getchar();
    if(ch=='.') {
      done = 1;
      continue;
    }
    putchar(ch+1);  /* shift the alphabet one position */
  }
}

listing 45
x = 1;

loop1:
  x++;
  if(x<100) goto loop1;

listing 46
for(...) {
  for(...) {
    while(...) {
      if(...) goto stop;
      .
      .
      .
    }
  }
}
stop:
  printf("error in program\n");

listing 47
done = 0;
for(...) {
  for(...) {
    while(...) {
      if(...) {
        done = 1;
        break;
      }
      .
      .
      .
    }
    if(done) break;
  }
  if(done) break;
}

listing 1
void pr_reverse(char *s)
{
  register int t;

  for(t=strlen(s)-1; t > -1; t--) printf("%c", s[t]);
}

listing 2
int find_substr(char *s1, char *s2)
{
  register int t;
  char *p, *p2;

  for(t=0; s1[t]; t++) {
    p = &s1[t];
    p2 = s2;
    while(*p2 && *p2==*p) {
      p++;
      p2++;
    }
    if(!*p2) return t;
  }
  return -1;
}

listing 3
swap(x, y) = 100;   /* incorrect statement */

listing 4
int t;

t = f();  /* no value to assign to t */

f()+f();  /* no value to add */

listing 5
#include <stdio.h>

int mul(int a, int b);

int main(void)
{
  int x, y, z;

  x = 10;   y = 20;
  z = mul(x, y);            /* 1 */
  printf("%d", mul(x, y));  /* 2 */
  mul(x, y);                /* 3 */

  return 0;
}

int mul(int a, int b)
{
  return a*b;
}

listing 6
/* return 1 if c is part of string s; 0 otherwise */
int is_in(char *s, char c)
{
  while(*s)
    if(*s==c) return 1;
    else s++;

  return 0;
}

listing 7
#include <stdio.h>

int sqr(int x);

int main(void)
{
  int t=10;

  printf("%d %d", sqr(t), t);
  return 0;
}

int sqr(int x)
{
  x = x*x;
  return x;
}

listing 8
void swap(int *x, int *y)
{
  int temp;

  temp = *x;  /* save the value at address x */
  *x = *y;    /* put y into x */
  *y = temp;  /* put x into y */
}

listing 9
#include <stdio.h>

void swap(int *x, int *y);

int main(void)
{
  int x, y;

  x = 10;
  y = 20;
  swap(&x, &y);
  printf("%d %d", x, y);

  return 0;
}

listing 10
#include <stdio.h>

void display(int num[10]);

int main(void)  /* print some numbers */
{
  int t[10], i;

  for(i=0; i<10; ++i) t[i]=i;
  display(t);
  return 0;
}

void display(int num[10])
{
  int i;

  for(i=0; i<10; i++) printf("%d ", num[i]);
}

listing 11
void display(int num[])
{
  int i;

  for(i=0; i<10; i++) printf("%d ", num[i]);
}

listing 12
void display(int *num)
{
  int i;

  for(i=0; i<10; i++) printf("%d ", num[i]);
}

listing 13
#include <stdio.h>

void display(int num);

int main(void) /* print some numbers */
{
  int t[10], i;

  for(i=0; i<10; ++i) t[i] = i;
  for(i=0; i<10; i++) display(t[i]);

  return 0;
}

void display(int num)
{
  printf("%d ", num);
}

listing 14
#include <stdio.h>
#include <ctype.h>

void print_upper(char *string);

int main(void)  /* print string as uppercase */
{
  char s[80];

  gets(s);
  print_upper(s);

  return 0;
}

void print_upper(char *string)
{
  register int t;

  for(t=0; string[t]; ++t)  {
    string[t] = toupper(string[t]);
    printf("%c", string[t]);
  }
}

listing 15
#include <stdio.h>
#include <ctype.h>

void print_upper(char *string);

int main(void)  /* print string as uppercase */
{
  char s[80];
  gets(s);
  print_upper(s);

  return 0;
}

void print_upper(char *string)
{
  register int t;

  for(t=0; string[t]; ++t)
    printf("%c", toupper(string[t]));
}

listing 16
/* A  simplified version of the standard
   gets() library function. */

void xgets(char *s)
{
  register char ch;
  register int t;

  for(t=0; t<79; ) {
    ch = getche();
    switch(ch) {
      case '\r':
        s[t] = '\0'; /* null terminate the string */
        return;
      case '\b':
        if(t>0) t--;
        break;
      default:
        s[t] = ch;
        t++;
    }
  }
  s[79] = '\0';
}

listing 17
#include <stdio.h>

int main(int argc, char *argv[])
{
  if(argc!=2) {
    printf("You forgot to type your name\n");
    return 1;
  }
  printf("Hello %s", argv[1]);

  return 0;
}

listing 18
char *argv[];

listing 19
/* Countdown program. */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(int argc, char *argv[])
{
  int disp, count;

  if(argc<2) {
    printf("You must enter the length of the count\n");
    printf("on the command line. Try again.\n");
    return 1;
  }

  if(argc==3 && !strcmp(argv[2],"display")) disp = 1;
  else disp = 0;

  for(count=atoi(argv[1]); count; --count)
    if(disp) printf("%d ", count);

  printf("%c", '\a');  /* this will ring the bell on most computers */
  return 0;
}

listing 20
#include <stdio.h>

int main(int argc, char *argv[])
{
  int t, i;

  for(t=0; t<argc; ++t) {
    i = 0;
    while(argv[t][i]) {
      printf("%c", argv[t][i]);
      ++i;
    }
    printf(" ");
  }

  return 0;
}

listing 21
/* Link this program with WILDARGS.OBJ. */

#include <stdio.h>

int main(int argc, char *argv[])
{
  register int i;

  printf("%d files match specified name\n", argc-1);

  printf("They are: ");

  for(i=1; i<argc; i++)
    printf("%s ", argv[i]);

  return 0;
}

listing 22
char *env[]

listing 23
/* This program prints all the environmental
   strings.
*/

#include <stdio.h>

int main(int argc, char *argv[], char *env[])
{
  int t;

  for(t=0; env[t]; t++)
    printf("%s\n", env[t]);

  return 0;
}

listing 24
/* This program searches the environmental
   strings for the one that contains the
   current PATH.
*/
#include <stdio.h>
#include <string.h>

int main(int argc, char *argv[], char *env[])
{
  int t;

  for(t=0; env[t]; t++) {
    if(strstr(env[t], "PATH"))
      printf("%s\n", env[t]);
  }

  return 0;
}

listing 25
double myfunc();

listing 26
/* This is an old-style program which will generate
   warning messages when compiled. */
#include <stdio.h>
#include <math.h>

double myfunc(); /* forward declaration of myfunc() */

int main(void)
{
  printf("%lf", myfunc(10.0));
  return 0;
}

double myfunc(double x)
{
  return sqrt(x) * 2.0; /* return sqr root of x * 2 */
}

listing 27
/* This program uses function prototypes to
   enforce strong type checking in the calls
   to func().

   The program will not compile because of the
   mismatch between the type of the arguments
   specified in the function's prototype and
   the type of arguments used to call the function.
*/

#include <stdio.h>

float func(int x, float y); /* prototype */

int main(void)
{
  int x, *y;

  x = 10;  y = &x;
  func(x, y);  /* type mismatch */
  return 0;
}

float func(int x, float y)
{
  printf("%f", y/(float)x);
  return y/(float) x;
}

listing 28
/*
   The program will not compile because of the
   mismatch between the number of parameters
   specified in the function's prototype and
   the number of arguments used to call the function.
*/

#include <stdio.h>

float func(int x, float y); /* prototype */

int main(void)
{
  func(2, 2.0, 4);  /* wrong number of args */
  return 0;
}

float func(int x, float y)
{
  printf("%f", y/(float)x);
  return y/(float) x;
}

listing 29
char func(char *, int);

char func(char *str, int count);

listing 30
#include <stdio.h>

void display10(void);

int main(void)
{
  display10();

  return 0;
}

void display10(void)
{
  int i;

  for(i=0; i<10; i++)
    printf("%d ", i);
}

listing 31
display10(100);

listing 32
char *match(char c, char *s)
{
  register int count;

  count = 0;
  while(c!=s[count] && s[count]) count++;

  return(&s[count]);
}

listing 33
#include <stdio.h>
#include <conio.h>

char *match(char c, char *s);

int main(void)
{
  char s[80], *p, ch;

  gets(s);
  ch = getche();
  p = match(ch, s);
  if(p)  /* there is a match */
    printf("%s ", p);
  else
    printf("No match found.");

  return 0;
}

listing 34
char *f(const char *str1, int count, int index)
{
  .
  .
  .
 }

listing 35
char *f(str1, count, index)
char *str1;
int count, index;
{
  .
  .
  .
 }

listing 36
/* Compute the factorial of a number. */
int factr(int n)  /* recursive */
{
  int answer;

  if(n==1) return(1);
  answer = factr(n-1)*n;
  return(answer);
}

/* Compute the factorial of a number. */
int fact(int n)    /* non-recursive */
{
  int t, answer;

  answer = 1;
  for(t=1; t<=n; t++)
    answer=answer*(t);
  return(answer);
}

listing 37
#include <stdio.h>
#include <string.h>

void check(char *a, char *b, int (*cmp) (const char *, const char *));

int main(void)
{
  char s1[80], s2[80];
  int  (*p)(const char*, const char*);

  p = strcmp;  /* get address of strcmp() */

  gets(s1);
  gets(s2);

  check(s1, s2, p);
  return 0;
}

void check(char *a, char *b, int (*cmp) (const char *, const char *))
{
  printf("Testing for equality.\n");
  if(!(*cmp) (a, b)) printf("Equal");
  else printf("Not equal");
}

listing 38
if(!(*cmp) (a, b)) printf("Equal");

listing 39
if(!cmp(a, b)) printf("Equal");

listing 40
check(s1, s2, strcmp);

listing 41
#include <stdio.h>
#include <ctype.h>
#include <string.h>
#include <stdlib.h>

void check(char *a, char *b, int (*cmp) (const char *, const char *));
int numcmp(const char *a, const char *b);

int main(void)
{
  char s1[80], s2[80];
  gets(s1);
  gets(s2);

  if(isalpha(*s1))
     check(s1, s2, strcmp);
  else
     check(s1, s2, numcmp);

   return 0;
}

void check(char *a, char *b, int (*cmp) (const char *, const char *))
{
  printf("Testing for equality.\n");
  if(!(*cmp) (a, b)) printf("Equal");
  else printf("Not equal");
}

int numcmp(const char *a, const char *b)
{
  if(atoi(a)==atoi(b)) return 0;
  else return 1;
}

listing 1
char p[10];

listing 2
#include <stdio.h>

int main(void)
{
  int x[10];  /* this reserves 10 integer elements */
  int t;

  for(t=0; t<10; ++t) x[t] = t;

  for(t=0; t<10; ++t) printf("%d ", x[t]);

  return 0;
}

listing 3
char a[7];

listing 4
int sample[10];

listing 5
int *p;
int sample[10];

p = sample;

listing 6
int main(void)
{
  int i[10];

  func1(i);
  .
  .
  .
}

listing 7
void func1(int *a)  /* pointer */
{
  .
  .
  .
}

listing 8
void func1(int a[32])
{
  .
  .
  .
}

listing 9
char s[11];

listing 10
#include <string.h>
#include <stdio.h>

int main(void)
{
  char s1[80], s2[80];

  gets(s1); gets(s2);

  printf("lengths: %d %d\n", strlen(s1), strlen(s2));

  if(!strcmp(s1, s2)) printf("The strings are equal\n");

  strcat(s1, s2);
  printf("%s\n", s1);

  return 0;
}

listing 11
int d[10][20];

listing 12
#include <stdio.h>

int main(void)
{
  int t,i, num[3][4];

  /* load numbers */
  for(t=0; t<3; ++t)
    for(i=0; i<4; ++i)
      num[t][i] = (t*4)+i+1;

  /* display numbers */
  for(t=0; t<3; ++t) {
    for(i=0; i<4; ++i)
      printf("%d ", num[t][i]);
    printf("\n");
  }

  return 0;
}

listing 13
void func1(int x[][10])
{
  .
  .
  .
}

listing 14
#include <conio.h>
#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>

#define CLASSES  3
#define GRADES  30
int grade[CLASSES][GRADES];

void disp_grades(int g[][GRADES]), enter_grades(void);
int get_grade(int num);

int main(void)  /* class grades program */
{
  char ch;

  for(;;) {
    do {
      printf("(E)nter grades\n");
      printf("(R)eport grades\n");
      printf("(Q)uit\n");
      ch = toupper(getche());
    } while(ch!='E' && ch!='R' && ch!='Q');

    switch(ch) {
      case 'E':
        enter_grades();
        break;
      case 'R':
        disp_grades(grade);
        break;
      case 'Q':
        return 0;
    }
  }
}

/* Enter each student's grade. */
void enter_grades(void)
{
  int t, i;

  for(t=0; t<CLASSES; t++) {
    printf("Class # %d:\n", t+1);
    for(i=0; i<GRADES; ++i)
      grade[t][i] = get_grade(i);
  }
}

/* Actually input the grade. */
int get_grade(int num)
{
  char s[80];

  printf("enter grade for student # %d:\n", num+1);
  gets(s);
  return(atoi(s));
}

/* Display the class grades. */
void disp_grades(int g[][GRADES])
{
  int t, i;

  for(t=0; t<CLASSES; ++t) {
    printf("Class # %d:\n", t+1);
    for(i=0; i<GRADES; ++i)
      printf("grade for student #%d is %d\n",i+1, g[t][i]);
  }
}

listing 15
char str_array[30][80];

listing 16
gets(str_array[2]);

listing 17
gets(&str_array[2][0]);

listing 18
#include <stdio.h>

#define MAX 100
#define LEN 255

char text[MAX][LEN];

/* A very simple text editor. */
int main(void)
{
  register int t, i, j;

  for(t=0; t<MAX; t++) {
    printf("%d: ", t);
    gets(text[t]);
    if(!*text[t]) break; /* quit on blank line */
  }

  /* this displays the text one character at a time */
  for(i=0; i<t; i++) {
    for(j=0; text[i][j]; j++) printf("%c", text[i][j]);
    printf("%c", '\n');
  }

  return 0;
}

listing 19
  for(i=0; i<t; i++)
    printf("%s\n", text[i]);

listing 20
int m[4][3][6][5];

listing 21
int func1(int d[][3][6][5])
{
  .
  .
  .
}

listing 22
char p[10];

listing 23
p

&p[0]

listing 24
p == &p[0]

listing 25
int *p, i[10];

p = i;

p[5] = 100;  /* assign using index */

*(p+5) = 100; /* assign using pointer arithmetic */

listing 26
a

&a[0][0]

listing 27
int num[10][10];
  .
  .
  .
void pr_row(int j)
{
  int *p, t;

  p = num[j]; /* get address of first element in row j */

  for(t=0; t<10; ++t) printf("%d ", *(p+t));
}

listing 28
/* General */
void pr_row(int j, int row_dimension, int *p)
{
  int t;

  p = p + (j * row_dimension);
  for(t=0; t<row_dimension; ++t)
    printf("%d ", *(p+t));
}

listing 29
char *p;

p = malloc(1000); /* get 1000 bytes */

listing 30
p = (char *) malloc(1000); /* get 1000 bytes */

listing 31
/* Print a string backwards using dynamic allocation. */

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

int main(void)
{
  char *s;
  register int t;

  s = (char *) malloc(80);

  if(!s) {
    printf("Memory request failed.\n");
    return 1;
  }

  gets(s);
  for(t=strlen(s)-1; t>=0; t--) printf("%c", s[t]);
  free(s);

  return 0;
}

listing 32
#include <stdlib.h>
#include <stdio.h>

int pwr(int a, int b);
void table(int p[5][11]), show(int p[5][11]);

/* This program displays various numbers raised to
   integer powers. */
int main(void)
{
  int *p;

  p = (int *) malloc(55*sizeof(int));

  if(!p) {
    printf("Memory request failed.\n");
    return 1;
  }

  /* here, p is simply a pointer */
  table(p);
  show(p);

  return 0;
}

/* Build a table of numbers. */
void table(int p[5][11]) /* now the compiler thinks that
                            p is an array */
{
  register int i, j;

  for(j=1; j<11; j++)
    for(i=1; i<5; i++) p[i][j] = pwr(j, i);
}

/* Display the table. */
void show(int p[5][11])
{
  register int i, j;

  printf("%10s %10s %10s %10s\n","N","N^2","N^3","N^4");
  for(j=1; j<11; j++) {
    for(i=1; i<5; i++) printf("%10d ", p[i][j]);
    printf("\n");
  }
}

/* Raise a to the b power. */
int pwr(int a, int b)
{
  register int t=1;

  for(; b; b--) t = t*a;
  return t;
}

listing 33
int i[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

listing 34
char str[6] = "hello";

listing 35
char str[6] = {'h', 'e', 'l', 'l', 'o', '\0'};

listing 36
int sqrs[10][2] = {
  1, 1,
  2, 4,
  3, 9,
  4, 16,
  5, 25,
  6, 36,
  7, 49,
  8, 64,
  9, 81,
  10, 100
};

listing 37
int sqrs[10][2] = {
  {1, 1},
  {2, 4},
  {3, 9},
  {4, 16},
  {5, 25},
  {6, 36},
  {7, 49},
  {8, 64},
  {9, 81},
  {10, 100}
};

listing 38
char e1[12] = "Read Error\n";
char e2[13] = "Write Error\n";
char e3[18] = "Cannot Open File\n";

listing 39
char e1[] = "Read Error\n";
char e2[] = "Write Error\n";
char e3[] = "Cannot Open File\n";

listing 40
printf("%s has length %d\n", e2, sizeof e2);

listing 41
int sqrs[][2] = {
  1, 1,
  2, 4,
  3, 9,
  4, 16,
  5, 25,
  6, 36,
  7, 49,
  8, 64,
  9, 81,
  10, 100
};

listing 42
#include <stdio.h>
#include <stdlib.h>

/* A simple game of Tic-Tac-Toe. */

#define SPACE  ' '

char matrix[3][3] = {  /* the tic-tac-toe matrix */
  {SPACE, SPACE, SPACE},
  {SPACE, SPACE, SPACE},
  {SPACE, SPACE, SPACE}
};

void get_computer_move(void), get_player_move(void);
void disp_matrix(void);
char check(void);

int main()
{
  char done;

  printf("This is the game of Tic-Tac-Toe.\n");
  printf("You will be playing against the computer.\n");

  done = SPACE;
  do {
    disp_matrix();         /* display the game board */
    get_player_move();     /* get your move */
    done = check();          /* see if winner */
    if(done!=SPACE) break; /* winner!*/
    get_computer_move();   /* get computer's move */
    done=check();          /* see if winner */
  } while(done==SPACE);
  if(done=='X') printf("You won!\n");
  else printf("I won!!!!\n");
  disp_matrix(); /* show final positions */

  return 0;
}

/* Input the player's move. */
void get_player_move(void)
{
  int x, y;

  printf("Enter coordinates for your X.\n");
  printf("Row? ");
  scanf("%d", &x);
  printf("Column? ");
  scanf("%d", &y);
  x--; y--;
  if(x<0 || y<0 || x>2 || y>2 || matrix[x][y]!=SPACE) {
    printf("Invalid move, try again.\n");
    get_player_move();
  }
  else matrix[x][y]='X';
}

/* Get the computer's move */
void get_computer_move(void)
{
  register int t;
  char *p;

  p = (char *) matrix;
  for(t=0; *p!=SPACE && t<9; ++t) p++;
  if(t==9)  {
    printf("draw\n");
    exit(0); /* game over */
  }
  else *p = 'O';
}

/* Display the game board. */
void disp_matrix(void)
{
  int t;

  for(t=0; t<3; t++) {
    printf(" %c | %c | %c ", matrix[t][0],
      matrix[t][1], matrix [t][2]);
    if(t!=2) printf("\n---|---|---\n");
  }
   printf("\n");
}

/* See if there is a winner. */
char check(void)
{
  int t;
  char *p;

  for(t=0; t<3; t++) { /* check rows */
    p = &matrix[t][0];
    if(*p==*(p+1) && *(p+1)==*(p+2)) return *p;
  }

  for(t=0; t<3; t++) { /* check columns */
    p = &matrix[0][t];
    if(*p==*(p+3) && *(p+3)==*(p+6)) return *p;
  }

  /* test diagonals */
  if(matrix[0][0]==matrix[1][1] && matrix[1][1]==matrix[2][2])
    return matrix[0][0];

  if(matrix[0][2]==matrix[1][1] && matrix[1][1]==matrix[2][0])
    return matrix[0][2];

  return SPACE;
}

listing 1
p = &num;

listing 2
q = *p;

listing 3
#include <stdio.h>

int main(void)
{
  int num, q;
  int *p;

  num = 100; /* num is assigned 100 */
  p = &num;  /* p receives num's address */
  q = *p;    /* q is assigned num's value
                  indirectly through p */

  printf("%d", q); /* prints 100 */

  return 0;
}

listing 4
#include <stdio.h>

int main(void)
{
  double x, y;
  int  *p;

  x = 100.123;

  p = &x;
  y = *p;
  printf("%f", y);  /* this will be wrong */

  return 0;
}

listing 5
#include <stdio.h>

int main(void)
{
  int x;
  int *p1, *p2;

  p1 = &x;
  p2 = p1;

  /* This will display the addresses held by
     p1 and p2. They will be the same.
  */
  printf("%p  %p", p1, p2);

  return 0;
}

listing 6
p1++;

listing 7
p1--;

listing 8
p1 = p1 + 9;

listing 9
if(p<q) printf("p points to lower memory than q\n");

listing 10
#include <stdio.h>
#include <stdlib.h>

#define STCKSIZE 50

void push(int i);
int pop(void);

int *p1, *tos, stack[STCKSIZE];

int main(void)
{
  int value;

  p1 =  stack; /* assign p1 the start of stack */
  tos = p1;  /* let tos hold top of stack */

  do {
    printf("Enter a number (-1 to quit, 0 to pop): ");
    scanf("%d", &value);
    if(value!=0) push(value);
    else printf("this is it %d\n", pop());
  } while(value!=-1);
  return 0;
}

void push(int i)
{
  p1++;
  if(p1==(tos + STCKSIZE)) {
    printf("stack overflow");
    exit(1);
  }
  *p1 = i;
}

int pop(void)
{
  if(p1==tos) {
    printf("stack underflow");
    exit(1);
  }
  p1--;
  return *(p1+1);
}

listing 11
return *p1 + 1;

listing 12
  char *p;

  p = (char *) malloc(25); 

listing 13
int *p;

p = (int *) malloc(50*sizeof(int));

listing 14
int *p;

if((p = (int *) malloc(100))==NULL) {
  printf("Out of memory.\n");
  exit(1);
}

listing 15
#include <stdio.h>

void sp_to_dash(const char *str);

int main(void)
{
  sp_to_dash("this is a test");

  return 0;
}

void sp_to_dash(const char *str)
{
  while(*str) {
    if(*str == ' ') printf("%c", '-');
    else printf("%c", *str);
    str++;
  }
}

listing 16
/* This is wrong. */
void sp_to_dash(const char *str)
{
  while(*str) {
    if(*str == ' ') *str = '-'; /* can't do this */
    printf("%c", *str);
    str++;
  }
}

listing 17
char str[80], *p1;
p1 = str;

listing 18
str[4]

listing 20
/* Use array. */
int puts(const char *s)
{
  register int t;

  for(t=0; s[t]; ++t) putchar(s[t]);
  return 1;
}

/* Use pointer. */
int puts(const char *s)
{
  while(*s) putchar(*s++);
  return 1;
}

listing 21
/* Use pointers. */
int strcmp(const char *s1, const char *s2)
{
  while(*s1)
    if(*s1-*s2)
      return *s1-*s2;
    else {
      s1++;
      s2++;
    }
  return 0; /* equal */
}

listing 22
while (*s1)

listing 23
/* This program is incorrect. */

#include <stdio.h>
#include <string.h>

int main(void)
{
  char *p1, s[80];

  p1 = s;  /* assign p1 the starting address of s */
  do {
    gets(s);  /* read a string */

    /* print the decimal equivalent of each
       character */
    while(*p1) printf(" %d", *p1++);

  } while(strcmp(s, "done"));
  return 0;
}

listing 24
/* This program is correct. */

#include <stdio.h>
#include <string.h>

int main(void)
{
  char *p1, s[80];

  do {
    p1 = s; /* assign p1 the starting address of s */
    gets(s);  /* read a string */

    /* print the decimal equivalent of each
       character */
    while(*p1) printf(" %d", *p1++);

  } while(strcmp(s, "done"));
  return 0;
}

listing 25
int *x[10];

listing 26
x[2] = &var;

listing 27
*x[2]

listing 28
void display_array(int *q[])
{
  int t;

  for(t=0; t<10; t++)
    printf("%d ", *q[t]);
}

listing 29
void serror(int num)
{
  static char *err[] = {
    "Cannot Open File\n",
    "Read Error\n",
    "Write Error\n",
    "Media Failure\n"
  };

  printf("%s", err[num]);
}

listing 30
float **newbalance;

listing 31
#include <stdio.h>

int main(void)
{
  int x, *p, **q;

  x = 10;
  p = &x;
  q = &p;

  printf("%d", **q); /* print the value of x */

  return 0;
}

listing 32
 /* Look up a name. */
int search(char *p[], char *name)
{
  register int t;
  for(t=0; p[t]; ++t)
    if(!strcmp(p[t], name)) return t;

  return -1; /* not found */
}

listing 33
char *p = "hello world\n";

listing 34
#include <stdio.h>
#include <string.h>

char *p = "hello world";

int main(void)
{
  register int t;

  /* print the string forward and backwards */
  printf(p);
  for(t=strlen(p)-1; t>-1; t--) printf("%c", p[t]);
  return 0;
}


listing 35
void enter(void), del(void), review(void), quit(void);
int menu(void);

void (*options[])(void) = {
  enter,
  del,
  review,
  quit
} ;

listing 36
#include <stdlib.h>
#include <stdio.h>
#include <conio.h>
#include <string.h>

void enter(void), del(void), review(void), quit(void);
int menu(void);

void (*options[])(void) = {
  enter,
  del,
  review,
  quit
} ;

int main(void)
{
  int i;

  i = menu(); /* get user's choice */

  (*options[i])();  /* execute it */
  return 0;

}

int menu(void)
{
  char ch;

  do {

    printf("1. Enter\n");
    printf("2. Delete\n");
    printf("3. Review\n");
    printf("4. Quit\n");
    printf("Select a number: ");
    ch = getche();
    printf("\n");
  } while(!strchr("1234", ch));
  return ch-49; /* convert to an integer equivalent */
}

void enter(void)
{
  printf("In enter.");
}

void del(void)
{
  printf("In del.");
}

void review(void)
{
  printf("In review.");
}

void quit(void)
{
  printf("In quit.");
  exit(0);
}

listing 37
/* This program is wrong. */

int main(void)
{
  int x, *p;

  x = 10;
  *p = x;

  return 0;
}

listing 38
#include <stdio.h>

/* This program is wrong. */
int main(void)
{
  int x, *p;

  x = 10;
  p = x;
  printf("%d", *p);

  return 0;
}

listing 39
p = x;

listing 40
p = &x;

listing 1
struct addr {
  char name[30];
  char street[40];
  char city[20];
  char state[3];
  unsigned long int zip;
};

listing 2
struct addr addr_info;

listing 3
struct addr {
  char name[30];
  char street[40];
  char city[20];
  char state[3];
  unsigned long int zip;
} addr_info, binfo, cinfo;

listing 4
struct {
  char name[30];
  char street[40];
  char city[20];
  char state[3];
  unsigned long int zip;
} addr_info;

listing 5
addr_info.zip = 12345;

listing 6
printf("%ld", addr_info.zip);

listing 7
gets(addr_info.name);

listing 8
register int t;

for(t=0; addr_info.name[t]; ++t) putchar(addr_info.name[t]);


listing 9
#include <stdio.h>

int main(void)
{
  struct {
    int a;
    int b;
  } x, y;

  x.a = 10;
  x.b = 20;

  y = x; /* assign one structure to another */

  printf("Contents of y: %d %d.", y.a, y.b);

  return 0;
}

listing 10
struct addr addr_info[100];

listing 11
printf("%ld", addr_info[2].zip);

listing 12
#define MAX 100

struct inv {
  char item[30];
  float cost;
  int on_hand;
} inv_info[MAX];

listing 13
int main(void)
{
  char choice;

  init_list(); /* initialize the structure array */
  for(;;) {
    choice = menu_select();
    switch(choice) {
      case 1: enter();
        break;
      case 2: del();
        break;
      case 3: list();
        break;
      case 4: return 0;
    }
  }
}

listing 14
/* Initialize the structure array. */
void init_list(void)
{
  register int t;

  for(t=0; t<MAX; ++t) inv_info[t].item[0] = '\0';
}

listing 15
/* Input the user's selection. */
int menu_select(void)
{
  char s[80];
  int c;

  printf("\n");
  printf("1. Enter an item\n");
  printf("2. Remove an item\n");
  printf("3. List the inventory\n");
  printf("4. Quit\n");
  do {
    printf("\nEnter your choice: ");
    gets(s);
    c = atoi(s);
  } while(c<0 || c>4);
  return c;
}

listing 16
/* Input the inventory information. */
void enter(void)
{
  int slot;

  slot = find_free();
  if(slot == -1) {
    printf("\nList Full");
    return;
  }

  printf("Enter item: ");
  gets(inv_info[slot].item);

  printf("Enter cost: ");
  scanf("%f", &inv_info[slot].cost);

  printf("Enter number on hand: ");
  scanf("%d%*c",&inv_info[slot].on_hand);
}

/* Return the index of the first unused array
   location or -1 if no free locations exist.
*/
int find_free(void)
{
  register int t;

  for(t=0; inv_info[t].item[0] && t<MAX; ++t) ;
  if(t == MAX) return -1; /* no slots free */
  return t;
}

listing 17
/* Remove an item from the list. */
void del(void)
{
  register int slot;
  char s[80];

  printf("enter record #: ");
  gets(s);
  slot = atoi(s);
  if(slot >= 0 && slot < MAX) inv_info[slot].item[0] = '\0';
}

listing 18
/* Display the list on the screen. */
void list(void)
{
  register int t;

  for(t=0; t<MAX; ++t) {
    if(inv_info[t].item[0]) {
      printf("Item: %s\n", inv_info[t].item);
      printf("Cost: %f\n", inv_info[t].cost);
      printf("On hand: %d\n\n", inv_info[t].on_hand);
    }
  }
  printf("\n\n");
}

listing 19
/* A simple inventory program using an array of structures */

#include <stdio.h>
#include <stdlib.h>

#define MAX 100

struct inv {
  char item[30];
  float cost;
  int on_hand;
} inv_info[MAX];

void init_list(void), list(void), del(void);
void enter(void);
int menu_select(void), find_free(void);

int main(void)
{
  char choice;

  init_list(); /* initialize the structure array */
  for(;;) {
    choice = menu_select();
    switch(choice) {
      case 1: enter();
        break;
      case 2: del();
        break;
      case 3: list();
        break;
      case 4: return 0;
    }
  }
}

/* Initialize the structure array. */
void init_list(void)
{
  register int t;

  for(t=0; t<MAX; ++t) inv_info[t].item[0] = '\0';
}

/* Input the user's selection. */
int menu_select(void)
{
  char s[80];
  int c;

  printf("\n");
  printf("1. Enter an item\n");
  printf("2. Remove an item\n");
  printf("3. List the inventory\n");
  printf("4. Quit\n");
  do {
    printf("\nEnter your choice: ");
    gets(s);
    c = atoi(s);
  } while(c<0 || c>4);
  return c;
}

/* Input the inventory information. */
void enter(void)
{
  int slot;

  slot = find_free();
  if(slot == -1) {
    printf("\nList Full");
    return;
  }

  printf("Enter item: ");
  gets(inv_info[slot].item);

  printf("Enter cost: ");
  scanf("%f", &inv_info[slot].cost);

  printf("Enter number on hand: ");
  scanf("%d%*c", &inv_info[slot].on_hand);
}

/* Return the index of the first unused array
   location or -1 if no free locations exist.
*/
int find_free(void)
{
  register int t;

  for(t=0; inv_info[t].item[0] && t<MAX; ++t) ;
  if(t == MAX) return -1; /* no slots free */
  return t;
}

/* Remove an item from the list. */
void del(void)
{
  register int slot;
  char s[80];

  printf("enter record #: ");
  gets(s);
  slot = atoi(s);
  if(slot >= 0 && slot < MAX) inv_info[slot].item[0] = '\0';
}

/* Display the list on the screen. */
void list(void)
{
  register int t;

  for(t=0; t<MAX; ++t) {
    if(inv_info[t].item[0]) {
      printf("Item: %s\n", inv_info[t].item);
      printf("Cost: %f\n", inv_info[t].cost);
      printf("On hand: %d\n\n", inv_info[t].on_hand);
    }
  }
  printf("\n\n");
}


listing 20
double d = sin(0.5);

listing 21
struct fred {
  char x;
  int y;
  float z;
  char s[10];
} mike;

listing 22
func(mike.x);    /* passes character value of x */
func2(mike.y);   /* passes integer value of y */
func3(mike.z);   /* passes float value of z */
func4(mike.s);   /* passes address of string s */
func(mike.s[2]); /* passes character value of s[2] */

listing 23
func(&mike.x);    /* passes address of character x */
func2(&mike.y);   /* passes address of integer y */
func3(&mike.z);   /* passes address of float z */
func4(mike.s);    /* passes address of string s */
func(&mike.s[2]); /* passes address of character s[2] */

listing 24
#include <stdio.h>

/* declare a structure type */
struct struct_type {
  int a, b;
  char ch;
} ;

void f1(struct struct_type parm);

int main(void)
{
  struct struct_type arg;  /* declare arg */

  arg.a = 1000;

  f1(arg);

  return 0;
}

void f1(struct struct_type parm)
{
  printf("%d", parm.a);
}

listing 25
struct addr *addr_pointer;

listing 26
struct bal {
  float balance;
  char name[80];
} person;

struct bal *p;  /* declare a structure pointer */

listing 27
p = &person;

listing 28
p->balance

listing 29
/* Display a software timer. */

#include <stdio.h>
#include <conio.h>

#define DELAY 128000

struct my_time {
  int hours;
  int minutes;
  int seconds;
} ;

void update(struct my_time *t), display(struct my_time *t);
void mydelay(void);

int main(void) 
{
  struct my_time systime;

  systime.hours = 0;
  systime.minutes = 0;
  systime.seconds = 0;

  for(;;) {
    update(&systime);
    display(&systime);
    if(kbhit()) return 0;
  }
}

void update(struct my_time *t)
{
  t->seconds++;
  if(t->seconds==60) {
    t->seconds = 0;
    t->minutes++;
  }
  if(t->minutes==60) {
    t->minutes = 0;
    t->hours++;
  }
  if(t->hours==24) t->hours = 0;
  mydelay();
}

void display(struct my_time *t)
{
  printf("%02d:", t->hours);
  printf("%02d:", t->minutes);
  printf("%02d\n", t->seconds);
}

void mydelay(void)
{
  long int t;

  for(t=1; t<DELAY; ++t) ;
}

listing 30
if(t->hours==24) t->hours = 0;

listing 31
/* A generalized input example using structure pointers. */

#include <stdio.h>
#include <conio.h>
#include <string.h>

struct xyinput {
  int x, y; /* screen location for prompt */
  char message[80]; /* prompting message */
  int i; /* input value */
} ;

void input_xy(struct xyinput *info);

int main(void)
{
  struct xyinput mess;

  mess.x = 10; mess.y = 10;
  strcpy(mess.message, "Enter an integer: ");

  clrscr();

  input_xy(&mess);

  printf("Your number squared is: %d.", mess.i*mess.i);

  return 0;
}

/* Display a prompting message at the specified location
   and input an integer value.
*/
void input_xy(struct xyinput *info)
{
  gotoxy(info->x, info->y);

  printf(info->message);
  scanf("%d", &info->i);
}

listing 32
struct x {
  int a[10][10]; /* 10 x 10 array of ints */
  float b;
} y;

listing 33
y.a[3][7]

listing 34
struct emp {
  struct addr address;
  float wage;
} worker;

listing 35
worker.wage = 35000.00;

worker.address.zip = 98765;

listing 36
struct device {
  unsigned active : 1;
  unsigned ready : 1;
  unsigned xmt_error : 1;
} dev_code;

listing 37
void wr_tape(char c)
{
  while(!dev_code.ready) rd(&dev_code); /* wait */

  wr_to_tape(c); /* write out byte */

  while(dev_code.active) rd(&dev_code); /* wait until
                                           info is written */

  if(dev_code.xmt_error) printf("Write Error");
}

listing 38
struct device {
  unsigned active : 1;
  unsigned ready : 1;
  unsigned xmt_error : 1;
  unsigned : 2;
  unsigned EOT : 1;
} dev_code;

listing 39
struct emp {
  struct addr address;
  float pay;
  unsigned lay_off:1;  /* lay off or active */
  unsigned hourly:1;   /* hourly pay or wage */
  unsigned deductions:3; /* IRS deductions */
};

listing 40
union union_type {
  int i;
  char ch;
} ;

listing 41
union union_type cnvt;

listing 42
cnvt.i = 10;

listing 43
union pw {
  int i;
  char ch[2];
};

listing 44
#include <stdio.h>
#include <stdlib>

union pw {
  int i;
  char ch[2];
};

int write_int(int num, FILE *fp);

int main()
{
  FILE *fp;

  fp = fopen("test.tmp", "w+");

  if(fp==NULL) {
    printf("Cannot open file.\n");
    exit(1);
  }

  write_int(1000, fp);
  fclose(fp);

  return 0;
}

/* write an integer using union */
int write_int(int num, FILE *fp)
{
  union pw wrd;

  wrd.i = num;
  putc(wrd.ch[0], fp); /* write first half */
  return putc(wrd.ch[1], fp); /* write second half */
}

listing 45
enum coin { penny, nickel, dime, quarter,
            half_dollar, dollar};

enum coin money;

listing 46
money = dime;

if(money==quarter) printf("is a quarter\n");

listing 47
printf("The value of quarter is %d ", quarter);

listing 48
printf("%d %d", penny, dime);

listing 49
enum coin { penny, nickel, dime, quarter=100,
            half_dollar, dollar};

listing 50
/* This will not work. */

money = dollar;

printf("%s", money);

listing 51
/* This code will not work. */

money = "penny";

listing 52
switch(money) {
  case penny: printf("penny");
     break;
  case nickel: printf("nickel");
     break;
  case dime: printf("dime");
     break;
  case quarter: printf("quarter");
     break;
  case half_dollar: printf("half_dollar");
     break;
  case dollar: printf("dollar");
}

listing 53
char name[][12]={
  "penny",
  "nickel",
  "dime",
  "quarter",
  "half_dollar",
  "dollar"
};
 .
 .
 .
printf("%s", name[money]);

listing 54
char ch;
int i;
float f;

printf("%d", sizeof ch);

printf("%d", sizeof i);

printf("%d", sizeof f);

printf("%d", sizeof(long double));

listing 55
struct s {
  char ch;
  int i;
  float f;
} s_var;

listing 56
union u {
  char ch;
  int i;
  float f;
} u_var;

listing 57
typedef float balance;

listing 58
balance past_due;

listing 59
typedef struct {
  float due;
  int over_due;
  char name[40];
} client;  /* here client is the new type name */

client clist[NUM_CLIENTS]; /* define array of
                              structures of type client */

listing 1
/* Case Switcher */
#include <conio.h>
#include <stdio.h>
#include <ctype.h>

int main(void) {
  char ch;

  do {
    ch = getche();
    if(islower(ch)) putchar(toupper(ch));
    else putchar(tolower(ch));
  } while (ch!='.'); /* use a period to stop*/
  return 0;
}

listing 2
/* This program appears to act as a command-prompt gone wild. It
   displays the command prompt but displays every character
   the user types as the next letter in the alphabet.
*/

#include <stdio.h>
#include <conio.h>

int main(void)
{
  char ch;

  do {
    printf("C>");
    for(;;) {
      ch = getch(); /* read chars without echo */
      if(ch=='\r' || ch==1) {
        printf("\n");
        break;
      }
      putchar(ch+1);
    }
  } while(ch!=1) ; /* exit on control-A */

  return 0;
}

listing 3
#include <stdio.h>
#include <string.h>

int main(void)
{
  char str[80];

  gets(str);
  printf("Length is %d", strlen(str));

  return 0;
}

listing 4
puts("hello");

listing 5
printf("Hi %c %d %s", 'c', 10, "there!");

listing 6
#include <stdio.h>

int main(void)
{
  double f;

  for(f=1.0; f<1.0e+10; f=f*10)
    printf("%g ", f);

  return 0;
}

listing 7
#include <stdio.h>

int main(void)
{
  unsigned num;

  for(num=0; num<255; num++) {
    printf("%o ", num);
    printf("%x ", num);
    printf("%X\n", num);
  }

  return 0;
}

listing 8
#include <stdio.h>

int sample;

int main(void)
{
  printf("%p", &sample);

  return 0;
}

listing 9
#include <stdio.h>

int main(void)
{
  int count;

  printf("this%n is a test\n", &count);
  printf("%d", count);

  return 0;
}

listing 10
#include <stdio.h>

int main(void)
{
  double item;

  item = 10.12304;

  printf("%f\n", item);
  printf("%10f\n", item);
  printf("%012f\n", item);

  return 0;
}

listing 11
#include <stdio.h>

int main(void)
{
  int i;

  /* display a table of squares and cubes */
  for(i=1; i<20; i++)
    printf("%8d %8d %8d\n", i, i*i, i*i*i);

  return 0;
}

listing 12
#include <stdio.h>

int main(void)
{
  printf("%.4f\n", 123.1234567);
  printf("%3.8d\n", 1000);
  printf("%10.15s\n", "This is a simple test.");

  return 0;
}

listing 13
#include <stdio.h>

int main(void)
{
  printf("right-justified:%8d\n", 100);
  printf("left-justified:%-8d\n", 100);

  return 0;
}

listing 14
#include <stdio.h>

int main(void)
{
  printf("%x %#x\n", 10, 10);
  printf("%*.*f", 10, 4, 1234.34);

  return 0;
}

listing 15
#include <stdio.h>

int main(void)
{
  int i, j;

  scanf("%o%x", &i, &j);
  printf("%o %x", i, j);

  return 0;
}

listing 16
unsigned num;
scanf("%u", &num);

listing 17
scanf("%c%c%c", &a, &b, &c);

listing 18
#include <stdio.h>

int main(void)
{
  char str[80];

  printf("Enter a string: ");
  scanf("%s", str);
  printf("Here's your string: %s", str);

  return 0;
}

listing 19
#include <stdio.h>

int main(void)
{
  char *p;

  printf("Enter an address: ");
  scanf("%p", &p);
  printf("Value at location %p is %c\n", p, *p);

  return 0;
}

listing 20
%[XYZ]

listing 21
#include <stdio.h>

int main(void)
{
  int i;
  char str[80], str2[80];

  scanf("%d%[abcdefg]%s", &i, str, str2);
  printf("%d %s %s", i, str, str2);

  return 0;
}

listing 22
%[A-Z]

listing 23
/* A scanset example using ranges. */
#include <stdio.h>

int main(void)
{
  char s1[80], s2[80];

  printf("Enter numbers, then some letters");
  scanf("%[0-9]%[a-zA-Z]", s1, s2);
  printf("%s %s", s1, s2);

  return 0;
}

listing 24
/* A scanset example using inverted ranges. */
#include <stdio.h>

int main(void)
{
  char s1[80], s2[80];

  printf("Enter non-numbers, then some non-letters");
  scanf("%[^0-9]%[^a-zA-Z]", s1, s2);
  printf("%s %s", s1, s2);

  return 0;
}

listing 25
scanf("%d", &count);

listing 26
scanf("%s", str);

listing 27
scanf("%20s", str);

listing 28
scanf("%s", str);

listing 29
scanf("%d%*c%d", &x, &y);

listing 30
FILE *fp;

listing 31
fp = fopen("test", "w");

listing 32
if((fp = fopen("test", "w"))==NULL) {
  puts("Cannot open file.");
  exit(1);
}

listing 33
ch = getc(fp);

while(ch!=EOF) {
  ch = getc(fp);
}

listing 34
/* ktod: key to disk. */

#include <stdio.h>

int main(int argc, char *argv[])
{
  FILE *fp;
  char ch;

  if(argc!=2) {
    printf("You forgot to enter the filename.");
    return 1;
  }

  if((fp=fopen(argv[1], "w")) == NULL) {
    printf("Cannot open file.");
    return 1;
  }

  do {
    ch = getchar();
    putc(ch, fp);
  } while (ch!='.');

  fclose(fp);

  return 0;
}

listing 35
/* dtos: disk to screen. */
#include <stdio.h>

int main(int argc, char *argv[])
{
  FILE *fp;
  char ch;

  if(argc!=2) {
    printf("You forgot to enter the filename.");
    return 1;
  }

  if((fp=fopen(argv[1], "r")) == NULL) {
    printf("Cannot open file.");
    return 1;
  }

  ch = getc(fp);   /* read one character */

  while (ch!=EOF) {
    putchar(ch);  /* print on screen */
    ch = getc(fp);
  }

  fclose(fp);

  return 0;
}

listing 36
while(!feof(fp)) ch = getc(fp);

listing 37
/* This program will copy a file to another. */
#include <stdio.h>

int main(int argc, char *argv[])
{
  FILE *in, *out;
  char ch;

  if(argc!=3) {
    printf("You forgot to enter a filename.");
    return 1;
  }

  if((in=fopen(argv[1], "rb")) == NULL) {
    printf("Cannot open source file.");
    return 1;
  }
  if((out=fopen(argv[2], "wb")) == NULL) {
    printf("Cannot open destination file.");
    return 1;
  }

  /* This code actually copies the file. */
  while(!feof(in)) {
     ch = getc(in);
     if(!feof(in)) putc(ch, out);
  }

  fclose(in);
  fclose(out);

  return 0;
}

listing 38
putw(100, fp);

listing 39
#include <stdio.h>

int main(void)
{
  char s[80];

  printf("Enter a string: ");
  fgets(s, 80, stdin);
  printf("Here is your string: %s", s);

  return 0;
}

listing 40
/* Write a floating point number to a disk file. */
#include <stdio.h>

int main(void)
{
  FILE *fp;
  float f = 12.23;

  if((fp=fopen("test", "wb"))==NULL) {
    printf("Cannot open file.");
    return 1;
  }

  fwrite(&f, sizeof(float), 1, fp);
  fclose(fp);

  return 0;
}

listing 41
#include <stdio.h>

int main(void)
{
  register int i;
  FILE *fp;
  float balance[100];

  /* open for write */
  if((fp=fopen("balance", "wb"))==NULL) {
    printf("Cannot open file.");
    return 1;
  }

  for(i=0; i<100; i++) balance[i] = (float) i;

  /* this saves the entire balance array in one step */
  fwrite(balance, sizeof balance, 1, fp);
  fclose(fp);

  /* zero array */
  for(i=0; i<100; i++) balance[i] = 0.0;

  /* open for read */
  if((fp=fopen("balance","rb"))==NULL) {
    printf("cannot open file");
    return 1;
  }

  /* this reads the entire balance array in one step */
  fread(balance, sizeof balance, 1, fp);

  /* display contents of array */
  for(i=0; i<100; i++) printf("%f ", balance[i]);

  fclose(fp);
  return 0;
}

listing 42
int func1(void)
{
  FILE *fp;

  if((fp=fopen("test", "rb")) == NULL) {
    printf("Cannot open file.");
    exit(1);
  }

  fseek(fp, 234L, 0);
  return getc(fp);   /* read one character */
                     /* at 234th position */
  }
}

listing 43
/* dump: A simple disk look utility using fseek. */
#include <stdio.h>
#include <ctype.h>

#define SIZE 128

void display(int numread);

char buf[SIZE];
void display();

int main(int argc, char *argv[])
{
  FILE *fp;
  int sector, numread;

  if(argc!=2) {
    printf("Usage: dump filename");
    return 1;
  }

  if((fp=fopen(argv[1], "rb"))==NULL) {
    printf("Cannot open file.");
    return 1;
  }

  do {
    printf("Enter sector: ");
    scanf("%d", &sector);
    if(sector >= 0) {
      if(fseek(fp, sector*SIZE, SEEK_SET)) {
        printf("seek error");
      }
      if((numread=fread(buf, 1, SIZE, fp)) != SIZE)
        printf("EOF reached.");

      display(numread);
    }
  } while(sector>=0);
  return 0;
}

/* Display the contents of a file. */
void display(int numread)
{
  int i, j;

  for(i=0; i<numread/16; i++) {
    for(j=0; j<16; j++) printf("%3X", buf[i*16+j]);
    printf("  ");
    for(j=0; j<16; j++) {
      if(isprint(buf[i*16+j])) printf("%c", buf[i*16+j]);
      else printf(".");
    }
    printf("\n");
  }
}

listing 44
/* A simple telephone directory */

#include <conio.h>
#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>
#include <string.h>

void add_num(void), lookup(void);
char menu(void);

int main(void) 
{
  char choice;

  do {
    choice = menu();
    switch(choice) {
      case 'a': add_num();
        break;
      case 'l': lookup();
        break;
    }
  } while (choice!='q');

  return 0;
}

/* Display menu and get request. */
char menu(void)
{
  char ch;

  do {
    printf("(A)dd, (L)ookup, or (Q)uit: ");
    ch = tolower(getche());
    printf("\n");
  } while(ch != 'q' && ch != 'a' && ch != 'l');

  return ch;
}

/* Add a name and number to the directory. */
void add_num(void)
{
  FILE *fp;
  char name[80];
  int a_code, exchg, num;

  /* open it for append */
  if((fp=fopen("phone","a")) == NULL) {
    printf("Cannot open directory file.");
    exit(1);
  }

  printf("Enter name and number: ");
  fscanf(stdin, "%s%d%d%d", name, &a_code, &exchg, &num);
  fscanf(stdin, "%*c"); /* remove CR from input stream */

  /* write to file */
  fprintf(fp,"%s %d %d %d\n", name, a_code, exchg, num);

  fclose(fp);
}

/* Find a number given a name. */
void lookup(void)
{
  FILE *fp;
  char name[80], name2[80];
  int a_code, exchg, num;

  /* open it for read */
  if((fp=fopen("phone","r")) == NULL) {
    printf("Cannot open directory file.");
    exit(1);
  }

  printf("name? ");
  gets(name);

  /* look for number */
  while(!feof(fp)) {
    fscanf(fp,"%s%d%d%d", name2, &a_code, &exchg, &num);
    if(!strcmp(name, name2)) {
      printf("%s: (%d) %d-%d\n",name, a_code, exchg, num);
      break;
    }
  }

  fclose(fp);
}

listing 45
/* A remove() example. */

#include <stdio.h>

int main(void)
{
  char fname[80];

  printf("Name of file to remove: ");
  gets(fname);

  if(remove(fname)) {
    printf("Error removing file");
    return 1;
  }

  else return 0;
}

listing 46
int putchar(int c)
{
  return putc(c, stdout);
}

listing 47
#include <stdio.h>

int main(void)
{
  char str[80];

  printf("Enter a string: ");
  gets(str);
  printf(str);

  return 0;
}

listing 1
/* Will not work! */
#include <stdio.h>  #include <stdlib.h>

listing 2
#define TRUE 1
#define FALSE 0

listing 3
printf("%d %d %d", FALSE, TRUE, TRUE+1);

listing 4
#define ONE   1
#define TWO   ONE+ONE
#define THREE ONE+TWO

listing 5
#define E_MS "Standard error on input.\n"
/* ... */
printf(E_MS);

listing 6
printf("Standard error on input.\n");

listing 7
#define XYZ this is a test
/* ... */
printf("XYZ");

listing 8
#define LONG_STRING "This is a very long \
string that is used as an example."

listing 9
#define MAX_SIZE 100
/* ... */
float balance[MAX_SIZE];
/* ... */
float temp[MAX_SIZE];

listing 10
#include <stdio.h>

#define MIN(a,b)  ((a)<(b)) ? (a) : (b)

int main(void)
{
  int x, y;

  x = 10;
  y = 20;
  printf("The minimum is: %d", MIN(x, y));

  return 0;
}

listing 11
printf("The minimum is: %d",((x)<(y)) ? (x) : (y));

listing 12
/* This program will give the wrong answer. */

#include <stdio.h>

#define EVEN(a) a%2==0 ? 1 : 0

int main(void)
{
  if(EVEN(9+1)) printf("is even");
  else printf("is odd");

  return 0;
}

listing 13
9+1%2==0 ? 1 : 0

listing 14
#include <stdio.h>

#define EVEN(a) (a)%2==0 ? 1 : 0

int main(void)
{
  if(EVEN(9+1)) printf("is even");
  else printf("is odd");

  return 0;
}

listing 15
#include "stdio.h"
#include <stdio.h>

listing 16
/* The program file: */
#include <stdio.h>

int main(void)
{
  #include "one"

  return 0;
}



/* Include file ONE: */
printf("This is from the first include file.\n");
#include "two"



/* Include file TWO: */
printf("This is from the second include file.\n");

listing 17
/* A simple #if example. */
#include <stdio.h>

#define MAX 100
int main(void)
{
#if MAX>99
  printf("Compiled for array greater than 99.\n");
#endif
  return 0;
}

listing 18
/* A simple #if/#else example. */
#include <stdio.h>

#define MAX 10
int main(void)
{
#if MAX>99
  printf("Compiled for array greater than 99.\n");
#else
  printf("Compiled for small array.\n");
#endif
  return 0;
}

listing 19
#define US 0
#define ENGLAND 1
#define FRANCE 2

#define ACTIVE_COUNTRY US

#if ACTIVE_COUNTRY==US
  char currency[] = "dollar";
#elif ACTIVE_COUNTRY==ENGLAND
  char currency[] = "pound";
#else
  char currency[] = "franc";
#endif

listing 20
#if MAX>100
   #if SERIAL_VERSION
      int port = 198;
   #elif
      int port = 200;
   #endif
#else
   char out_buffer[100];
#endif

listing 21
#if (sizeof(char *) == 2)
  printf("Program compiled for small array.");
#else
  printf("Program compiled for large array.");
#endif

listing 22
#include <stdio.h>

#define TED 10

int main(void)
{
#ifdef TED
  printf("Hi Ted\n");
#else
  printf("Hi anyone\n");
#endif
#ifndef RALPH
  printf("RALPH not defined\n");
#endif
  return 0;
}

listing 23
#define LEN 100
#define WIDTH 100

char array[LEN][WIDTH];

#undef LEN
#undef WIDTH
/* at this point both LEN and WIDTH are undefined */

listing 24
#if defined MYFILE

listing 26
#if !defined DEBUG
  printf("Final version!\n");
#endif

listing 27
#include <stdio.h>

#line 100                    /* reset the line counter */
int main(void)               /* line 100 */
{                            /* line 101 */
  printf("%d\n", __LINE__);  /* line 102 */

  return 0;
}

listing 28
void f(void);

listing 29
#include <stdio.h>

void start(void);

#pragma startup start 65

int main(void)
{
  printf("In main\n");

  return 0;
}

void start(void)
{
  printf("In start\n");
}

listing 30
#include <stdio.h>

#pragma message This will be displayed as a warning.

int main(void)
{
  int i=10;

  printf("This is i: %d\n", i);
#pragma message This is also displayed as a warning.
  return 0;
}

listing 31
#pragma option -ml

listing 32
#include "stdio.h"

#define mkstr(s)  # s

int main(void)
{
  printf(mkstr(I like C));

  return 0;
}

listing 33
printf(mkstr(I like C));

listing 34
printf("I like C");

listing 35
#include "stdio.h"

#define concat(a, b)  a ## b

int main(void)
{
  int xy = 10;

  printf("%d", concat(x, y));

  return 0;
}

listing 36
printf("%d", concat(x, y));

listing 37
printf("%d", xy);

listing 38
#include <stdio.h>

int main(void)
{
  printf("hello");
  /* printf("there"); */

  return 0;
}

listing 39
x = 10+ /* add the numbers */5;

listing 40
swi/*this will not work*/tch(c) { ...

listing 41
/* this is an outer comment
  x = y/a;
  /* this is an inner comment - and causes an error */
*/

listing 1
int count;
extern void display(void);

int main(void)
{
  count = 10;
  display();
  return 0;
}

listing 2
#include <stdio.h>
extern int count;

void display(void)
{
  printf("%d", count);
}

listing 3
#include <string.h>

char s1[20] = "hello ";
char s2[] = "there.";

int main(void)
{
  int p;

  p = strcat(s1, s2);
  return 0;
}

listing 1
#include <stdio.h>
#include <io.h>

int main(void)
{
  if(!access("TEST.TST", 0))
    printf("File Present");
  else
    printf("File not Found");
  return 0;
}

listing 2
if(_rtl_chmod("TEST.TST", 1, FA_RDONLY)==FA_RDONLY)
  printf("File set to read-only mode.");

listing 3
if(!chmod("TEST.TST", S_IREAD | S_IWRITE))
  printf("File set to read/write access.");

listing 4
/*
  Assume that a file associated with handle
  has been opened.
*/

if(!chsize(handle, 256))
  printf("File size is now 256 bytes.");

listing 5
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char *argv[])  /* copy one file to another */
{
  FILE *in, *out;
  char ch;

  if(argc!=3) {
    printf("You forgot to enter a filename\n");
    exit(0);
  }

  if((in=fopen(argv[1], "rb")) == NULL) {
    printf("Cannot open file.\n");
    exit(0);
  }
  if((out=fopen(argv[2],"wb")) == NULL) {
    printf("Cannot open file.\n");
    exit(0);
  }

  while(!feof(in)) {
    ch = getc(in);
    if(ferror(in)) {
      printf("Read Error");
      clearerr(in);
    } else {
      if(!feof(in)) putc(ch, out);
      if(ferror(out)) {
        printf("Write Error");
        clearerr(out);
      }
    }
  }
  fclose(in);
  fclose(out);
  return 0;
}

listing 6
#include <stdio.h>
#include <fcntl.h>
#include <sys\stat.h>
#include <io.h>
#include <stdlib.h>

int main(int argc, char *argv[])
{
  int fd;

  if((fd=open(argv[1], O_RDONLY))==-1) {
    printf("Cannot open file.");
    exit(1);
  }

  printf("File is existent.\n");

  if(close(fd))
    printf("Error in closing file.\n");
  return 0;
}

listing 7
#include <stdio.h>
#include <sys\stat.h>
#include <io.h>
#include <stdlib.h>

int main(void)
{
  int fd;

  if((fd=creat("test", S_IWRITE))==-1) {
    printf("Cannot open file.\n");
    exit(1);
  }
 .
 .
 .

listing 8
FILE *fp, *fp2;
 .
 .
 .
fp2 = dup(fp);

listing 9
#include <stdio.h>
#include <io.h>
#include <fcntl.h>
#include <stdlib.h>

int main(int argc, char *argv[])
{
  int fd;
  char ch;

  if((fd=open(argv[1], O_RDWR))==-1) {
    printf("Cannot open file.\n");
    exit(1);
  }

  while(!eof(fd)) {
    read(fd, &ch, 1);  /* read one char at a time */
    printf("%c", ch);
  }

  close(fd);
  return 0;
}

listing 10
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
  FILE *fp;

  if((fp=fopen("test", "rb"))==NULL) {
    printf("Cannot open file.\n");
    exit(1);
  }
 .
 .
 .
  if(fclose(fp))
    printf("File close error.\n");
  return 0;
}

listing 11
/*
  Assume that fp has been opened as a binary file
  for read operations.
*/
while(!feof(fp)) getc(fp);

listing 12
/*
  Assume that fp points to a stream opened for write
  operations.
*/

while(!done) {
  putc(info,fp);
  if(ferror(fp)) {
    printf("File Error\n");
    exit(1);
  }
 .
 .
 .
}

listing 13
/*
  Assume that fp is associated with an output file.
*/
 .
 .
 .
fwrite(buf, sizeof(data_type), 1, fp);
fflush(fp);
 .
 .
 .

listing 14
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char *argv[])
{
  FILE *fp;
  char ch;

  if((fp=fopen(argv[1], "r"))==NULL) {
    printf("Cannot open file.\n");
    exit(1);
  }

  while((ch=fgetc(fp))!=EOF) {
    printf("%c", ch);
  }
  fclose(fp);
  return 0;
}

listing 15
#include <stdio.h>
#include <stdlib.h>
int main(int argc, char *argv[])
{
  FILE *fp;
  long l;
  int  i;
  fpos_t *pos;  /* fpos_t is defined in stdio.h */
  pos = &l;

  if((fp=fopen(argv[1], "w+"))==NULL) {
    printf("Cannot open file.\n");
    exit(1);
  }

  for (i=0; i<10; i++)
    fputc('Z', fp);  /* write 10 Z's to the file */
  fgetpos(fp, pos);

  printf("We are now at position %ld in the file.", *pos);
  fclose(fp);
  return 0;
}

listing 16
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char *argv[])
{
  FILE *fp;
  char str[128];

  if((fp=fopen(argv[1], "r"))==NULL) {
    printf("Cannot open file.\n");
    exit(1);
  }

  while(!feof(fp)) {
    if(fgets(str, 126, fp))
      printf("%s", str);
  }
  fclose(fp);
  return 0;
}

listing 17
printf("The file is %ld bytes long.", filelength(fd));

listing 18
FILE *stream;
int fd;

if((stream=fopen("TEST", "r"))==NULL) {
  printf("Cannot open TEST file.");
  exit(1);
}

fd = fileno(stream);

listing 19
/*
  Assume that fp is associated with an output file.
*/
  .
  .
  .
fwrite(buf,sizeof(data_type),1,fp);
flushall();
  .
  .
  .

listing 20
FILE *fp;

if ((fp = fopen("test", "w"))==NULL) {
  printf("Cannot open file.\n");
  exit(1);
}

listing 21
FILE *fp;

if((fp=fopen("test", "rb+"))==NULL) {
  printf("Cannot open file.\n");
  exit(1);
}

listing 22
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
  FILE *fp;

  if((fp=fopen("test", "w"))==NULL) {
    printf("Cannot open file.\n");
    exit(1);
  }

  fprintf(fp, "this is a test %d %f", 10, 20.01);

  fclose(fp);
  return 0;
}

listing 23
void write_string(char *str, FILE *fp)
{
  while(*str) if(!ferror(fp)) fputc(*str++, fp);
}

listing 24
void write_string(char *str)
{
  while(*str) if(!ferror(fp)) fputchar(*str++);
}

listing 25
fputs("this is a test", fp);

listing 26
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
  FILE *fp;
  float bal[10];

  if((fp=fopen("test", "rb"))==NULL) {
    printf("Cannot open file.\n");
    exit(1);
  }

  if(fread(bal, sizeof(float), 10, fp)!=10) {
    if(feof(fp)) printf("Premature end of file.");
    else printf("File read error.");
  }

  fclose(fp);
  return 0;
}

listing 27
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
  FILE *fp;

  printf("This will display on the screen\n");

  if((fp=freopen("OUT", "w", stdout))==NULL) {
    printf("Cannot open file.\n");
    exit(1);
}

  printf("This will be written to the file OUT");
  fclose(fp);
  return 0;
}

listing 28
char str[80];
float f;

fscanf(fp, "%s%f", str, &f);

listing 29
struct addr {
  char name[40];
  char street[40];
  char city[40];
  char state[3];
  char zip[10];
} info;

void find(long client_num)
{
  FILE *fp;

  if((fp=fopen("mail", "rb"))==NULL) {
    printf("Cannot open file.\n");
    exit(1);
  }

  /* find the proper structure */
  fseek(client_num*sizeof(struct addr), 0);

  /* read the data into memory */
  fread(&info, sizeof(struct addr), 1, fp);
  fclose(fp);
}

listing 30
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char *argv[])
{
  FILE *fp;
  long l;
  int  i;
  fpos_t *pos;  /* fpos_t is defined in stdio.h */
  pos = &l;

  if((fp=fopen(argv[1], "w+"))==NULL) {
    printf("Cannot open file.\n");
    exit(1);
  }

  for (i=0; i<10; i++)
    fputc('Y', fp);  /* write 10 Y's to the file */
  fgetpos(fp, pos);

  for (i=0; i<10; i++)
    fputc('Z', fp);  /* write 10 Z's to the file */
  fsetpos(fp, pos);  /* reset to the end of the Y's */

  fputc('A', fp);     /* replace first Z with an A. */
  fclose(fp);
  return 0;
}

listing 31
fp=_fsopen("TEST.DAT", "wb", SH_DENYRD);

listing 32
#include <stdio.h>
#include <sys\stat.h>
#include <stdlib.h>

int main(void)
{
  FILE *fp;
  struct stat buff;

  if((fp=fopen("test", "rb"))==NULL) {
    printf("Cannot open file.\n");
    exit(1);
  }

  /* fill the stat structure */
  fstat(fileno(fp), &buff);

  printf("Size of the file is: %ld\n", buff.st_size);
  fclose(fp);
  return 0;
}

listing 33
long i;
if((i=ftell(fp))==-1L) printf("A file error has occurred.\n");

listing 34
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
  FILE *fp;
  float f=12.23;

  if((fp=fopen("test", "wb"))==NULL) {
    printf("Cannot open file.\n");
    exit(1);
  }

  fwrite(&f, sizeof(float), 1, fp);

  fclose(fp);
  return 0;
}

listing 35
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char *argv[])
{
  FILE *fp;
  char ch;

  if((fp=fopen(argv[1], "r"))==NULL) {
    printf("Cannot open file.\n");
    exit(1);
  }

  while((ch=getc(fp))!=EOF)
    printf("%c", ch);

  fclose(fp);
  return 0;
}

listing 36
do {
  printf("1: Check spelling\n");
  printf("2: Correct spelling\n");
  printf("3: Look up a word in the dictionary\n");
  printf("4: Quit\n");

  printf("\nEnter your selection: ");
  choice = getch();
} while(!strchr("1234", choice));

listing 37
#include <stdio.h>

int main(void)
{
  char s[256], *p;

  p = s;

  while((*p++=getchar())!='\n') ;
  *p = '\0';  /* add null terminator */
  printf(s);
  return 0;
}

listing 38
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
  FILE *fp;
  char fname[128];

  printf("Enter filename: ");
  gets(fname);

  if((fp=fopen(fname, "r"))==NULL) {
    printf("Cannot open file.\n");
    exit(1);
  }

 .
 .
 .
  fclose(fp);
  return 0;
}

listing 39
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
  FILE *fp;
  int sum = 0;

  if((fp=fopen("inttest", "rb"))==NULL) {
    printf("Cannot open file.\n");
    exit(1);
  }

  while(!feof(fp))
    sum = getw(fp)+sum;

  printf("The sum is %d", sum);
  fclose(fp);
  return 0;
}

listing 40
if(isatty(fd)) printf("is a character device");
else printf("is not a character device");

listing 41
lock(fd, 0, 128);

listing 42
if(locking(fd, LK_UNLOCK, 10)) {
  // process error
}

listing 43
#include <stdio.h>
#include <fcntl.h>
#include <sys\stat.h>
#include <io.h>
#include <stdlib.h>

#define BUF_SIZE  128

/* read buffers using lseek() */
int main(int argc, char *argv[])
{
  char buf[BUF_SIZE+1], s[10];
  int fd, sector;

  buf[BUF_SIZE+1] = '\0'; /* null terminate buffer for printf */
  if((fd=open(argv[1], O_RDONLY | O_BINARY))==-1) { /* open for write */
    printf("Cannot open file.\n");
    exit(0);
  }
  do {
    printf("Buffer: ");
    gets(s);

    sector = atoi(s); /* get the sector to read */

    if(lseek(fd, (long)sector*BUF_SIZE,0)==-1L)
      printf("Seek Error\n");

    if(read(fd, buf, BUF_SIZE)==0) {
      printf("Read Error\n");
    }
    else {
      printf("%s\n", buf);
    }
  } while(sector > 0);
  close(fd);
  return 0;
}

listing 44
if((fd=open(filename, mode)) == -1)  {
  printf("Cannot open file.\n");
  exit(1);
}

listing 45
#include <stdio.h>
#include <math.h>
#include <errno.h> /* contains declaration for errno */

int main(void)
{
  /* this will generate a domain error */
  asin(10.0);
  if(errno==EDOM)
    perror("Program Error Test");
  return 0;
}

listing 46
printf("Hi %c %d %s", 'c', 10, "there!");

listing 47
int i;

printf("this is a test %n", &i);
printf("%d", i);

listing 48
#include <stdio.h>

int main(void)
{
  /* This prints "this is a test" left-justified
     in a 20-character field.
  */
  printf("%-20s", "this is a test");

  /* This prints a float with 3 decimal places in a
     10-character field. The output will be "    12.235".
  */
  printf("%10.3f", 12.234657);
  return 0;
}

listing 49
for(; *str; str++) putc(*str, fp);

listing 50
putch('X');

listing 51
for(; *str; str++) putchar(*str);

listing 52
#include <stdio.h>
#include <string.h>

int main(void)
{
  char str[80];

  strcpy(str, "this is an example");
  puts(str);
  return 0;
}

listing 53
putw(100, fp);

listing 54
#include <stdio.h>
#include <io.h>
#include <fcntl.h>
#include <stdlib.h>

int main(void)
{
  int fd;
  char buffer[100];

  if((fd=open("TEST.TST", O_RDONLY))==-1) {
    printf("Cannot open file.\n");
    exit(1);
  }

  if(read(fd, buffer, 100)!=100)
    printf("Possible read error.");
  return 0;
}

listing 55
#include <stdio.h>

int main(int argc, char *argv[])
{
  if(remove(argv[1])==-1)
    printf("Remove Error");
  return 0;
}

listing 56
#include <stdio.h>

int main(int argc, char *argv[])
{
  if(rename(argv[1], argv[2])!=0)
    printf("Rename Error");
  return 0;
}

listing 57
void re_read(FILE *fp)
{
  /* read once */
  while(!feof(fp)) putchar(getc(fp));

  rewind(fp);

  /* read twice */
  while(!feof(fp)) putchar(getc(fp));
}

listing 58
scanf("%d", &count);

listing 59
scanf("%s", address);

listing 60
scanf("%d%d", &r, &c);

listing 61
scanf("%d%*c%d", &x, &y);

listing 62
scanf("%20s", address);

listing 63
scanf("%c%c%c", &a, &b, &c);

listing 64
scanf("%st%s", &x, &y);

listing 65
%[ABC]

listing 66
%[A-Z]

listing 67
char str[80];
int i;

/* read a string and an integer */
scanf("%s%d", str, &i);

/* read up to 79 chars into str */
scanf("%79s", str);

/* skip the integer between the two strings */
scanf("%s%*d%s", str, &i, str);

listing 68
char buffer[BUFSIZ];
  .
  .
  .
setbuf(fp,buffer);

listing 69
setmode(fd, O_TEXT)

listing 70
#include <stdio.h>
char buffer[128];
 .
 .
 .
setvbuf(fp, buffer, _IOLBF, 128);

listing 71
if((fd=sopen(filename, access, shflag, mode)) ==-1)  {
  printf("Cannot open file.\n");
  exit(1);
}

listing 72
char str[80];
sprintf(str, "%s %d %c", "one", 2, '3');

listing 73
#include <stdio.h>

int main(void)
{
  char str[80];
  int i;

  sscanf("hello 1 2 3 4 5", "%s%d", str, &i);
  printf("%s %d", str, i);
  return 0;
}

listing 74
#include <stdio.h>
#include <sys\stat.h>
#include <stdlib.h>

int main(void)
{
  FILE *fp;
  struct stat buff;

  if((fp=fopen("test", "rb"))==NULL) {
    printf("Cannot open file.\n");
    exit(1);
  }

  /* fill the stat structure */
  stat("test", &buff);

  printf("Size of the file is: %ld\n", buff.st_size);
  fclose(fp);
  return 0;
}

listing 75
long pos;
  .
  .
  .
pos = tell(fd);
printf("Position indicator is %ld bytes from the start", pos);

listing 76
FILE *temp;

if(!(temp=tmpfile())) {
  printf("Cannot open temporary work file.\n");
  exit(1);
}

listing 77
#include <stdio.h>

int main(void)
{
  char name[40];
  int i;
  for(i=0; i<3; i++) {
    tmpnam(name);
    printf("%s ", name);
  }
  return 0;
}

listing 78
void read_word(FILE *fp, char *token)
{

  while(isalpha(*token=getc(fp))) token++;

  ungetc(fp, *token);
}

listing 79
#include <stdio.h>
#include <conio.h>

int main()
{
  char ch;

  ch = getch(); // get keypress
  putch(ch); // show the key
  ungetch(ch);  // return to buffer
  ch = getch(); // get same key again
  putch(ch); // show the key again

  return 0;
}

listing 80
#include <stdio.h>
#include <dos.h>

int main(int argc, char *argv[])
{
  if(unlink(argv[1])==-1)
    printf("Cannot remove file.");
  return 0;
}

listing 81
unlock(fd, 0, 128);

listing 82
#include <stdio.h>
#include <stdarg.h>

void print_message(char *, ...);

int main(void)
{
  print_message("Cannot open file %s","test");
  return 0;
}

void print_message( char *format, ...)
{
  va_list ptr; /* get an arg ptr */

  /* initialize ptr to point to the first argument after the
     format string
  */
  va_start(ptr, format);
  /* print out message */
  vprintf(format, ptr);
  va_end(ptr);
}

listing 83
#include <stdio.h>
#include <stdarg.h>

void read_int(int num, ...);

int main(void)
{
  int a, b;
  read_int(2, &a, &b);
  printf("%d %d", a, b);

  return 0;
}

void read_int(int num, ...)
{
  va_list ptr; /* get an arg ptr */

  /* initialize ptr to point to the first argument after the
     format string
  */
  va_start(ptr, num);

  printf("Enter %d integers: ", num);
  /* read ints */
  vscanf("%d %d", ptr);

  va_end(ptr);
}


listing 84
#include <stdio.h>
#include <io.h>
#include <fcntl.h>
#include <stdlib.h>

int main(void)
{
  int fd;
  char buffer[100];

  if((fd=open("test", O_WRONLY))==-1) {
    printf("Cannot open file.\n");
    exit(1);
  }

  gets(buffer);

  if(write(fd, buffer, 100)!=100)
    printf("Write Error");
  close(fd);

  return 0;
}

listing 1
#include <ctype.h>
#include <stdio.h>

int main(void)
{
  char ch;

  for(;;) {
    ch = getchar();
    if(ch==' ') break;
    if(isalnum(ch)) printf("%c is alphanumeric\n", ch);
  }
  return 0;
}

listing 2
#include <ctype.h>
#include <stdio.h>

int main(void)
{
  char ch;

  for(;;) {
    ch = getchar();
    if(ch==' ') break;
    if(isalpha(ch)) printf("%c is a letter\n", ch);
  }
  return 0;
}

listing 3
#include <ctype.h>
#include <stdio.h>

int main(void)
{
  char ch;

  for(;;) {
    ch = getchar();
    if(ch==' ') break;
    if(isascii(ch)) printf("%c is ASCII defined\n", ch);
  }
  return 0;
}

listing 4
#include <ctype.h>
#include <stdio.h>

int main(void)
{
  char ch;

  for(;;) {
    ch = getchar();
    if(ch==' ') break;
    if(iscntrl(ch)) printf("%c is a control character\n", ch);
  }
  return 0;
}

listing 5
#include <ctype.h>
#include <stdio.h>

int main(void)
{
  char ch;

  for(;;) {
    ch = getchar();
    if(ch==' ') break;
    if(isdigit(ch)) printf("%c is a digit\n", ch);
  }
  return 0;
}

listing 6
#include <ctype.h>
#include <stdio.h>

int main(void)
{
  char ch;

  for(;;) {
    ch = getchar();
    if(ch==' ') break;
    if(isgraph(ch)) printf("%c is a printing character\n", ch);
  }
  return 0;
}

listing 7
#include <ctype.h>
#include <stdio.h>

int main(void)
{
  char ch;

  for(;;) {
    ch = getchar();
    if(ch==' ') break;
    if(islower(ch)) printf("%c is lowercase\n", ch);
  }
  return 0;
}

listing 8
#include <ctype.h>
#include <stdio.h>

int main(void)
{
  char ch;

  for(;;) {
    ch = getchar();
    if(ch==' ') break;
    if(isprint(ch)) printf("%c is printable\n", ch);
  }
  return 0;
}

listing 9
#include <ctype.h>
#include <stdio.h>

int main(void)
{
  char ch;

  for(;;) {
    ch = getchar();
    if(ch==' ') break;
    if(ispunct(ch)) printf("%c is punctuation\n", ch);
  }
  return 0;
}

listing 10
#include <ctype.h>
#include <stdio.h>

int main(void)
{
  char ch;

  for(;;) {
    ch = getchar();
    if(ch=='.') break;
    if(isspace(ch)) printf("%c is white-space\n", ch);
  }
  return 0;
}

listing 11
#include <ctype.h>
#include <stdio.h>

int main(void)
{
  char ch;

  for(;;) {
    ch = getchar();
    if(ch==' ') break;
    if(isupper(ch)) printf("%c is upper-case\n", ch);
  }
  return 0;
}

listing 12
#include <ctype.h>
#include <stdio.h>

int main(void)
{
  char ch;

  for(;;) {
    ch = getchar();
    if(ch==' ') break;
    if(isxdigit(ch)) printf("%c is hexadecimal \n", ch);
  }
  return 0;
}

listing 13
char str[20], out[20];

strcpy(str, "hello there");

memccpy(out, str,' ', 20);

listing 14
#include <stdio.h>
#include <string.h>

int main(void)
{
  void *p;

  p = memchr("this is a test", ' ', 14);
  printf((char *) p);
  return 0;
}

listing 15
#include <stdio.h>
#include <string.h>

int main(int argc, char *argv[])

{
  int outcome;
  size_t len, l1, l2;

  /* find the length of shortest */
  len = (l1=strlen(argv[1]))<(l2=strlen(argv[2])) ? l1:l2;

  outcome = memcmp(argv[1], argv[2], len);
  if(!outcome) printf("equal");
  else if(outcome<0) printf("First less than second.\n");
  else printf("First greater than second\n");
  return 0;
}

listing 16
#include <stdio.h>
#include <string.h>
#define SIZE 80

int main(void)
{
  char buf1[SIZE], buf2[SIZE];

  strcpy(buf1, "When, in the course of...");
  memcpy(buf2, buf1, SIZE);
  printf(buf2);
  return 0;
}

listing 17
#include <stdio.h>
#include <string.h>

int main(void)
{
  char str1[40], str2[40];

  strcpy(str1, "Born to code in C/C++.");
  memmove(str2, str1, strlen(str1));
  printf(str2);
  return 0;
}

listing 18
memset(buf, '\0', 100);
memset(buf, 'X', 10);
printf((char *) buf);

listing 19
#include <stdio.h>
#include <string.h>
#include <dos.h>

int main(void)
{
  char buff[25];

  movedata(_DS, 0, FP_SEG(buff), FP_OFF(buff), 25);
  return 0;
}

listing 20
char str[8];
stpcpy(str, "hello");

listing 21
#include <stdio.h>
#include <string.h>

int main(void)
{
  char s1[80], s2[80];

  gets(s1);
  gets(s2);

  strcat(s2, s1);
  printf(s2);
  return 0;
}

listing 22
#include <stdio.h>
#include <string.h>

int main(void)
{
  char *p;

  p = strchr("this is a test", ' ');
  printf(p);
  return 0;
}

listing 23
password()
{
  char s[80];

  printf("Enter password: ");
  gets(s);

  if(strcmp(s, "pass")) {
    printf("Invalid password.\n");
    return 0;
  }
  return 1;
}

listing 24
char str[80];
strcpy(str, "hello");

listing 25
#include <stdio.h>
#include <string.h>

int main(void)
{
  int len;

  len = strcspn("this is a test", "ab");
  printf("%d", len);
  return 0;
}

listing 26
char str[80], *p;

strcpy(str, "this is a test");

p = strdup(str);

listing 27
void swap()
{
  /* ... */
  if(error) printf(_strerror("Error in swap."));

listing 28
if(errno) printf(strerror(errno));

listing 29
#include <stdio.h>
#include <string.h>

int main(int argc, char *argv[])
{
  if(!stricmp(argv[1], argv[2]))
    printf("The filenames are the same.\n");
  else
    printf("The filenames differ.\n");

  return 0;
}

listing 30
strcpy(s, "hello");
printf("%d", strlen(s));

listing 31
#include <stdio.h>
#include <string.h>

int main(void)
{
  char s[80];

  strcpy(s, "THIS IS A TEST");

  strlwr(s);

  printf(s);

  return 0;
}

listing 32
#include <stdio.h>
#include <string.h>

int main(void)
{
  char s1[80], s2[80];
  size_t len;

  gets(s1);
  gets(s2);

  /* compute how many chars will actually fit */
  len = 79-strlen(s2);

  strncat(s2, s1, len);
  printf(s2);
  return 0;
}

listing 33
#include <stdio.h>
#include <string.h>

int main(int argc, char *argv[])
{
  if(!strnicmp(argv[1], argv[2], 8))
    printf("The filenames are the same.\n");
  else
    printf("The filenames differ.\n");
  return 0;
}

listing 34
char str1[128], str2[80];
gets(str1);
strncpy(str2, str1, 79);

listing 35
strnset(str, 'x', 10);

listing 36
#include <stdio.h>
#include <string.h>

int main(void)
{
  char *p;

  p = strpbrk("this is a test", " absj");
  printf(p);
  return 0;
}

listing 37
#include <stdio.h>
#include <string.h>

int main(void)
{
  char *p;

  p = strrchr("this is a test", 'i');
  printf(p);
  return 0;
}

listing 38
#include <stdio.h>
#include <string.h>

char s[] = "hello";

main(void)
{
  strrev(s);

  printf(s);

  return 0;
}

listing 39
strset(str, 'x');

listing 40
#include <stdio.h>
#include <string.h>

int main(void)
{
  int len;

  len = strspn("this is a test", "siht ");
  printf("%d",len);
  return 0;
}

listing 41
#include <stdio.h>
#include <string.h>

int main(void)
{
  char *p;

  p = strstr("this is a test", "is");
  printf(p);
  return 0;
}

listing 42
#include <stdio.h>
#include <string.h>

int main(void)
{
  char *p;

  p = strtok("The summer soldier, the sunshine patriot"," ");
  printf(p);
  do {
    p=strtok('\0', ", ");
    if(p) printf("|%s", p);
  } while(p);
  return 0;
}

listing 43
#include <stdio.h>
#include <string.h>

int main(void)
{
  char s[80];

  strcpy(s, "this is a test");

  strupr(s);

  printf(s);

  return 0;
}

listing 44
putchar(tolower('Q'));

listing 45
putchar(toupper('a'));

listing 1
#include <stdio.h>
#include <math.h>

int main(void)
{
  double val = -1.0;

  do {
    printf("arc cosine of %f is %f\n", val, acos(val));
    val += 0.1;
  } while(val <= 1.0);
  return 0;
}

listing 2
#include <stdio.h>
#include <math.h>

int main(void)
{
  double val = -1.0;

  do {
    printf("arc sine of %f is %f\n", val, asin(val));
    val += 0.1;
  } while(val <= 1.0);
  return 0;
}

listing 3
#include <stdio.h>
#include <math.h>

int main(void)
{
  double val = -1.0;

  do {
    printf("arc tangent of %f is %f\n", val, atan(val));
    val += 0.1;
  } while(val <= 1.0);
  return 0;
}

listing 4
#include <stdio.h>
#include <math.h>

int main(void)
{
  double y = -1.0;

  do {
    printf("atan2 of %f is %f\n", y, atan2(y, 1.0));
    y += 0.1;
  } while(y <= 1.0);
  return 0;
}

listing 5
#include <stdio.h>
#include <math.h>

int main(void)
{
  struct complex z;

  z.x = 1;
  z.y = 2;

  printf("%f", cabs(z));
  return 0;
}

listing 6
printf("%f", ceil(9.9));

listing 7
#include <stdio.h>
#include <math.h>

int main(void)
{
  double val = -1.0;

  do {
    printf("cosine of %f is %f\n", val, cos(val));
    val += 0.1;
  } while(val <= 1.0);
  return 0;
}

listing 8
#include <stdio.h>
#include <math.h>

int main(void)
{
  double val = -1.0;

  do {
    printf("hyperbolic cosine of %f is %f\n", val, cosh(val));
    val += 0.1;
  } while(val <= 1.0);
  return 0;
}

listing 9
printf("Value of e to the first: %f", exp(1.0));

listing 10
#include <stdio.h>
#include <math.h>

int main(void)
{
  printf("%1.1f %1.1f", fabs(1.0), fabs(-1.0));
  return 0;
}

listing 11
printf("%f", floor(10.9));

listing 12
#include <stdio.h>
#include <math.h>

int main(void)
{
  printf("%1.1f", fmod(10.0, 3.0));
  return 0;
}

listing 13
int e;
double f;

f = frexp(10.0, &e);
printf("%f %d", f, e);

listing 14
printf("%f", hypot(2, 1));

listing 15
#include <stdio.h>
#include <math.h>

int main(void)
{
  printf("%f", ldexp(1, 2));
  return 0;
}

listing 16
#include <stdio.h>
#include <math.h>

int main(void)
{
  double val = 1.0;

  do {
    printf("%f %f\n", val, log(val));
    val++;
  } while (val < 11.0);
  return 0;
}

listing 17
#include <stdio.h>
#include <math.h>

int main(void)
{
  double val = 1.0;

  do {
    printf("%f %f\n", val, log10(val));
    val++;
  } while (val < 11.0);
  return 0;
}

listing 18
struct exception {
  int type;
  char *name;
  double arg1, arg2;
  double retval;
};

listing 19
double i;
double f;

f = modf(10.123, &i);
printf("%f %f", i, f);

listing 20
#include <stdio.h>
#include <math.h>

int main(void)
{
  double c[2];

  c[1] = 2;
  c[0] = 45;

  printf("%f", poly(1, 2, c));
  return 0;
}

listing 21
#include <stdio.h>
#include <math.h>

int main(void)
{
  double x=12.0, y=0.0;

  do {
    printf("%f\n", pow(x, y));
    y++;
  } while(y<11);
  return 0;
}

listing 22
#include <stdio.h>
#include <math.h>

int main(void)
{
  int x=0;

  while(x < 11)
    printf("%f\n", pow10(x++));
  return 0;
}

listing 23
#include <stdio.h>
#include <math.h>

int main(void)
{
  double val = -1.0;

  do {
    printf("sine of %f is %f\n", val, sin(val));
    val += 0.1;
  } while(val <= 1.0);
  return 0;
}

listing 25
printf("%f", sqrt(16.0));

listing 26
#include <stdio.h>
#include <math.h>

int main(void)
{
  double val = -1.0;

  do {
    printf("tangent of %f is %f\n", val, tan(val));
    val += 0.1;
  } while(val <= 1.0);
  return 0;
}

listing 27
#include <stdio.h>
#include <math.h>

int main(void)
{
  double val = -1.0;

  do {
    printf("Hyperbolic tangent of %f is %f\n", val, tanh(val));
    val += 0.1;
  } while(val <= 1.0);
  return 0;
}

listing 1
#include <stdio.h>
#include <dos.h>
#include <stdlib.h>

int main(void)
{
  char buf[2048];
  int sector, i;

  for(;;) {
    printf("\nEnter sector: ");
    scanf("%d", &sector);
    if(sector==-1) return 0;
    absread(2, 1, sector, buf); /* read drive c */
    for(i=0; i<512; i++) {
      printf("%c ", buf[i]);
      if(!(i%16)) {
        printf("\n");
      }
    }
  }
}

listing 2
#include <stdio.h>
#include <time.h>

int main(void)
{
  struct tm *ptr;
  time_t lt;
  
  lt = time(NULL);
  ptr = localtime(&lt);
  printf(asctime(ptr));
  return 0;
}

listing 3
/* Do raw keyboard reads. */
#include <dos.h>

int main(void)
{
  char ch;

  while((ch=bdos(1, 0, 0))!='q') ;
  /* ... */
  return 0;
}

listing 4
bioscom(0, 251, 0);

listing 5
#include <stdio.h>
#include <bios.h>

int main(void)
{
  unsigned eq;

  eq = biosequip();
 
  eq >>= 6; /* shift bits 6 and 7 into lowest position */

  printf("number of disk drives: %d", (eq & 3) + 1);

  return 0;
}

listing 6
while(!bioskey(1)) rand();

listing 7
#include <stdio.h>
#include <bios.h>

int main(void)
{
  printf("%dK bytes of ram", biosmemory());

  return 0;
}

listing 8
char p[]="hello";

while(*p) biosprint(0, *p++, 0);

listing 9
#include <stdio.h>
#include <bios.h>

int main(void)
{
  printf("The current timer value is %ld", biostime(0,0));
  return 0;
}

listing 10
_bios_timeofday(_TIME_SETCLOCK, 0L);

listing 11
#include <stdio.h>
#include <time.h>

int main(void)
{
  clock_t start, stop;
  unsigned long t;
  
  start = clock();
  for(t=0; t<500000L; t++);
  stop = clock();
  printf("Loop required %f seconds",
         (stop - start) / CLK_TCK);

  return 0;
}

listing 12
#include <stdio.h>
#include <dos.h>

int main(void)
{
  struct COUNTRY c;

  country(0, &c);

  printf(c.co_curr);

  return 0;
}

listing 13
asctime(localtime(time))

listing 14
#include <stdio.h>
#include <time.h>
#include <stddef.h>

int main(void)
{
  time_t lt;
  
  lt = time(NULL);
  printf(ctime(&lt));
  return 0;
}

listing 15
#include <stdio.h>
#include <dos.h>

int break_handler(void);

int main(void)
{
  register int i;

  ctrlbrk(break_handler);

  for(i=0; i<32000; i++)  printf("%d ", i);

  return 0;
}

break_handler(void)
{
  printf("This is the new break handler.");
  return 0;
}

listing 16
#include <stdio.h>
#include <dos.h>

int main(void)
{
  printf("beep beep ");
  
  sound(500);
  delay(600);
  nosound();
  delay(300);
  sound(500);
  delay(600);
  nosound();

  return 0;
}

listing 17
#include <stdio.h>
#include <time.h>
#include <stddef.h>

int main(void)
{
  time_t start,end;
  long unsigned int t;
  
  start = time(NULL);
  for(t=0; t<500000L; t++) ;
  end = time(NULL);
  printf("Loop required %f seconds", difftime(end, start));

  return 0;
}

listing 18
_dos_close(fd);

listing 19
int fd;

if(_dos_creat("test.tst", _A_NORMAL, &fd))
  printf("Cannot open file.\n");

listing 20
#include <stdio.h>
#include <dos.h>

int main(void)
{
  struct dosdate_t d;
  struct dostime_t t;

  _dos_getdate(&d);
  _dos_gettime(&t);

  printf("Time and date: %d:%d:%d, %d/%d/%d",
         t.hour, t.minute, t.second, d.month, d.day,
         d.year);

  return 0;
}

listing 21
#include <dos.h>
#include <stdio.h>

int main(void)
{
  struct diskfree_t p;

  _dos_getdiskfree(3, &p); /* drive C */

  printf("Number of free clusters is %d.",
          p.avail_clusters);

  return 0;
}

listing 22
unsigned d;

_dos_getdrive(&d);
printf("drive is %c", d-1+'A');

listing 23
unsigned attr;

if(_dos_getfileattr("test.tst", &attr))
  printf("file error");

if(attr & _A_NORMAL) printf("File is normal.\n");

listing 24
#include <io.h>
#include <dos.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
  struct {
    unsigned day: 5;
    unsigned month: 4;
    unsigned year: 7;
  } d;

  unsigned t;
  int fd;

  if(_dos_open("TEST.TST", O_RDONLY, &fd)) {
    printf("Cannot open file.\n");
    exit(1);
  }

  _dos_getftime(fd, (unsigned *) &d, &t);

  printf("Date of creation: %u", d.year+1980);  

  return 0;
}

listing 25
void interrupt (*p)();

p = _dos_getvect(5);

listing 26
int fd;

if(_dos_open("test.tst", O_RDWR, &fd))
   printf("Error opening file.");

listing 27
int fd;
unsigned count
char *buf[128];
.
.
.
if(_dos_read(fd, buf, 128, &count))
  printf("Error reading file.\n");

listing 28
struct dostime_t t;

t.hour = 10;
t.minute  = 10;
t.second  = 10;
t.hsecond = 0;

_dos_settime(&t);


listing 29
unsigned num;

_dos_setdrive(2, &num);

listing 30
unsigned attr;

attr = _A_RDONLY;

if(_dos_setfileattr("test.tst", attr))
  printf("File Error");

listing 31
#include <stdio.h>
#include <io.h>
#include <dos.h>
#include <fcntl.h>
#include <stdlib.h>

int main(void)
{
  struct dt {
    unsigned day: 5;
    unsigned month: 4;
    unsigned year: 7;
  } ;

  union {
    struct dt date_time;
    unsigned u;
  } d;

  unsigned t;
  int fd;

  if(_dos_open("TEST.TST", O_RDONLY, &fd)) {
    printf("Cannot open file.\n");
    exit(1);
  }

  _dos_getftime(fd, &d.u, &t);
  d.date_time.year = 20;
  
  _dos_setftime(fd, d.u, t);

  return 0;
}

listing 32
int fd;
unsigned count
char *buf[128];
.
.
.
if(_dos_write(fd, buf, 128, &count))
  printf("Error writing file.");

listing 33
#include <stdio.h>
#include <dos.h>
#include <stdlib.h>

int main(void)
{
  char far *ptr;

  ptr = (char far *) malloc(100);

  printf("segment:offset of ptr: %u %u", FP_SEG(ptr),
         FP_OFF(ptr));

  return 0;
}

listing 34
#include <stdio.h>
#include <sys\timeb.h>

int main(void)
{
  struct timeb lt;
  
  ftime(&lt);
  printf("%ld seconds %d milliseconds.",lt.time,lt.millitm);
  return 0;
}

listing 35
#include <dos.h>

int main(void)
{
  geninterrupt(5); /* print screen function */
  return 0;
}

listing 36
printf("The current cbrk setting is %d", getcbrk());

listing 37
#include <stdio.h>
#include <time.h>
#include <dos.h>

int main(void)
{
  time_t t;
  struct time dos_time;
  struct date dos_date;
  struct tm *local;

  getdate(&dos_date);
  gettime(&dos_time);

  t = dostounix(&dos_date, &dos_time);
  local = localtime(&t);
  printf("time and date: %s", asctime(local));

  return 0;
}

listing 38
#include <stdio.h>
#include <dos.h>

int main(void)
{
  struct dfree p;

  getdfree(3, &p); /* drive C */

  printf("Number of free clusters is %d.", p.df_avail);

  return 0;
}

listing 39
char far *ptr;

ptr = getdta();

listing 40
#include <stdio.h>
#include <dos.h>

int main(void)
{
  long total;
  struct fatinfo p;

  getfat(0, &p);

  total = (long) p.fi_sclus * (long) p.fi_nclus *
          (long) p.fi_bysec;

  printf("Total storage capacity: %ld.", total);

  return 0;
}

listing 41
#include <stdio.h>
#include <io.h>
#include <dos.h>
#include <fcntl.h>
#include <stdlib.h>

int main(void)
{
  struct ftime p;
  int fd;

  if((fd=open("TEST.TST", O_RDONLY))==-1) {
    printf("Cannot open file.\n");
   exit(1);
  }

  getftime(fd, &p);

  printf("%d", p.ft_year + 1980);
  
  return 0;
}

listing 42
void interrupt (*p)(void);

p = getvect(5);

listing 43
#include <stdio.h>
#include <dos.h>

int main(void)
{
  printf("The verify flag is set to %d.", getverify());

  return 0;
}

listing 44
#include <stdio.h>
#include <time.h>
#include <stddef.h>

/* print local and GM time */
int main(void)
{
  struct tm *local, *gm;
  time_t t;
  
  t = time(NULL);
  local = localtime(&t);
  printf("Local time and date: %s", asctime(local));
  gm = gmtime(&t);
  printf("Greenwich mean time and date: %s", asctime(gm));

  return 0;
}

listing 45
unsigned int i;

i = inport(1);

listing 46
#include <dos.h>

/* Set the video mode */
void set_mode(char mode)
{
  union REGS in, out;

  in.h.al = mode;
  in.h.ah = 0;  /* set mode function number */

  int86(0x10, &in, &out);
}

listing 47
#include <stdio.h>
#include <dos.h>

int main(void)
{
  union REGS in, out;

  in.h.ah = 0x2c;  /* get time function number */
  intdos(&in, &out);
  printf("time is %.2d:%.2d:%.2d", out.h.ch, out.h.cl, out.h.dh);

  return 0;
}

listing 48
/* Print the screen. */
#include <dos.h>

int main(void)
{
  struct REGPACK r;

  intr(5, &r);

  return 0;
}

listing 49
while(!kbhit());  /* wait for keypress */

listing 50
#include <stdio.h>
#include <time.h>
#include <stddef.h>

/* Print local and Greenwich mean time. */
int main(void)
{
  struct tm *local, *gm;
  time_t t;
  
  t = time(NULL);
  local = localtime(&t);
  printf("Local time and date: %s", asctime(local));
  gm = gmtime(&t);
  printf("Greenwich mean time and date: %s", asctime(gm));

  return 0;
}

listing 51
#include <stdio.h>
#include <time.h>

int main(void)
{
  struct tm t;
  
  t.tm_year = 90;  /* year 1990   */
  t.tm_mon  =  1;  /* month - 1 */
  t.tm_mday =  7;
  mktime(&t);
  printf("The day of the week is %d", t.tm_wday);

  return 0;
}

listing 52
void far *p;

p = MK_FP(16, 101);

listing 53
outport(0x10, 0xFF);

listing 54
#include <stdio.h>
#include <dos.h>

int main(void)
{
  printf("%d", peekb(0, 0x0100));
  return 0;
}

listing 55
#include <stdio.h>
#include <dos.h>

int main(void)
{
  if (getcbrk() == 0)
     setcbrk(1);
  else
     setcbrk(0);

  printf("BREAK is %s", (getcbrk()) ? "on" : "off");
  return 0;
}

listing 56
struct time t;

t.ti_hour = 10;
t.ti_min  = 10;
t.ti_sec  = 10;
t.ti_hund = 0;

settime(&t);

listing 57
char far *p;

p = MK_FP(0xA000, 0)
setdta(p);

listing 58
setftime(fd, &t);

listing 59
#include <stdio.h>
#include <dos.h>

int main(void)
{
  printf("Turning the verify flag on.");
  setverify(1);

  return 0;
}

listing 60
#include <stdio.h>
#include <dos.h>

int main(void)
{
  printf("hello");

  sleep(10);

  printf(" there");

  return 0;
}

listing 61
#include <stdio.h>
#include <time.h>

int main(void)
{
  time_t t;

  t = 0;
  stime(&t);
  return 0;
}

listing 62
#include <stdio.h>
#include <time.h>

int main(void)
{
  char str[9];

  _strtime(str);
  printf("Time: %s", str);

  _strdate(str);
  printf(", Date: %s", str);

  return 0;
}

listing 63
strftime(str, 100, "It is now %H %p", ltime)
printf(str);

listing 64
#include <stdio.h>
#include <time.h>

int main(void)
{
  struct tm *ptr;
  time_t lt;
  
  lt = time(NULL);
  ptr = localtime(&lt);
  printf(asctime(ptr));

  return 0;
}

listing 65
struct time t;
struct date d;

unixtodos(timeandday, &d, &t)

listing 1
int _es *ptr;

listing 2
#include <malloc.h>
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
  int i=10; 
  char *str;

  if(!(str = (char *) alloca(80))) {
    printf("Allocation error.");
    exit(1);
  }
  /* ... */
  return 0;
}

listing 3
unsigned i;
unsigned s;

i = 0;

if((i=allocmem(100, &s)==-1) printf("Allocation successful.");
else
  printf("Allocation failed, only %u paragraphs available.", i);

listing 4
#include <stdlib.h>
#include <stdio.h>

float *get_mem(void)
{
  float *p;

  p = (float *) calloc(100, sizeof(float));
  if(!p) {
    printf("Allocation failure.");
    exit(1);
  }
  return p;
}

listing 5
#include <alloc.h>
#include <stdio.h>

int main(void)
{
  printf("The size of the heap is %u", coreleft());
  return 0;
}

listing 6
unsigned i;
unsigned s;

i = 0;

if(!_dos_allocmem(100, &s)) printf("Allocation successful.");
else 
  printf("Failure - only %u paragraphs available", i);

listing 7
unsigned i;

if(_dos_allocmem(some, &i))
  printf("Allocation error.");
  /* ... */

_dos_freemem(i); /* free memory */

listing 8
unsigned max;
if(_dos_setblock(100, seg, &max)) printf("Resize error.");

listing 9
#include <alloc.h>
#include <stdio.h>

int main(void)
{
  printf("Far heap free memory: %ld", farcoreleft());
  return 0;
}

listing 10
#include <alloc.h>

int main(void)
{
  char far *p;

  p = (char far *) farmalloc(100);

  /* only free it if there was no allocation error */
  if(p) farfree(p);
  return 0;
}

listing 11
#include <stdlib.h>
#include <stdio.h>

int main(void)
{
  char *str[100];
  int i;

  for(i=0; i<100; i++) {
    if((str[i]=(char *)malloc(128))==NULL) {
      printf("Allocation error.");
      exit(0);
    }
    gets(str[i]);
  }

  /* now free the memory */
  for(i=0; i<100; i++) free(str[i]);
  return 0;
}

listing 12
unsigned i;

if(allocmem(some, &i)!=-1)
  printf("Allocation error.");
else
  freemem(i);

listing 13
if(heapcheck() == _HEAPOK)
  printf("Heap is correct.");
else
  printf("Error in heap.");

listing 14
int status;

heapfillfree(1);
status = heapcheckfree(1)

if(status == _HEAPOK)
  printf("Heap is filled correctly.\n");
else
  if(status == _BADVALUE)
    printf("Heap not filled with correct value.\n");

listing 15
#include <stdio.h>
#include <stdlib.h>
#include <alloc.h>

int main(void)
{
  char *ptr;
  int status;

  if((ptr = (char *) malloc(10)) == NULL)
    exit(1);

  status = heapchecknode(ptr);

  if(status == _USEDENTRY)
    printf("Node is being used.\n");
  else
    printf("Error in heap.\n");

  free(ptr);
  return 0;
}

listing 16
int status;

status = heapfillfree(0);
if(status == _HEAPOK)
  printf("Heap is correct.");
else
  printf("Error in heap.");

listing 17
#include <stdio.h>
#include <stdlib.h>
#include <alloc.h>

int main(void)
{
  struct heapinfo hinfo;
  char *p1, *p2;

  if((p1 = (char *) malloc(80)) == NULL)
    exit(1);

  if((p2 = (char *) malloc(20)) == NULL)
    exit(1);

  if(heapcheck() < 0) { /* always check heap before walk */
    printf("Heap corrupt.");
    exit(1);
  }

  hinfo.ptr = NULL;  /* set ptr to null before first call */

  /* examine first block */
  if(heapwalk(&hinfo) == _HEAPOK)
    printf("Size of p1's block is %d\n", hinfo.size);

  /* examine second block */
  if(heapwalk(&hinfo) == _HEAPOK)
    printf("Size of p2's block is %d\n", hinfo.size);

  free(p1);
  free(p2);
  return 0;
}

listing 18
#include <stdlib.h>

struct addr {
  char name[40];
  char street[40];
  char city[40];
  char state[3];
  char zip[10];
 };
  .
  .
  .
struct addr *get_struct(void)
{
  struct addr *p;

  if(!(p=(struct addr *)malloc(sizeof(addr)))) {
    printf("Allocation error.");
    exit(0);
  }
  return p;
}

listing 19
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

int main(void)
{
  char *p;

  p = (char *) malloc(17);
  if(!p) {
    printf("Allocation error.");
    exit(1);
  }

  strcpy(p, "This is 16 chars");

  p = (char *) realloc(p,18);
  if(!p) {
    printf("Allocation error.");
    exit(1);
  }

  strcat(p, ".");

  printf(p);

  free(p);

  return 0;
}

listing 20
if(setblock(seg, 100)!=-1) printf("Resize error.");

listing 1
chdir("C:\\WP\\FORMLET");

listing 2
_chdrive(3); /* switch to drive C */

listing 3
#include <dos.h>
#include <stdio.h>

int main(void)
{
  struct find_t f;
  register int done;

  done = _dos_findfirst("*.c", _A_NORMAL, &f);
  while(!done) {
    printf("%s %ld\n", f.name, f.size);
    done = _dos_findnext(&f);
  }
  return 0;
}

listing 4
#include <stdio.h>
#include <dos.h>
#include <dir.h>

int main(void)
{
  struct ffblk f;
  register int done;

  done = findfirst("*.c", &f, 0);
  while(!done) {
    printf("%s %ld\n", f.ff_name, f.ff_fsize);
    done = findnext(&f);
  }
  return 0;
}

listing 5
#include <stdio.h>
#include <dir.h>

int main(void)
{
  char path[MAXPATH];
  fnmerge(path, "C:", "", "TEST", ".C");
  printf(path);
  return 0;
}

listing 6
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
  char fpath[80];

  _fullpath(fpath, "\\INCLUDE", 80);

  printf("Full path: %s\n", fpath);

  return 0;
}

listing 7
#include <stdio.h>
#include <dir.h>

int main(void)
{
  char dir[MAXDIR];

  getcurdir(0, dir);
  printf("Current directory is %s", dir);
  return 0;
}

listing 8
#include <stdio.h>
#include <dir.h>

int main(void)
{
  char dir[MAXDIR];

  getcwd(dir, MAXDIR);
  printf("Current directory is %s", dir);
  return 0;
}

listing 9
#include <stdio.h>
#include <direct.h>

int main(void)
{
  char path[80];

  _getdcwd(4, path, 80);

  printf("Current directory of drive D is %s\n", path);

  return 0;
}

listing 10
#include <stdio.h>
#include <dir.h>

int main(void)
{
  printf("Current drive is %c", getdisk()+'A');
  return 0;
}

listing 11
printf("Current drive is %d.", _getdrive());

listing 12
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
  char fpath[80];
  char fname[9];
  char dir[64];
  char drive[3];
  char ext[5];

  _makepath(fpath, "B:", "MYDIR", "MYFILE", "DAT");
  printf("%s\n", fpath);

  _splitpath(fpath, drive, dir, fname, ext);
  printf("%s %s %s %s\n", drive, dir, fname, ext);

  return 0;
}

listing 13
#include <dir.h>

int main(void)
{
  mkdir("FORMLET");
  return 0;
}

listing 14
#include <stdio.h>
#include <dir.h>

char fname[7] = "XXXXXX";

int main(void)
{
  mktemp(fname);
  printf(fname);
  return 0;
}

listing 15
#include <stdio.h>
#include <dir.h>
int main(void)
{
  if(!rmdir("FORMLET")) printf("FORMLET removed\n");
  return 0;
}

listing 16
#include <stdio.h>
#include <dir.h>

int main(void)
{
  printf(searchpath("BCC.EXE"));
  return 0;
}

listing 17
#include <stdio.h>
#include <dir.h>

int main(void)
{
  printf("%d drives", setdisk(0));
  return 0;
}

listing 18
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
  char fname[9];
  char dir[64];
  char drive[3];
  char ext[5];

  _splitpath("B:\\MYDIR\\MYFILE.DAT", drive, dir, fname, ext);

  printf("%s %s %s %s\n", drive, dir, fname, ext);

  return 0;
}

listing 1
#include <process.h>
#include <conio.h>

int main(void)
{
  for(;;)
    if(getch()=='A') abort();
  return 0;
}

listing 2
#include <stdio.h>
#include <stdlib.h>

/* Example using atexit(). */
int main(void)
{
  void done();

  if(atexit(done)) printf("Error in atexit().");
  return 0;
}

void done()
{
  printf("Hello there!");
}

listing 3
_cexit();

listing 4
/* First file - parent */

#include <stdio.h>
#include <process.h>
#include <stdlib.h>

int main(void)
{
  execl("test.exe", "test.exe", "hello", "10", NULL);
  return 0;
}


/* Second file - child */
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char *argv[])
{
  printf("This program is executed with these command line ");
  printf("arguments: ");
  printf(argv[1]);
  printf(" %d", atoi(argv[2]));
  return 0;
}

listing 5
char menu(void)
{
  char ch;

  do {
    printf("Enter names (E)");
    printf("Delete name (D)");
    printf("Print (P)");
    printf("Quit (Q)");
  } while(!strchr("EDPQ", toupper(ch));
  if(ch=='Q') exit(0);
  return ch;
}

listing 6
/* Parent process */
#include <stdio.h>
#include <process.h>

int main(void)
{
  printf("In parent\n");
  spawnl(P_WAIT, "test.exe", "test.exe", "hello", "10", NULL);
  printf("In parent\n");
  return 0;
}


/* First child */
#include <stdio.h>
#include <stdlib.h>
#include <process.h>

int main(int argc, char *argv[])
{
  printf("First child process executing ");
  printf("with these command line arguments: ");
  printf(argv[1]);
  printf(" %d\n", atoi(argv[2]));
  spawnl(P_WAIT, "test2.exe", NULL);
  printf("In first child process.\n");
  return 0;
}


/* Second child */
#include <stdio.h>
int main(void)
{
  printf("In second child process.\n");
  return 0;
}

listing 1
bcc test graphics.lib

listing 2
#include <graphics.h>
#include <conio.h>

int main(void)
{
  int driver, mode;

  driver = DETECT; /* autodetect */
  mode = 0;
  initgraph(&driver, &mode, "c:\\bc5\\bgi");

  setcolor(WHITE);
  arc(100, 100, 0, 90, 20);

  getch(); /* wait until keypress */
  restorecrtmode();

  return 0;
}

listing 3
#include <graphics.h>
#include <conio.h>

int main(void)
{
  int driver, mode;
  driver = DETECT; /* autodetect */
  mode = 0;
  initgraph(&driver, &mode, "c:\\bc5\\bgi");

  /* display a green 2-d bar */
  setfillstyle(SOLID_FILL, GREEN);
  bar(100, 100, 120, 200);

  /* now show a red 3-d bar */
  setfillstyle(SOLID_FILL, RED);
  bar3d(200, 100, 220, 200, 10, 1);

  getch();
  restorecrtmode();
  return 0;
}

listing 4
#include <graphics.h>
#include <conio.h>

int main(void)
{
  int driver, mode;
  driver = DETECT; /* autodetect */
  mode = 0;
  initgraph(&driver, &mode, "c:\\bc5\\bgi");

  circle(200, 200, 20);
  circle(200, 200, 30);
  circle(200, 200, 40);
  circle(200, 200, 50);
  circle(200, 200, 60);

  getch();
  restorecrtmode();
  return 0;
}

listing 5
#include <graphics.h>
#include <conio.h>

void box(int, int, int, int, int);

int main(void)
{
  int driver, mode;

  driver = DETECT; /* autodetect */
  mode = 0;
  initgraph(&driver, &mode, "c:\\bc5\\bgi");

  /* frame the screen for perspective */
  box(0, 0, 639, 349, WHITE);

  setviewport(20, 20, 200, 200, 1);
  box(0, 0, 179, 179, RED);

  outtext("this is a test of the viewport");

  outtextxy(20, 10, "press a key");
  getch();
  /* clear the current viewport but not the entire screen */
  clearviewport();

  getch();
  restorecrtmode();
  return 0;
}

/* Draw a box given the coordinates of its two corners. */
void box(int startx, int starty, int endx, int endy,
         int color)
{
  setcolor(color);
  line(startx, starty, startx, endy);
  line(startx, starty, endx, starty);
  line(endx, starty, endx, endy);
  line(endx, endy, startx, endy);
}

listing 6
closegraph();
cprintf("this is not in graphics");

listing 7
#include <conio.h>

int main(void)
{
  register int i;

  gotoxy(10, 10);
  cprintf("This is a test of the clreol() function.");
  getch();
  gotoxy(10, 10);
  clreol();

  for(i=0; i<20; i++) cprintf("Hello there\n\r");
  getch();

  /* clear the screen */
  clrscr();
  return 0;
}

listing 8
#include <conio.h>

int main(void)
{
  /* This prints "this is a test" left justified
     in 20 character field.
  */
  cprintf("%-20s", "this is a test");

  /* This prints a float with 3 decimal places in a 10
     character field. The output will be "    12.235".
  */
  cprintf("%10.3f\n\r", 12.234657);
  return 0;
}

listing 9
#include <conio.h>

void border(int, int, int, int);

int main(void)
{
  clrscr();
  /* create first window */
  window(3, 2, 40, 9);
  border(3, 2, 40, 9);
  gotoxy(1,1);
  cputs("This line will be wrapped at the end of the window.");
  getche();
  return 0;
}

/* Draws a border around a text window. */
void border(int startx, int starty, int endx, int endy)
 {
  register int i;

  gotoxy(1, 1);
  for(i=0; i<=endx-startx; i++)
    putch('-');

  gotoxy(1, endy-starty);
  for(i=0; i<=endx-startx; i++)
    putch('-');

  for(i=2; i<endy-starty; i++) {
    gotoxy(1, i);
    putch('|');
    gotoxy(endx-startx+1, i);
    putch('|');
  }
}

listing 10
char str[80];
float f;

cscanf("%s%f", str, &f);

listing 11
#include <conio.h>

int main(void)
{
  register int i;

  clrscr();

  for(i=0; i<24; i++) cprintf("line %d\n\r", i);
  getch();
  gotoxy(1, 3);
  delline();

  getch();
  return 0;
}

listing 12
int driver, mode;
detectgraph(&driver, &mode);

if(driver==-2) {
  cprintf("No graphics adapter in the system.\n");
  exit(1);
}

listing 13
#include <graphics.h>
#include <conio.h>

int main(void)
{
  int driver, mode;
  int shape[10] = { /* five points * 2 */
    10, 10,
    100, 80,
    200, 200,
    350, 90,
    0, 0
  };

  driver = DETECT; /* autodetect */
  mode = 0;
  initgraph(&driver, &mode, "c:\\bc5\\bgi");

  drawpoly(5, shape);
  getch();
  restorecrtmode();
  return 0;
}

listing 14
#include <graphics.h>
#include <conio.h>

int main(void)
{  int driver, mode;

  driver = DETECT; /* autodetect */
  mode = 0;
  initgraph(&driver, &mode, "c:\\bc5\\bgi");

  ellipse(100, 100, 0, 360, 80, 40);

  getch();
  restorecrtmode();
  return 0;
}

listing 15
#include <graphics.h>
#include <conio.h>

int main(void)
{
  int driver, mode;

  driver = DETECT; /* autodetect */
  mode = 0;
  initgraph(&driver, &mode, "c:\\bc5\\bgi");

  fillellipse(100, 100, 80, 40);

  getch();
  restorecrtmode();
  return 0;
}

listing 16
#include <graphics.h>
#include <conio.h>

int main(void)
{
  int driver, mode;

  int shape[] = {
    100, 100,
    100, 200,
    200, 200,
    100, 100
  };

  driver = DETECT; /* autodetect */
  mode = 0;
  initgraph(&driver, &mode, "c:\\bc5\\bgi");

  setfillstyle(INTERLEAVE_FILL, MAGENTA);
  fillpoly(4, shape);

  getch();
  restorecrtmode();
  return 0;
}

listing 17
#include <graphics.h>
#include <conio.h>

int main(void)
{
  int driver, mode;

  driver = DETECT; /* autodetect */
  mode = 0;
  initgraph(&driver, &mode, "c:\\bc5\\bgi");

  ellipse(100, 100, 0, 360, 80, 40);

  setfillstyle(XHATCH_FILL, MAGENTA);
  floodfill(100, 100, WHITE);

  getch();
  restorecrtmode();
  return 0;
}

listing 18
#include <graphics.h>
#include <conio.h>

int main(void)
{
  int driver, mode;
  struct arccoordstype ac;

  driver = DETECT; /* autodetect */
  mode = 0;
  initgraph(&driver, &mode, "c:\\bc5\\bgi");

  arc(100, 100, 0, 90, 100);

  /* now, draw a line between the endpoints of the arc */
  getarccoords(&ac);  /* get the coordinates */
  line(ac.xstart, ac.ystart, ac.xend, ac.yend);

  getch();
  restorecrtmode();
  return 0;
}

listing 19
int xasp, yasp;

getaspectratio(&xasp, &yasp);

cprintf("X,Y aspect ratios %d %d", xasp, yasp);

listing 20
cprintf("background color is %d", getbkcolor());

listing 21
cprintf("drawing color is %d", getcolor());

listing 22
struct palettetype far *p;
p = getdefaultpalette();

listing 23
#include <graphics.h>
#include <conio.h>

int main(void)
{
  int driver, mode;
  char *name;
  driver = DETECT; /* autodetect */
  mode = 0;
  initgraph(&driver, &mode, "c:\\bc5\\bgi");

  name = getdrivername();

  outtextxy(10, 10, name);

  getch();
  restorecrtmode();
  return 0;
}

listing 24
#include <stdio.h>
#include <graphics.h>
#include <conio.h>

int main(void)
{
  int driver, mode;
  char f[8], num[10];
  int i;

  driver = DETECT; /* autodetect */
  mode = 0;
  initgraph(&driver, &mode, "c:\\bc5\\bgi");
  getfillpattern((char far *) &f);

  /* display each byte in fill pattern */
  for(i=0; i<8; i++) {
    sprintf(num, "%d ", f[i]);
    outtext(num);
  }

  getch();
  restorecrtmode();
  return 0;
}

listing 25
struct fillsettingstype p;

getfillsettings(&p);

listing 26
printf("graphics mode is %d", getgraphmode());

listing 27
/* This program demonstrates how a graphics image can be
   moved using getimage(), imagesize(), and putimage().
*/
  #include <conio.h>
  #include <graphics.h>
  #include <stdlib.h>
void box(int, int, int, int, int);

int main(void)
{
  int driver, mode;
  unsigned size;
  void *buf;

  driver = DETECT; /* autodetect */
  mode = 0;
  initgraph(&driver, &mode, "c:\\bc5\\bgi");

  box(20, 20, 200, 200, 15);
  setcolor(RED);
  line(20, 20, 200, 200);
  setcolor(GREEN);
  line(20, 200, 200, 20);
  getch();

  /* move the image */

  /* first, get the image's size */
  size = imagesize(20, 20, 200, 200);
  if(size != 0xffff) { /* alloc memory for the image */
    buf = malloc(size);
    if(buf) {
      getimage(20, 20, 200, 200, buf);
      putimage(100, 100, buf, COPY_PUT);
      putimage(300, 50, buf, COPY_PUT);
    }
  }
  outtext("Press a key.");
  getch();
  restorecrtmode();
  return 0;
}

/* Draw a box given the coordinates of its two corners. */
void box(int startx, int starty, int endx, int endy,
         int color)
{
  setcolor(color);

  line(startx, starty, startx, endy);
  line(startx, starty, endx, starty);
  line(endx, starty, endx, endy);
  line(endx, endy, startx, endy);
}

listing 28
struct linesettingstype info;

getlinesettings(&info);

listing 29
#include <stdio.h>
#include <graphics.h>
#include <conio.h>

int main(void)
{
  int driver, mode;

  driver = DETECT; /* autodetect */
  mode = 0;
  initgraph(&driver, &mode, "c:\\bc5\\bgi");

  printf("largest color: %d", getmaxcolor());
  getch();
  restorecrtmode();
  return 0;
}

listing 30
int mode;
mode = getmaxmode();

listing 31
#include <stdio.h>
#include <graphics.h>
#include <conio.h>

int main(void)
{
  int driver, mode;

  driver = DETECT; /* autodetect */
  mode = 0;
  initgraph(&driver, &mode, "c:\\bc5\\bgi");

  printf("max X,Y: %d,%d", getmaxx(), getmaxy());
  getch();
  restorecrtmode();
  return 0;
}

listing 32
#include <graphics.h>
#include <conio.h>
int main(void)
{
  int driver, mode;
  char *name;
  driver = DETECT; /* autodetect */
  mode = 0;
  initgraph(&driver, &mode, "c:\\bc5\\bgi");

  name = getmodename(mode);  /* default mode */

  outtextxy(10, 10, name);

  getch();
  restorecrtmode();
  return 0;
}

listing 33
#include <stdio.h>
#include <graphics.h>
#include <conio.h>

int main(void)
{
  int driver, mode;
  int high, low;

  driver = DETECT; /* autodetect */
  mode = 0;
  initgraph(&driver, &mode, "c:\\bc5\\bgi");

  getmoderange(driver, &low, &high);
  printf("mode range: %d - %d", low, high);
  getch();
  restorecrtmode();
  return 0;
}

listing 34
#include <stdio.h>
#include <graphics.h>
#include <conio.h>

int main(void)
{
  int driver, mode;
  struct palettetype p;

  driver = DETECT; /* autodetect */
  mode = 0;
  initgraph(&driver, &mode, "c:\\bc5\\bgi");
  getpalette(&p);
  printf("number of colors in palette: %d", p.size);
  getch();
  restorecrtmode();
  return 0;
}

listing 35
#include <graphics.h>
#include <conio.h>
#include <stdio.h>

int main(void)
{
  int driver, mode;
  int num;
  char buff[100];

  driver = DETECT; /* autodetect */
  mode = 0;
  initgraph(&driver, &mode, "c:\\bc5\\bgi");

  num = getpalettesize();
  sprintf(buff, "Number of colors in palette: %d", num);
  outtextxy(10, 10, buff);

  getch();
  restorecrtmode();
  return 0;
}

listing 36
getpixel(10, 20);

listing 37
malloc(10 * 10 *2);

gettext(10, 10, 20, 20, buf);

listing 38
struct text_info i;
gettextinfo(&i);

listing 39
struct textsettingstype t;

gettextsettings(&t);

listing 40
struct viewporttype info;

getviewsettings(&info);

printf("View port is %dx%x by %dx%d", info.left, info.right,
        info.top, info.bottom);

listing 41
printf("CP's loc: %d, %d", getx(), gety());

listing 42
#include <conio.h>

int main(void)
{
  register int i, j;

  clrscr();

  /* print diagonal Xs */
  for(i=1, j=1; j<24; i+=3, j++) {
    gotoxy(i, j);
    cprintf("X");
  }
   getche();
   clrscr();
   return 0;
}

listing 43
graphdefaults();

listing 44
printf("%s", grapherrormsg(graphresult()));

listing 45
printf("%s", grapherrormsg(graphresult()));

listing 46
highvideo();

listing 47
unsigned size;

size = imagesize(10, 10, 100, 100);

listing 48
int driver, mode;

driver = DETECT; /* autodetect */
mode = 0;
initgraph(&driver, &mode, "");

listing 49
#include <conio.h>

int main(void)
{
  register int i;

  clrscr();

  for(i=1; i<24; i++) {
    gotoxy(1, i);
    cprintf("This is line %d\n\r", i);
  }
  getche();
  gotoxy(1, 10);
  insline();
  getch();
  return 0;
}

listing 50
int driver, mode;

driver = installuserdriver("newdriver", NULL);
mode = 0;
initgraph(&driver, &mode, "");

listing 51
int fontnumber;

fontnumber = installuserfont("newfont.chr");
settextstyle(fontnumber, HORIZ_DIR, 1);

listing 52
#include <graphics.h>
#include <conio.h>

int main(void)
{
  int driver, mode;

  driver = DETECT; /* autodetect */
  mode = 0;
  initgraph(&driver, &mode, "c:\\bc5\\bgi");

  line(100, 100, 200, 200);

  lineto(100, 50);

  linerel(30, 40);

  getch();
  restorecrtmode();
  return 0;
}

listing 53
lowvideo();

listing 54
moverel(10, 20);

listing 55
movetext(1, 1, 8, 8, 10, 10);

listing 56
moveto(100, 100);

listing 57
normvideo();

listing 58
#include <graphics.h>
#include <conio.h>

int main(void)
{
  int driver, mode;
  int i;

  driver = DETECT; /* autodetect */
  mode = 0;
  initgraph(&driver, &mode, "c:\\bc5\\bgi");

  /* write two lines at CP */
  outtext("this is an example ");
  outtext("another line");

  /* use "cursor" positioning */
  for(i=100; i<200; i+=8) outtextxy(200, i, "hello");

  getch();
  restorecrtmode();
  return 0; 
}

listing 59
#include <graphics.h>
#include <conio.h>

int main(void)
{
  int driver, mode;
  int i, start, end;

  driver = DETECT; /* autodetect */
  mode = 0;
  initgraph(&driver, &mode, "c:\\bc5\\bgi");

  /* demonstrate pieslice() */

  start = 0; end = 45;
  for(i=0; i<8; i++) {
    setfillstyle(SOLID_FILL, i);
    pieslice(300, 200, start, end, 100);
    start += 45;
    end += 45;
  }

  getch();
  restorecrtmode();
  return 0;
}

listing 60
/* This program demonstrates how a graphics image can be
   moved using getimage(), imagesize(), and putimage().
*/
  #include <conio.h>
  #include <graphics.h>
  #include <stdlib.h>

void box(int, int, int, int, int);

int main(void)
{
  int driver, mode;
  unsigned size;
  void *buf;

  driver = DETECT; /* autodetect */
  mode = 0;
  initgraph(&driver, &mode, "c:\\bc5\\bgi");

  box(20, 20, 200, 200, 15);

  setcolor(RED);
  line(20, 20, 200, 200);
  setcolor(GREEN);
  line(20, 200, 200, 20);
  getch();

  /* move the image */

  /* first, get the image's size */
  size = imagesize(20, 20, 200, 200);
  if(size != 0xffff) { /* alloc memory for the image */
    buf = malloc(size);
    if(buf) {
      getimage(20, 20, 200, 200, buf);
      putimage(100, 100, buf, COPY_PUT);
      putimage(300, 50, buf, COPY_PUT);
    }
  }
  outtext("press a key");
  getch();
  restorecrtmode();
  return 0;
}

/* Draw a box given the coordinates of its two corners. */
void box(int startx, int starty, int endx, int endy,
         int color)
{
  setcolor(color);

  rectangle(startx, starty, endx, endy);
}

listing 61
putpixel(10, 20, GREEN);

listing 62
malloc(10 * 10 *2);
gettext(10, 10, 20, 20, buf);
puttext(0, 0, 30, 30, buf);

listing 63
#include <graphics.h>
#include <conio.h>

int main(void)
{
  int driver, mode;

  driver = DETECT; /* autodetect */
  mode = 0;
  initgraph(&driver, &mode, "c:\\bc5\\bgi");

  rectangle(100, 100, 300, 300);
  rectangle(150, 90, 34, 300);
  rectangle(0, 0, 2, 2);

  getch();
  restorecrtmode();
  return 0;
}

listing 64
restorecrtmode();

listing 65
#include <graphics.h>
#include <conio.h>

int main(void)
{
  int driver, mode;
  int i, start, end;

  driver = DETECT; /* autodetect */
  mode = 0;
  initgraph(&driver, &mode, "c:\\bc5\\bgi");

  /* demonstrate sector() */

  start = 0; end = 45;
  for(i=0; i<8; i++) {
    setfillstyle(SOLID_FILL, i);
    sector(300, 200, start, end, 100, 200);
    start += 45;
    end += 45;
  }

  getch();
  restorecrtmode();
  return 0;
}

listing 66
setactivepage(1);

listing 67
struct palettetype p;
int i;

for(i=0; i<16; i++) p.colors[i] = i;
p.size = 16;

setallpalette(&p);

listing 68
int xaspect, yaspect;

getaspectratio(&xaspect, &yaspect);
yaspect += 1;
setaspectratio(&xaspect, &yaspect);

cprintf("X,Y aspect ratios are now %d %d",
         xaspect, yaspect);

listing 69
#include <graphics.h>
#include <conio.h>

int main(void)
{
  int driver, mode;

  driver = DETECT; /* autodetect */
  mode = 0;
  initgraph(&driver, &mode, "c:\\bc5\\bgi");

  setbkcolor(LIGHTGRAY);

  rectangle(100, 100, 300, 300);
  rectangle(150, 90, 34, 300);
  rectangle(0, 0, 2, 2);

  getch();
  restorecrtmode();
  return 0;
}

listing 70
#include <graphics.h>
#include <conio.h>

int main(void)
{
  int driver, mode;
  int i;

  driver = DETECT; /* autodetect */
  mode = 0;
  initgraph(&driver, &mode, "c:\\bc5\\bgi");

  moveto(0, 200);

  for(i=0; i<16; i++) {
    setcolor(i);
    linerel(20, 0);
  }

  getch();
  restorecrtmode();
  return 0;
}

listing 71
#include <graphics.h>
#include <conio.h>

int main(void)
{
  int driver, mode;
  /* define a fill pattern */
  char p[8] = {1, 2, 3, 4, 5, 6, 7};

  driver = DETECT; /* autodetect */
  mode = 0;
  initgraph(&driver, &mode, "c:\\bc5\\bgi");

  setcolor(GREEN);
  rectangle(100, 200, 200, 300);

  setfillpattern(p, RED);
  floodfill(150, 250, GREEN);

  getch();
  restorecrtmode();
  return 0;
}

listing 72
#include <graphics.h>
#include <conio.h>

int main(void)
{
  int driver, mode;

  driver = DETECT; /* autodetect */
  mode = 0;
  initgraph(&driver, &mode, "c:\\bc5\\bgi");

  setcolor(GREEN);
  rectangle(100, 200, 200, 300);

  setfillstyle(LINE_FILL, RED);
  floodfill(150, 250, GREEN);

  getch();
  restorecrtmode();
  return 0;
}

listing 73
/* after graphics system has been initialized */
setgraphmode(VGAHI);

listing 74
#include <graphics.h>
#include <conio.h>

int main(void)
{
  int driver, mode;
  int i;

  driver = DETECT; /* autodetect */
  mode = 0;
  initgraph(&driver, &mode, "c:\\bc5\\bgi");

  for(i=0; i<4; i++) {
    setlinestyle(i, 0, 1);
    line(i*50, 100, i*50+50, 100);
  }

  getch();
  restorecrtmode();
  return 0;
}

listing 75
setpalette(0, GREEN);

listing 76
setpalette(5, EGA_CYAN);

listing 77
setrgbpalette(15, 16, 16, 16);  /* the upper 6 bits = 4 */

listing 78
settextjustify(RIGHT_TEXT, TOP_TEXT);

listing 79
/* Demonstrate some different text fonts and sizes. */

#include <graphics.h>
#include <conio.h>

int main(void)
{
  int driver, mode;

  driver = DETECT; /* autodetect */
  mode = 0;
  initgraph(&driver, &mode, "c:\\bc5\\bgi");

  outtext("Normal ");

  /* Gothic font, twice normal size */
  settextstyle(GOTHIC_FONT, HORIZ_DIR, 2);
  outtext("Gothic ");

  /* Triplex font, twice normal size */
  settextstyle(TRIPLEX_FONT, HORIZ_DIR, 2);
  outtext("Triplex ");

  /* Sans serif font, 7 times normal size*/
  settextstyle(SANS_SERIF_FONT, HORIZ_DIR, 7);
  outtext("Sans serif");
  getch();
  restorecrtmode();
  return 0;
}

listing 80
#include <graphics.h>
#include <conio.h>

int main(void)
{
  int driver, mode;

  driver = DETECT; /* autodetect */
  mode = 0;
  initgraph(&driver, &mode, "c:\\bc5\\bgi");

  outtext("normal ");
  settextstyle(TRIPLEX_FONT, HORIZ_DIR, USER_CHAR_SIZE);

  /* make very big letters */
  setusercharsize(5, 1, 5, 1);
  outtext("big");

  getch();
  restorecrtmode();
  return 0;
}

listing 81
setviewport(10, 10, 40, 40, 1);

listing 82
setvisualpage(1);

listing 83
#include <graphics.h>
#include <conio.h>

int main(void)
{
  int driver, mode;

  driver = DETECT; /* autodetect */
  mode = 0;
  initgraph(&driver, &mode, "c:\\bc5\\bgi");

  setwritemode(COPY_PUT);  /* set for overwrite */
  setcolor(BLUE);
  rectangle(10, 10, 100, 100);
  getch();

  setwritemode(XOR_PUT);  /* set for combining */

  setcolor(RED);
  rectangle(30, 30, 80, 80); /* draw inside first rectangle */
  getch();

  rectangle(30, 30, 80, 80); /* now erase it */
  getch();

  restorecrtmode();
  return 0;
}

listing 84
textattr(RED | BLINK | BLUE*16);

listing 85
textbackground(CYAN);

listing 86
textcolor(BLINK);

listing 87
#include <stdio.h>
#include <graphics.h>
#include <conio.h>

int main(void)
{
  int driver, mode;

  driver = DETECT; /* autodetect */
  mode = 0;
  initgraph(&driver, &mode, "c:\\bc5\\bgi");

  printf("height: %d", textheight("hello"));

  getch();
  restorecrtmode();
  return 0;
}

listing 88
textmode(C80);

listing 89
#include <stdio.h>
#include <graphics.h>
#include <conio.h>

int main(void)
{
  int driver, mode;

  driver = DETECT; /* autodetect */
  mode = 0;
  initgraph(&driver, &mode, "c:\\bc5\\bgi");

  printf("width: %d", textwidth("hello"));

  getch();
  restorecrtmode();
  return 0;
}

listing 90
int xpos, ypos;

xpos = wherex();
ypos = wherey();

listing 91
window(10, 10, 60, 15);
gotoxy(2, 3);
cprintf("at location 2, 3");

listing 1
#include <stdio.h>
#include <stdlib.h>

int get_abs()
{
  char num[80];

  gets(num);

  return abs(atoi(num));
}

listing 2
.
.
.
ch = read_port();
assert(!(ch & 128)); /* check bit 7 */
.
.
.

listing 3
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
  char num1[80], num2[80];

  printf("Enter first number: ");
  gets(num1);
  printf("Enter second number: ");
  gets(num2);
  printf("The sum is: %f", atof(num1)+atof(num2));
  return 0;
}

listing 4
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
  char num1[80], num2[80];

  printf("Enter first number: ");
  gets(num1);
  printf("Enter second number: ");
  gets(num2);
  printf("The sum is: %d", atoi(num1)+atoi(num2));
  return 0;
}

listing 5
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
  char num1[80], num2[80];

  printf("Enter first number: ");
  gets(num1);
  printf("Enter second number: ");
  gets(num2);
  printf("The sum is: %ld", atol(num1)+atol(num2));
  return 0;
}

listing 6
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>

char *alpha="abcdefghijklmnopqrstuvwxyz";
int comp(const void *, const void *);

int main(void)
{
  char ch;
  char *p;

  do {
    printf("Enter a character: ");
    scanf("%c%*c", &ch);
    ch = tolower(ch);
    p = (char *) bsearch(&ch, alpha, 26, 1, comp);
    if(p) printf("is in alphabet\n");
    else printf("is not in alphabet\n");
  } while(p);
  return 0;
}

/* Compare two characters. */
int comp(const void *ch, const void *s)
{
  return *(char *)ch - *(char *)s;
}

listing 7
int quot;  /* the quotient */
int rem;   /* the remainder */

listing 8
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
  div_t n;

  n = div(10,3);

  printf("Quotient and remainder: %d %d\n", n.quot, n.rem);

  return 0;
}

listing 9
int decpnt, sign;
char *out;

out = ecvt(10.12, 5, &decpnt, &sign);

listing 10
int decpnt, sign;
char *out;

out = fcvt(10.12, 5, &decpnt, &sign);

listing 11
/* compute and print payroll checks */
system("payroll");

_fpreset();

listing 12
char buf[80];

gcvt(10.12, 5, buf);

listing 13
.
.
.
p = getenv("DEVICES");
.
.
.

listing 14
#include <conio.h>
#include <string.h>
void pswd (char *pw)

{
  char *input;

  do {
    input=getpass("Enter your password:");
  } while (!strcmp("starbar", input));

  printf("You're in!");
}

listing 15
printf("This process ID of this program is %d\n", getpid());

listing 16
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
  char p[17];

  itoa(1423, p, 16);

  printf(p);

  return 0;
}

listing 17
#include <stdio.h>
#include <stdlib.h>
long int get_labs()
{
  char num[80];

  gets(num);

  return labs(atol(num));
}

listing 18
long quot;  /* the quotient */
long rem;   /* the remainder */

listing 19
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
  ldiv_t n;

  n = ldiv(100000L,3L);

  printf("Quotient and remainder: %ld %ld.\n", n.quot, n.rem);

  return 0;
}

listing 20
#include <stdlib.h>
#include <ctype.h>
#include <stdio.h>

char *alpha="abcdefghijklmnopqrstuvwxyz";

int comp(const void *, const void *);

int main(void)
{
  char ch;
  char *p;
  size_t num=26;

  do {
    printf("Enter a character: ");
    scanf("%c%*c", &ch);
    ch = tolower(ch);
    p = (char *) lfind(&ch, alpha, &num, 1, comp);
    if(p) printf("is in alphabet\n");
    else printf("is not in alphabet\n");
  } while(p);
  return 0;
}

/* Compare two characters. */
int comp(const void *ch, const void *s)
{
  return *(char *)ch - *(char *)s;
}

listing 21
#include <stdio.h>
#include <setjmp.h>

jmp_buf ebuf;
void f2(void);

int main(void)
{
  char first=1;
  int i;

  printf("1 ");
  i = setjmp(ebuf);
  if(first) {
    first =! first;
    f2();
    printf("this will not be printed");
  }
  printf("%d", i);
  return 0;
}

void f2(void)
{
  printf("2 ");
  longjmp(ebuf, 3);
}

listing 22
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
  char p[34];

  ltoa(1423, p, 16);

  printf(p);

  return 0;
}

listing 23
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
  unsigned long l = 1;

  printf("1 rotated left 2 bits = %ld\n", _lrotl(l,2));
  printf("1 rotated right 2 bits = %ld\n", _lrotr(l,2));

  return 0;
}

listing 24
#include <stdlib.h>
#include <stdio.h>

int main (void)
{
  printf("max of 10, 20 is %d\n", max (10, 20));
  printf("min of 10, 20 is %d\n", min (10, 20));

  return 0;
}

listing 25
printf("%d", mblen(mb, 2));

listing 26
mbstowcs(wstr, mb, 4);

listing 27
mbtowc(wstr, mbstr, 2);

listing 28
#include <dos.h>

int main(void)
{
  sound(1000);
  sleep(2);
  nosound();

  return 0;
}

listing 29
#include <dos.h>
#include <stdio.h>

int main(void)
{
  int result;

  result = _OvrInitExt(NULL, 0);
  if(result)
    printf("Cannot use extended memory for overlays.");

  return 0;
}

listing 30
#include <stdio.h>
#include <stdlib.h>

int num[10] = {
  1,3,6,5,8,7,9,6,2,0
};

int comp(const int *, const int *);

int main(void)
{
  int i;

  printf("Original array: ");
  for(i=0; i<10; i++) printf("%d ",num[i]);
  printf("\n");

  qsort(num, 10, sizeof(int),
        (int(*)(const void *, const void *)) comp);

  printf("Sorted array: ");
  for(i=0; i<10; i++) printf("%d ", num[i]);

  return 0;
}

/* compare the integers */
int comp(const int *i, const int *j)
{ 
  return *i - *j;
}

listing 31
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>

void myhandler(int);

int main(void)
{
  signal(SIGTERM, myhandler);
  raise(SIGTERM);
  printf("This line will not be executed.\n");
  return 0;
}

void myhandler(int notused)
{
  printf("Program terminated.\n");
  exit(1);
}

listing 32
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
  int i;

  for(i=0; i<10; i++)
    printf("%d ", rand());

  return 0;
}

listing 33
#include <time.h>
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
  int i;

  randomize();

  for(i=0; i<10; i++) printf("%d ", random(25));

  return 0;
}

listing 34
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
  unsigned val = 64;

  printf("Rotated left 2 bits = %d\n", _rotl(val,2));
  printf("Rotated right 2 bits = %d\n", _rotr(val,2));

  return 0;
}

listing 35
_setcursortype(_SOLIDCURSOR);

listing 36
#include <stdio.h>
#include <setjmp.h>

jmp_buf ebuf;
void f2(void);

int main(void)
{
  char first=1;
  int i;

  printf("1 ");
  i = setjmp(ebuf);
  if(first) {
    first =! first;
    f2();
    printf("this will not be printed");
  }
  printf("%d", i);
  return 0;
}

void f2(void)
{
  printf("2 ");
  longjmp(ebuf, 3);
}

listing 37
#include <stdlib.h>
#include <stdio.h>

int main(int argc, char *argv[])
{
  char fpath[64];

  if(argc!=3) {
    printf("Usage: FINDFILE <fname> <ename>");
    return 1;
  }

  _searchenv(argv[1], argv[2], fpath);

  /* fpath will contain path if file is found */
  if(*fpath) printf("Path: %s", fpath);

  return 0;
}

listing 38
signal(SIGINT, myint);

listing 39
#include <dos.h>

int main(void)
{
  sound(440);
  sleep(1);
  nosound();

  return 0;
}

listing 40
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

/* Seed rand with the system time
   and display the first 100 numbers.
*/
int main(void)
{
  int i, stime;
  long  ltime;

  /* get the current calendar time */

  ltime = time(NULL);
  stime = (unsigned int) ltime/2;
  srand(stime);
  for(i=0; i<10; i++) printf("%d ", rand());
  return 0;
}

listing 41
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>

int main(void)
{
  char *end, *start="100.00 pliers 200.00 hammers";

  end = start;
  while(*start) {
    printf("%f, ",strtod(start, &end));
    printf("Remainder: %s\n", end);
    start = end;
    /* move past the non-digits */
    while(!isdigit(*start) && *start) start++;
  }
  return 0;
}

listing 42
#include <stdio.h>
#include <stdlib.h>

long int read_long()
{
  char start[80], *end;

  printf("Enter a number: ");
  gets(start);
  return strtol(start, &end, 10);
}

listing 43
char dest[3];

swab("Hi", dest, 2);
printf(dest);

listing 44
#include <stdlib.h>

int main(void)
{
  system("dir");
  return 0;
}

listing 45
int ch;

ch = getche():

ch = toascii(ch);

listing 46
umask(S_IREAD);

listing 47
#include <utime.h>
#include <stdio.h>

int main(int argc, char *argv[])
{
  if(argc!=2) {
    printf("Usage: SETTIME <fname>");
    return 1;
  }

  /* set to current system time */
  utime(argv[1], NULL);

  return 0;
}

listing 48
/* Variable length argument example - sum a series.*/

#include <stdio.h>
#include <stdarg.h>

double sum_series(int, ...);

int main(void)
{
  double d;

  d = sum_series(5, 0.5, 0.25, 0.125, 0.0625, 0.03125);

  printf("Sum of series is %f\n",d);

  return 0;

}

double sum_series(int num, ...)
{
  double sum = 0.0, t;
  va_list argptr;

  /* initialize argptr */
  va_start(argptr, num);

  /* sum the series */
  for(; num; num--) {
   t = va_arg(argptr,double);
   sum += t;
  }

  /* do orderly shutdown */
  va_end(argptr);
  return sum;
}

listing 1
#include <iostream.h>
#include <stdio.h>

int main()
{
  int i;
  char str[80];

  cout << "I like Borland C++.\n";  // this is a single-line comment
  /* you can still use C-style comments, too */

  printf("You can use printf(), but most C++ programs don't.\n");

  // input a number using >>
  cout << "Enter a number: ";
  cin >> i;

  // now, output a number using <<
  cout << "Your number is " << i << "\n";

  // read a string
  cout << "Enter a string: ";
  cin >> str;
  // print it
  cout << str;

  return 0;
}

listing 2
int main()

listing 3
int main(void)

listing 4
cout << "I like Borland C++.\n";  // this is a single line comment

listing 5
cout << "I like Borland C++.\n";

listing 6
cin >> i;

listing 7
cout << "Your number is " << i << "\n";

listing 8
// This creates the class queue.
class queue {
  int q[100];
  int sloc, rloc;
public:
  void init();
  void qput(int i);
  int qget();
};

listing 9
queue intqueue;

listing 10
void queue::qput(int i)
{
  if(sloc==99) {
    cout << "Queue is full.\n";
    return;
  }
  sloc++;
  q[sloc] = i;
}

listing 11
queue a, b;

a.init();

listing 12
#include <iostream.h>

// This creates the class queue.
class queue {
  int q[100];
  int sloc, rloc;
public:
  void init();
  void qput(int i);
  int qget();
};

void queue::init()
{
  rloc = sloc = 0;
}

void queue::qput(int i)
{
  if(sloc==99) {
    cout << "Queue is full.\n";
    return;
  }
  sloc++;
  q[sloc] = i;
}

int queue::qget()
{
  if(rloc == sloc) {
    cout << "Queue underflow.\n";
    return 0;
  }
  rloc++;
  return q[rloc];
}

int main()
{
  queue a, b;  // create two queue objects

  a.init();
  b.init();

  a.qput(10);
  b.qput(19);

  a.qput(20);
  b.qput(1);

  cout << a.qget() << " ";
  cout << a.qget() << " ";
  cout << b.qget() << " ";
  cout << b.qget() << "\n";

  return 0;
}

listing 13
a.rloc = 0;

listing 14
#include <iostream.h>

// sqr_it is overloaded three ways
int sqr_it(int i);
double sqr_it(double d);
long sqr_it(long l);

int main()
{
  cout << sqr_it(10) << "\n";

  cout << sqr_it(11.0) << "\n";

  cout << sqr_it(9L) << "\n";

  return 0;
}

int sqr_it(int i)
{
  cout << "Inside the sqr_it() function that uses ";
  cout << "an integer argument.\n";

  return i*i;
}

double sqr_it(double d)
{
  cout << "Inside the sqr_it() function that uses ";
  cout << "a double argument.\n";

  return d*d;
}

long sqr_it(long l)
{
  cout << "Inside the sqr_it() function that uses ";
  cout << "a long argument.\n";

  return l*l;
}

listing 15
#include <iostream.h>

void prompt(char *str, int *i);
void prompt(char *str, double *d);
void prompt(char *str, long *l);

int main()
{
  int i;
  double d;
  long l;

  prompt("Enter an integer: ", &i);
  prompt("Enter a double: ", &d);
  prompt("Enter a long: ", &l);

  cout << i << " " << d << " " << l;

  return 0;
}

void prompt(char *str, int *i)
{
  cout << str;
  cin >> *i;
}

void prompt(char *str, double *d)
{
  cout << str;
  cin >> *d;
}

void prompt(char *str, long *l)
{
  cout << str;
  cin >> *l;
}

listing 16
class road_vehicle {
  int wheels;
  int passengers;
public:
  void set_wheels(int num);
  int get_wheels();
  void set_pass(int num);
  int get_pass();
};

listing 17
class truck : public road_vehicle {
  int cargo;
public:
  void set_cargo(int size);
  int get_cargo();
  void show();
};

listing 18
#include <iostream.h>

class road_vehicle {
  int wheels;
  int passengers;
public:
  void set_wheels(int num);
  int get_wheels();
  void set_pass(int num);
  int get_pass();
};

class truck : public road_vehicle {
  int cargo;
public:
  void set_cargo(int size);
  int get_cargo();
  void show();
};

enum type {car, van, wagon};

class automobile : public road_vehicle {
  enum type car_type;
public:
  void set_type(enum type t);
  enum type get_type();
  void show();
};

void road_vehicle::set_wheels(int num)
{
  wheels = num;
}

int road_vehicle::get_wheels()
{
  return wheels;
}

void road_vehicle::set_pass(int num)
{
  passengers = num;
}

int road_vehicle::get_pass()
{
  return passengers;
}

void truck::set_cargo(int num)
{
  cargo = num;
}

int truck::get_cargo()
{
  return cargo;
}

void truck::show()
{
  cout << "Wheels: " << get_wheels() << "\n";
  cout << "Passengers: " << get_pass() << "\n";
  cout << "Cargo capacity in cubic feet: " << cargo << "\n";
}

void automobile::set_type(enum type t)
{
  car_type = t;
}

enum type automobile::get_type()
{
  return car_type;
}

void automobile::show()
{
  cout << "Wheels: " << get_wheels() << "\n";
  cout << "Passengers: " << get_pass() << "\n";
  cout << "Type: ";
  switch(get_type()) {
    case van: cout << "Van\n";
      break;
    case car: cout << "Car\n";
      break;
    case wagon: cout << "Wagon\n";
  }
}

int main()
{
  truck t1, t2;
  automobile c;

  t1.set_wheels(18);
  t1.set_pass(2);
  t1.set_cargo(3200);

  t2.set_wheels(6);
  t2.set_pass(3);
  t2.set_cargo(1200);

  t1.show();
  t2.show();

  c.set_wheels(4);
  c.set_pass(6);
  c.set_type(van);
  c.show();

  return 0;
}

listing 19
// This creates the class queue.
class queue {
  int q[100];
  int sloc, rloc;
public:
  queue();  // constructor
  void qput(int i);
  int qget();
};

listing 20
// This is the constructor function.
queue::queue()
{
  sloc = rloc = 0;
  cout << "Queue initialized.\n";
}

listing 21
// This creates the class queue.
class queue {
  int q[100];
  int sloc, rloc;
public:
  queue();  // constructor
  ~queue(); // destructor
  void qput(int i);
  int qget();
};

// This is the constructor function.
queue::queue()
{
  sloc = rloc = 0;
  cout << "Queue initialized.\n";
}

// This is the destructor function.
queue::~queue()
{
  cout << "Queue destroyed.\n";
}

listing 22
#include <iostream.h>

// This creates the class queue.
class queue {
  int q[100];
  int sloc, rloc;
public:
  queue();  // constructor
  ~queue(); // destructor
  void qput(int i);
  int qget();
};

// This is the constructor function.
queue::queue()
{
  sloc = rloc = 0;
  cout << "Queue initialized.\n";
}

// This is the destructor function.
queue::~queue()
{
  cout << "Queue destroyed.\n";
}

void queue::qput(int i)
{
  if(sloc==99) {
    cout << "Queue is full.\n";
    return;
  }
  sloc++;
  q[sloc] = i;
}

int queue::qget()
{
  if(rloc == sloc) {
    cout << "Queue underflow.\n";
    return 0;
  }
  rloc++;
  return q[rloc];
}

int main()
{
  queue a, b;  // create two queue objects

  a.qput(10);
  b.qput(19);

  a.qput(20);
  b.qput(1);

  cout << a.qget() << " ";
  cout << a.qget() << " ";
  cout << b.qget() << " ";
  cout << b.qget() << "\n";

  return 0;
}


listing 1
// This creates the class queue.
class queue {
  int q[100];
  int sloc, rloc;
  int who; // holds the queue's ID number
public:
  queue(int id);  // parameterized constructor
  ~queue(); // destructor
  void qput(int i);
  int qget();
};

listing 2
// This is the constructor function.
queue::queue(int id)
{
  sloc = rloc = 0;
  who = id;
  cout << "Queue " << who << " initialized\n";
}

listing 3
queue a = queue(101);

listing 4
queue a(101);

listing 5
#include <iostream.h>

// This creates the class queue.
class queue {
  int q[100];
  int sloc, rloc;
  int who; // holds the queue's ID number
public:
  queue(int id);  // parameterized constructor
  ~queue(); // destructor
  void qput(int i);
  int qget();
};

// This is the constructor function.
queue::queue(int id)
{
  sloc = rloc = 0;
  who = id;
  cout << "Queue " << who << " initialized.\n";
}

// This is the destructor function.
queue::~queue()
{
  cout << "Queue " << who << " destroyed.\n";
}

void queue::qput(int i)
{
  if(sloc==99) {
    cout << "Queue is full.\n";
    return;
  }
  sloc++;
  q[sloc] = i;
}

int queue::qget()
{
  if(rloc == sloc) {
    cout << "Queue underflow.\n";
    return 0;
  }
  rloc++;
  return q[rloc];
}

int main()
{
  queue a(1), b(2);  // create two queue objects

  a.qput(10);
  b.qput(19);

  a.qput(20);
  b.qput(1);

  cout << a.qget() << " ";
  cout << a.qget() << " ";
  cout << b.qget() << " ";
  cout << b.qget() << "\n";

  return 0;
}

listing 6
#include <iostream.h>

class widget {
  int i;
  int j;
public:
  widget(int a, int b);
  void put_widget();
} ;

widget::widget(int a, int b)
{
  i = a;
  j = b;
}

void widget::put_widget()
{
  cout << i << " " << j << "\n";
}

int main()
{
  widget x(10, 20), y(0, 0);

  x.put_widget();
  y.put_widget();

  return 0;
}

listing 7
class cl {
  .
  .
  .
public:
  friend void frd();
  .
  .
  .
};

listing 8
class line;

class box {
  int color; // color of box
  int upx, upy; // upper left corner
  int lowx, lowy; // lower right corner
public:
  friend int same_color(line l, box b);
  void set_color(int c);
  void define_box(int x1, int y1, int x2, int y2);
  void show_box();
} ;

class line {
  int color;
  int startx, starty;
  int len;
public:
  friend int same_color(line l, box b);
  void set_color(int c);
  void define_line(int x, int y, int l);
  void show_line();
} ;

listing 9
// Return true if line and box have same color.
int same_color(line l, box b)
{
  if(l.color==b.color) return 1;
  return 0;
}

listing 10
#include <iostream.h>
#include <conio.h>

class line;

class box {
  int color; // color of box
  int upx, upy; // upper left corner
  int lowx, lowy; // lower right corner
 public:
  friend int same_color(line l, box b);
  void set_color(int c);
  void define_box(int x1, int y1, int x2, int y2);
  void show_box();
} ;

class line {
  int color;
  int startx, starty;
  int len;
public:
  friend int same_color(line l, box b);
  void set_color(int c);
  void define_line(int x, int y, int l);
  void show_line();
} ;

// Return true if line and box have same color.
int same_color(line l, box b)
{
  if(l.color==b.color) return 1;
  return 0;
}

void box::set_color(int c)
{
  color = c;
}

void line::set_color(int c)
{
  color = c;
}

void box::define_box(int x1, int y1, int x2, int y2)
{
  upx = x1;
  upy = y1;
  lowx = x2;
  lowy = y2;
}

void box::show_box()
{
  int i;

  textcolor(color);

  gotoxy(upx, upy);
  for(i=upx; i<=lowx; i++) cprintf("-");

  gotoxy(upx, lowy-1);
  for(i=upx; i<=lowx; i++) cprintf("-");

  gotoxy(upx, upy);
  for(i=upy; i<=lowy; i++) {
    cprintf("|");
    gotoxy(upx, i);
  }

  gotoxy(lowx, upy);
  for(i=upy; i<=lowy; i++) {
    cprintf("|");
    gotoxy(lowx, i);
  }
}

void line::define_line(int x, int y, int l)
{
  startx = x;
  starty = y;
  len = l;
}

void line::show_line()
{
  int i;

  textcolor(color);

  gotoxy(startx, starty);

  for(i=0; i<len; i++) cprintf("-");
}

int main()
{
  box b;
  line l;

  b.define_box(10, 10, 15, 15);
  b.set_color(3);
  b.show_box();

  l.define_line(2, 2, 10);
  l.set_color(2);
  l.show_line();

  if(!same_color(l, b)) cout << "Not the same.\n";
  cout << "\nPress a key.";
  getch();

  // now, make line and box the same color
  l.define_line(2, 2, 10);
  l.set_color(3);
  l.show_line();

  if(same_color(l, b)) cout << "Are the same color.\n";

  return 0;
}

listing 11
void f(int i = 1)
{
  .
  .
  .
}

listing 12
f(10);  // pass an explicit value
f();   // let function use default

listing 13
//Output a string at specified X,Y location.
void xyout(char *str, int x = 0, int y = 0)
{
  if(!x) x = wherex();
  if(!y) y = wherey();
  gotoxy(x, y);
  cout << str;
}

listing 14
#include <iostream.h>
#include <conio.h>

void xyout(char *str, int x=0, int y=0)
{
  if(!x) x = wherex();
  if(!y) y = wherey();
  gotoxy(x, y);
  cout << str;
}

int main()
{
  xyout("hello", 10, 10);
  xyout(" there");
  xyout("I like C++", 40);  // this is still on line 10

  xyout("This is on line 11.\n", 1, 11);
  xyout("This follows on line 12.\n");
  xyout("This follows on line 13.");

  return 0;
}

listing 15
#include <iostream.h>
#include <conio.h>

void xyout(char *str, int x = 0, int y = 0);

int main()
{
  xyout("hello", 10, 10);
  xyout(" there");
  xyout("I like C++", 40);  // this is still on line 10

  xyout("This is on line 11.\n", 1, 11);
  xyout("This follows on line 12.\n");
  xyout("This follows on line 13.");

  return 0;
}

/* Since x and y's defaults have already been specified
   in xyout()'s prototype, they cannot
   be repeated here.
*/
void xyout(char *str, int x, int y)
{
  if(!x) x = wherex();
  if(!y) y = wherey();
  gotoxy(x, y);
  cout << str;
}

listing 16
// wrong!
void xyout(int x = 0, int y = 0, char *str)

listing 17
// wrong !
int f(int i, int j=10, int k)

listing 18
/* This is the constructor function that uses
   a default value. */
queue::queue(int id=0)
{
  sloc = rloc = 0;
  who = id;
  cout << "Queue " << who << " initialized.\n";
}

listing 19
queue a, b(2);

listing 20
#include <iostream.h>

struct cl {
  int get_i(); // these are public
  void put_i(int j); // by default
private:
  int i;
} ;

int cl::get_i()
{
  return i;
}

void cl::put_i(int j)
{
  i = j;
}

int main()
{
  cl s;

  s.put_i(10);
  cout << s.get_i();

  return 0;
}

listing 21
#include <iostream.h>

class cl {
  int i; // private by default
public:
  int get_i();
  void put_i(int j);
} ;

int cl::get_i()
{
  return i;
}

void cl::put_i(int j)
{
  i = j;
}

int main()
{
  cl s;

  s.put_i(10);
  cout << s.get_i();

  return 0;
}

listing 22
#include <iostream.h>

union u_type {
  u_type(short int a);  // public by default
  void showchars();
  short int i;
  char ch[2];
};

// constructor
u_type::u_type(short int a)
{
  i = a;
}

// Show the characters that comprise an int.
void u_type::showchars()
{
  cout << ch[0] << " ";
  cout << ch[1] << "\n";
}

int main()
{
  u_type u(1000);

  u.showchars();

  return 0;
}

listing 23
#include <iostream.h>

int main()
{
  // This declares an anonymous union.
  union {  // no tag name
    int i;
    char ch[2];
  } ;  // no variables specified

  /* Now reference i and ch without referencing
     a union name or dot or arrow operators.
  */
  i = 88;
  cout << i << " " << ch[0];

  return 0;
}

listing 24
inline int f()
{
  // ...
}

listing 25
#include <iostream.h>

class cl {
  int i; 
public:
  int get_i();
  void put_i(int j);
} ;

inline int cl::get_i()
{
  return i;
}

inline void cl::put_i(int j)
{
  i = j;
}

int main()
{
  cl s;

  s.put_i(10);
  cout << s.get_i();

  return 0;
}

listing 26
#include <iostream.h>

class cl {
  int i; 
public:
  // automatic inline functions
  int get_i() { return i; }
  void put_i(int j) { i = j; }
} ;

int main()
{
  cl s;

  s.put_i(10);
  cout << s.get_i();

  return 0;
}

listing 27
class cl {
  int i; 
public:
  // automatic inline functions
  int get_i()
  {
    return i;
  }

  void put_i(int j)
  {
     i = j;
  }
} ;

listing 28
#include <iostream.h>

class myclass {
  int i;
public:
  myclass(int n);
  ~myclass();
  void set_i(int n) {i=n;}
  int get_i() {return i;}
};

myclass::myclass(int n)
{
  i = n;
  cout << "Constructing " << i << "\n";
}

myclass::~myclass()
{
  cout << "Destroying " << i << "\n";
}

void f(myclass ob);

int main()
{
  myclass o(1);

  f(o);
  cout << "This is i in main: ";
  cout << o.get_i() << "\n";

  return 0;
}

void f(myclass ob)
{
  ob.set_i(2);

  cout << "This is local i: " << ob.get_i();
  cout << "\n";
}

listing 29
#include <iostream.h>

class myclass {
  int i;
public:
  void set_i(int n) {i=n;}
  int get_i() {return i;}
};

myclass f();  // return object of type myclass

int main()
{
  myclass o;

  o = f();

  cout << o.get_i() << "\n";

  return 0;
}

myclass f()
{
  myclass x;

  x.set_i(1);
  return x;
}

listing 30
#include <iostream.h>

class myclass {
  int i;
public:
  void set_i(int n) {i=n;}
  int get_i() {return i;}
};

int main()
{
  myclass ob1, ob2;

  ob1.set_i(99);
  ob2 = ob1; // assign data from ob1 to ob2

  cout << "this is ob2's i: " << ob2.get_i();

  return 0;
}

listing 31
// An example of arrays of objects

#include <iostream.h>

enum disp_type {mono, cga, ega, vga};

class display {
  int colors;  // number of colors
  enum disp_type dt; // display type
public:
  void set_colors(int num) {colors = num;}
  int get_colors() {return colors;}
  void set_type(enum disp_type t) {dt = t;}
  enum disp_type get_type() {return dt;}
} ;

char names[4][5] = {
  "mono",
  "cga",
  "ega",
  "vga"
} ;

int main()
{
  display monitors[3];
  register int i;

  monitors[0].set_type(mono);
  monitors[0].set_colors(1);

  monitors[1].set_type(cga);
  monitors[1].set_colors(4);

  monitors[2].set_type(ega);
  monitors[2].set_colors(16);

  for(i=0; i<3; i++) {
    cout << names[monitors[i].get_type()] << " ";
    cout << "has " << monitors[i].get_colors();
    cout << " colors" << "\n";
  }

  return 0;
}

listing 32
#include <iostream.h>

class cl {
  int i;
public:
  cl(int j) {i=j;}  // constructor
  int get_i() {return i;}
};

int main()
{
  cl ob[3] = {1, 2, 3};  // initializers
  int i;

  for(i=0; i<3; i++)
    cout << ob[i].get_i() << "\n";

  return 0;
}

listing 33
#include <iostream.h>

class cl {
  int h;
  int i;
public:
  cl(int j, int k) { h=j; i=k; } // constructor
  int get_i() {return i;}
  int get_h() {return h;}
};

int main()
{
  cl ob[3] = {
    cl(1, 2),
    cl(3, 4),
    cl(5, 6)
  };  // initializers

  int i;

  for(i=0; i<3; i++) {
    cout << ob[i].get_h();
    cout << ", ";
    cout << ob[i].get_i() << "\n";
  }

  return 0;
}

listing 34
cl a[9]; // error, constructor requires initializers

listing 35
class cl {
  int i;
public:
  cl() {i=0;}  // called for non-initialized arrays
  cl(int j) {i=j;}  // called for initialized arrays
  int get_i() {return i;}
};

listing 36
cl a1[3] = {3, 5, 6}; // initialized

cl a2[34]; // uninitialized

listing 37
// A simple example using an object pointer.

#include <iostream.h>

class P_example {
  int num;
public:
  void set_num(int val) {num = val;}
  void show_num();
};

void P_example::show_num()
{
  cout << num << "\n";
}

int main()
{
  P_example ob, *p; // declare an object and pointer to it

  ob.set_num(1); // access ob directly

  ob.show_num();

  p = &ob; // assign p the address of ob
  p->show_num();  // access ob using pointer

  return 0;
}

listing 38
// Incrementing an object pointer
#include <iostream.h>

class P_example {
  int num;
public:
  void set_num(int val) {num = val;}
  void show_num();
};

void P_example::show_num()
{
  cout << num << "\n";
}

int main()
{
  P_example ob[2], *p;

  ob[0].set_num(10);  // access objects directly
  ob[1].set_num(20);

  p = &ob[0];  // obtain pointer to first element
  p->show_num(); // show value of ob[0] using pointer

  p++;  // advance to next object
  p->show_num(); // show value of ob[1] using pointer

  p--;  // retreat to previous object
  p->show_num(); // again show value of ob[0]

  return 0;
}

listing 1
#include <iostream.h>
#include <stdlib.h>
#include <time.h>

class timer{
  int seconds;
public:
  // seconds specified as a string
  timer(char *t) { seconds = atoi(t); }

  // seconds specified as integer
  timer(int t) { seconds = t; }

  // time specified in minutes and seconds
  timer(int min, int sec) { seconds = min*60 + sec; }

  void run();
} ;

void timer::run()
{
  clock_t t1, t2;

  t1 = t2 = clock()/CLK_TCK;
  while(seconds) {
    if(t1/CLK_TCK+1 <= (t2=clock())/CLK_TCK) {
       seconds--;
       t1 = t2;
    }
  }
  cout << "\a"; // ring the bell
}

int main()
{
  timer a(10), b("20"), c(1, 10);

  a.run(); // count 10 seconds
  b.run(); // count 20 seconds
  c.run(); // count 1 minute, 10 seconds

  return 0;
}

listing 2
/* Incorrect in C */
void f()
{
  int i;

  i = 10;

  int j;
  /* ... */
}

listing 3
#include <iostream.h>
#include <string.h>

int main()
{
  int i;
  i = 10;

  int j = 100; // perfectly legal in C++

  cout << i*j << "\n";

  cout << "Enter a string: ";
  char str[80];  // also legal in C++
  cin >> str;

  // display the string in reverse order
  int k;  // in C++, declare k where it is needed
  k = strlen(str);
  k--;
  while(k>=0) {
    cout << str[k];
    k--;
  }

  return 0;
}

listing 4
#include <iostream.h>
#include <stdlib.h>
#include <time.h>

class timer{
  int seconds;
public:
  // seconds specified as a string
  timer(char *t) { seconds = atoi(t); }

  // seconds specified as integer
  timer(int t) { seconds = t; }

  // time specified in minutes and seconds
  timer(int min, int sec) { seconds = min*60 + sec; }

  void run();
} ;

void timer::run()
{
  clock_t t1, t2;

  t1 = t2 = clock()/CLK_TCK;
  while(seconds) {
    if(t1/CLK_TCK+1 <= (t2=clock())/CLK_TCK) {
       seconds--;
       t1 = t2;
    }
  }
  cout << "\a"; // ring the bell
}
int main()
{
  timer a(10); 
  a.run();

  cout << "Enter number of seconds: ";
  char str[80];
  cin >> str;
  timer b(str); // initialize at runtime using a string
  b.run();

  cout << "Enter minutes and seconds: ";
  int min, sec;
  cin >> min >> sec;
  timer c(min, sec);  /* initialize at runtime
                         using minutes and seconds */
  c.run();

  return 0;
}

listing 5
int myfunc(double d);
 .
 .
 .
cout << myfunc('c');  // not an error, conversion applied

listing 6
#include <iostream.h>

float myfunc(float i);
double myfunc(double i);

int main()
{
  cout << myfunc(10.1) << " "; // unambiguous, calls myfunc(double)
  cout << myfunc(10);  // ambiguous

  return 0;
}

float myfunc(float i)
{
  return i;
}

double myfunc(double i)
{
  return -i;
}

listing 7
#include <iostream.h>

char myfunc(unsigned char ch);
char myfunc(char ch);

int main()
{
  cout << myfunc('c');  // this calls myfunc(char)
  cout << myfunc(88) << " "; // ambiguous

  return 0;
}

char myfunc(unsigned char ch)
{
  return ch-1;
}

char myfunc(char ch)
{
  return ch+1;
}

listing 8
#include <iostream.h>

int myfunc(int i);
int myfunc(int i, int j=1);

int main()
{
  cout << myfunc(4, 5) << " ";  // unambiguous
  cout << myfunc(10);  // ambiguous

  return 0;
}

int myfunc(int i)
{
  return i;
}

int myfunc(int i, int j)
{
  return i*j;
}

listing 9
p = myfunc;

listing 10
#include <iostream.h>

int myfunc(int a);
int myfunc(int a, int b);

int main()
{
  int (*fp)(int a);  // pointer to int xxx(int)

  fp = myfunc;  // points to myfunc(int)

  cout << fp(5);

  return 0;
}

int myfunc(int a)
{
  return a;
}

int myfunc(int a, int b)
{
  return a*b;
}

listing 11
int (*fp)(int a, int b);

listing 12
ob.f();

listing 13
class cl {
  int i;
  // ...
};

listing 14
i = 10;

listing 15
this->i = 10;

listing 16
#include <iostream.h>

class cl {
  int i;
public:
  void load_i(int val) { this->i = val; } // same as i = val
  int get_i() { return this->i; } // same as return i
} ;

int main()
{
  cl o;

  o.load_i(100);
  cout << o.get_i();

  return 0;
}

listing 17
#include <iostream.h>

class three_d {
  int x, y, z; // 3-d coordinates
public:
  three_d operator+(three_d t);
  three_d operator=(three_d t);

  void show() ;
  void assign(int mx, int my, int mz);
} ;

// Overload the +.
three_d three_d::operator+(three_d t)
{
  three_d temp;

  temp.x = x+t.x;
  temp.y = y+t.y;
  temp.z = z+t.z;
  return temp;
}

// Overload the =.
three_d three_d::operator=(three_d t)
{
  x = t.x;
  y = t.y;
  z = t.z;
  return *this;
}

// Show X, Y, Z coordinates.
void three_d::show()
{
  cout << x << ", ";
  cout << y << ", ";
  cout << z << "\n";
}

// Assign coordinates.
void three_d::assign(int mx, int my, int mz)
{
  x = mx;
  y = my;
  z = mz;
}

int main()
{
  three_d a, b, c;

  a.assign(1, 2, 3);
  b.assign(10, 10, 10);

  a.show();
  b.show();

  c = a+b;  // now add a and b together
  c.show();

  c = a+b+c; // add a, b and c together
  c.show();

  c = b = a;  // demonstrate multiple assignment
  c.show();
  b.show();

  return 0;
}

listing 18
temp.x = x + t.x;

listing 19
a = b = c = d;

listing 20
#include <iostream.h>

class three_d {
  int x, y, z; // 3-d coordinates
public:
  three_d operator+(three_d op2);  // op1 is implied
  three_d operator=(three_d op2);  // op1 is implied
  three_d operator++(); // op1 is also implied here

  void show() ;
  void assign(int mx, int my, int mz);
} ;

// Overload the +.
three_d three_d::operator+(three_d op2)
{
  three_d temp;

  temp.x = x+op2.x;  // these are integer additions
  temp.y = y+op2.y;  // and the + retains its original
  temp.z = z+op2.z;  // meaning relative to them
  return temp;
}

// Overload the =.
three_d three_d::operator=(three_d op2)
{
  x = op2.x; // these are integer assigments
  y = op2.y; // and the = retains its original
  z = op2.z; // meaning relative to them
  return *this;
}

// Overload a unary operator.
three_d three_d::operator++()
{
  x++;
  y++;
  z++;
  return *this;
}

// Show X, Y, Z coordinates.
void three_d::show()
{
  cout << x << ", ";
  cout << y << ", ";
  cout << z << "\n";
}

// Assign coordinates.
void three_d::assign(int mx, int my, int mz)
{
  x = mx;
  y = my;
  z = mz;
}

int main()
{
  three_d a, b, c;

  a.assign(1, 2, 3);
  b.assign(10, 10, 10);

  a.show();
  b.show();

  c = a+b;  // now add a and b together
  c.show();

  c = a+b+c; // add a, b and c together
  c.show();

  c = b = a;  // demonstrate multiple assignment
  c.show();
  b.show();

  ++c;  // increment c
  c.show();
  return 0;
}

listing 21
O++;

++O;

listing 22
loc operator++(int x);

listing 23
#include <iostream.h>

class three_d {
  int x, y, z; // 3-d coordinates
public:
  friend three_d operator+(three_d op1, three_d op2);
  three_d operator=(three_d op2);  // op1 is implied
  three_d operator++(); // op1 is implied here, too

  void show() ;
  void assign(int mx, int my, int mz);
} ;

// This is now a friend function.
three_d operator+(three_d op1, three_d op2)
{
  three_d temp;

  temp.x = op1.x + op2.x;  // these are integer additions
  temp.y = op1.y + op2.y;  // and the + retains its original
  temp.z = op1.z + op2.z;  // meaning relative to them
  return temp;
}

// Overload the =.
three_d three_d::operator=(three_d op2)
{
  x = op2.x; // these are integer assignments
  y = op2.y; // and the = retains its original
  z = op2.z; // meaning relative to them
  return *this;
}

// Overload a unary operator.
three_d three_d::operator++()
{
  x++;
  y++;
  z++;
  return *this;
}

// Show X, Y, Z coordinates.
void three_d::show()
{
  cout << x << ", ";
  cout << y << ", ";
  cout << z << "\n";
}

// Assign coordinates.
void three_d::assign(int mx, int my, int mz)
{
  x = mx;
  y = my;
  z = mz;
}
int main()
{
  three_d a, b, c;

  a.assign(1, 2, 3);
  b.assign(10, 10, 10);

  a.show();
  b.show();

  c = a+b;  // now add a and b together
  c.show();

  c = a+b+c; // add a, b and c together
  c.show();

  c = b = a;  // demonstrate multiple assignment
  c.show();
  b.show();

  ++c;  // increment c
  c.show();

  return 0;
}

listing 24
O = O + 10; // will work

listing 25
O = 10 + O; // won't work

listing 26
#include <iostream.h>

class CL {
public:
  int count;
  CL operator=(int i);
  friend CL operator+(CL ob, int i);
  friend CL operator+(int i, CL ob);
};

CL CL::operator=(int i)
{
  count = i;
  return *this;
}

// This handles ob + int.
CL operator+(CL ob, int i)
{
  CL temp;

  temp.count = ob.count + i;
  return temp;
}

// This handles int + ob.
CL operator+(int i, CL ob)
{
  CL temp;

  temp.count = ob.count + i;
  return temp;
}

int main()
{
  CL obj;
  obj = 10;
  cout << obj.count << " "; // outputs 10

  obj = 10 + obj; // add object to integer
  cout << obj.count << " "; // outputs 20

  obj = obj + 12; // add integer to object
  cout << obj.count;        // outputs 32

  return 0;
}

listing 27
#include <iostream.h>

void swap(int *a, int *b);

int main()
{
  int x, y;

  x = 99;
  y = 88;

  cout << x << " " << y << "\n";

  swap(&x, &y); // exchange their values

  cout << x << " " << y << "\n";

  return 0;
}

// C-like, explicit pointer version of swap().
void swap(int *a, int *b)
{
  int t;

  t = *a;
  *a = *b;
  *b = t;
}

listing 28
void f(int &f)
{
  f = rand(); // this modifies the calling argument
}

listing 29
f = rand() ;

listing 30
int val;

f(val);  // get random value
printf("%d", val);

listing 31
#include <iostream.h>

void swap(int &a, int &b); // declare as reference parameters

int main()
{
  int x, y;

  x = 99;
  y = 88;

  cout << x << " " << y << "\n";

  swap(x, y); // exchange their values

  cout << x << " " << y << "\n";

  return 0;
}

/* Here, swap() is defined as using call-by-reference,
   not call-by-value. */
void swap(int &a, int &b)
{
  int t;

  t = a;
  a = b;  // this swaps x
  b = t;  // this swaps y
}

listing 32
#include <iostream.h>

class cl {
  int id;
public:
  int i;
  cl(int i);
  ~cl();
  void neg(cl &o) {o.i = -o.i;} 
};

cl::cl(int num)
{
  cout << "Constructing " << num << "\n";
  id = num;
}

cl::~cl()
{
  cout << "Destructing " << id << "\n";
}

int main()
{
  cl o(1);

  o.i = 10;
  o.neg(o);

  cout << o.i << "\n";

  return 0;
}

listing 33
Constructing 1
-10
Destructing 1

listing 34
#include <iostream.h>

char &replace(int i);  // return a reference

char s[80] = "Hello There";

int main()
{

  replace(5) = 'X'; // assign X to space after Hello

  cout << s;

  return 0;
}

char &replace(int i)
{
  return s[i];
}

listing 35
#include <iostream.h>

int main()
{
  int j, k;
  int &i = j; // independent reference to j

  j = 10;

  cout << j << " " << i; // outputs 10 10

  k = 121;
  i = k; // copies k's value into j -- not k's address

  cout << "\n" << j;  // outputs 121

  return 0;
}

listing 36
int &i = 100;

listing 37
int& p; // & associated with type
int &p; // & associated with variable

listing 38
int* a, b;

listing 39
// Overload a unary operator.
three_d three_d::operator++()
{
  x++;
  y++;
  z++;
  return *this;
}

listing 40
// THIS WILL NOT WORK
three_d operator++(three_d op1)
{
 op1.x++;
 op1.y++;
 op1.z++;
 return op1;
}

listing 41
// This version uses a friend operator++() function.
#include <iostream.h>

class three_d {
  int x, y, z; // 3-d coordinates
public:
  friend three_d operator+(three_d op1, three_d op2);
  three_d operator=(three_d op2);  // op1 is implied
  // use a reference to overload the ++
  friend three_d operator++(three_d &op1);

  void show() ;
  void assign(int mx, int my, int mz);
} ;

// This is now a friend function.
three_d operator+(three_d op1, three_d op2)
{
  three_d temp;

  temp.x = op1.x + op2.x;  // these are integer additions
  temp.y = op1.y + op2.y;  // and the + retains its original
  temp.z = op1.z + op2.z;  // meaning relative to them
  return temp;
}

// Overload the =.
three_d three_d::operator=(three_d op2)
{
  x = op2.x; // these are integer assigments
  y = op2.y; // and the = retains its original
  z = op2.z; // meaning relative to them
  return *this;
}

/* Overload a unary operator using a friend function.
   This requires the use of a reference parameter. */
three_d operator++(three_d &op1)
{
  op1.x++;
  op1.y++;
  op1.z++;
  return op1;
}

// Show X, Y, Z coordinates.
void three_d::show()
{
  cout << x << ", ";
  cout << y << ", ";
  cout << z << "\n";
 }

// Assign coordinates.
void three_d::assign(int mx, int my, int mz)
{
  x = mx;
  y = my;
  z = mz;
}

int main()
{
  three_d a, b, c;
  a.assign(1, 2, 3);
  b.assign(10, 10, 10);

  a.show();
  b.show();

  c = a+b;  // now add a and b together
  c.show();

  c = a+b+c; // add a, b and c together
  c.show();

  c = b = a;  // demonstrate multiple assignment
  c.show();
  b.show();

  ++c;  // increment c
  c.show();

  return 0;
}

listing 42
O[3]

listing 43
operator[](3)

listing 44
#include <iostream.h>

class atype {
  int a[3];
public:
  atype(int i, int j, int k) {
    a[0] = i;
    a[1] = j;
    a[2] = k;
  }
  int operator[](int i) {return a[i];}
};

int main()
{
  atype ob(1, 2, 3);

  cout << ob[1];  // displays 2

  return 0;
}

listing 45
#include <iostream.h>

class atype {
  int a[3];
public:
  atype(int i, int j, int k) {
    a[0] = i;
    a[1] = j;
    a[2] = k;
  }
  int &operator[](int i) {return a[i];}
};

int main()
{
  atype ob(1, 2, 3);

  cout << ob[1];  // displays 2
  cout << " ";

  ob[1] = 25;  // [] on left of =

  cout << ob[1];  // now displays 25

  return 0;
}

listing 46
// A safe array example.
#include <iostream.h>
#include <stdlib.h>

class atype {
  int a[3];
public:
  atype(int i, int j, int k) {
    a[0] = i;
    a[1] = j;
    a[2] = k;
  }
  int &operator[](int i);
};

// Provide range checking for atype.
int &atype::operator[](int i)
{
  if(i<0 || i> 2) {
    cout << "Boundary Error\n";
    exit(1);
  }
  return a[i];
}

int main()
{
  atype ob(1, 2, 3);

  cout << ob[1];  // displays 2
  cout << " ";

  ob[1] = 25;  // [] appears on left
  cout << ob[1];  // displays 25

  ob[3] = 44; // generates runtime error, 3 out-of-range
  return 0;
}

listing 47
ob[3] = 44;

listing 48
#include <iostream.h>
#include <string.h>

class str_type {
  char string[80];
public:
  str_type(char *str = "\0") { strcpy(string, str); }


  str_type operator+(str_type str); // concatenate
  str_type operator=(str_type str); // assign

  // output the string
  void show_str() { cout << string; }
} ;

listing 49
// Concatenate two strings.
str_type str_type::operator+(str_type str) {
  str_type temp;

  strcpy(temp.string, string);
  strcat(temp.string, str.string);
  return temp;
}

// Assign one string to another.
str_type str_type::operator=(str_type str) {
  strcpy(string, str.string);
  return *this;
}

listing 50
int main()
{
  str_type a("Hello "), b("There"), c;

  c = a + b;

  c.show_str();

  return 0;
}

listing 51
a = "this is currently wrong";

listing 52
class str_type {
  char string[80];
public:
  str_type(char *str = "\0") { strcpy(string, str); }

  str_type operator+(str_type str); // concatenate objects
  str_type operator+(char *str);  /* concatenate object with
                                     a string */

  str_type operator=(str_type str); /* assign object to
                                       object */
  char *operator=(char *str); // assign string to object

  void show_str() { cout << string; }
} ;

listing 53
// Assign a string to an object.
str_type str_type::operator=(char *str)
{
  str_type temp;

  strcpy(string, str);
  strcpy(temp.string, string);
  return temp;
}

// Add a string to an object.
str_type str_type::operator+(char *str)
{
  str_type temp;

  strcpy(temp.string, string);
  strcat(temp.string, str);
  return temp;
}

listing 54
str_type a, b, c;

a = "hi there";  // assign an object a string

c = a + " George";  // concatenate an object with a string

listing 55
// Expanding the string type.
#include <iostream.h>
#include <string.h>

class str_type {
  char string[80];
public:
  str_type(char *str = "\0") { strcpy(string, str); }

  str_type operator+(str_type str);
  str_type operator+(char *str);

  str_type operator=(str_type str);
  str_type operator=(char *str);

  void show_str() { cout << string; }
} ;

str_type str_type::operator+(str_type str) {
  str_type temp;

  strcpy(temp.string, string);
  strcat(temp.string, str.string);
  return temp;
}

str_type str_type::operator=(str_type str) {
  strcpy(string, str.string);
  return *this;
}

str_type str_type::operator=(char *str)
{
  str_type temp;

  strcpy(string, str);
  strcpy(temp.string, string);
  return temp;
}

str_type str_type::operator+(char *str)
{
  str_type temp;

  strcpy(temp.string, string);
  strcat(temp.string, str);
  return temp;
}

int main()
{
  str_type a("Hello "), b("There"), c;

  c = a + b;

  c.show_str();
  cout << "\n";

  a = "to program in because";
  a.show_str();
  cout << "\n";

  b = c = "C++ is fun";

  c = c+" "+a+" "+b;
  c.show_str();

  return 0;
}

listing 1
class X {
  int i;
  int j;
public:
  void get_ij();
  void put_ij();
} ;

class Y : public X {
  int k;
public:
  int get_k();
  void make_k();
} ;

listing 2
class X {
protected:
  int i;
  int j;
public:
  void get_ij();
  void put_ij();
} ;

class Y : public X {
  int k;
public:
  int get_k();
  void make_k();
} ;

listing 3
class my_class {
protected:
  int i;
  int j;
public:
  void f1();
  void f2();
protected:
  int a;
public:
  int b;
} ;

listing 4
#include <iostream.h>

class X {
protected:
  int i;
  int j;
public:
  void get_ij() {
    cout << "Enter two numbers: ";
    cin >> i >> j;
  }
  void put_ij() { cout << i << " " << j << "\n"; }
} ;

// In Y, i and j of X become protected members.
class Y : public X {
  int k;
public:
  int get_k() { return k; }
  void make_k() { k = i*j; }
} ;

/* Z has access to i and j of X, but not to
   k of Y, since it is private. */
class Z : public Y {
public:
  void f();
} ;

// i and j are accessible here
void Z::f()
{
  i = 2; // ok
  j = 3; // ok
}

int main()
{
  Y var;
  Z var2;

  var.get_ij();
  var.put_ij();

  var.make_k();
  cout << var.get_k();
  cout << "\n";

  var2.f();
  var2.put_ij();

  return 0;
}

listing 5
#include <iostream.h>

class X {
protected:
  int i;
  int j;
public:
  void get_ij() {
    cout << "Enter two numbers: ";
    cin >> i >> j;
  }
  void put_ij() { cout << i << " " << j << "\n"; }
} ;

// Now, i and j are converted to private members of Y.
class Y : private X {
  int k;
public:
  int get_k() { return k; }
  void make_k() { k = i*j; }
} ;

/* Because i and j are private in Y, they
   may not be inherited by Z. */
class Z : public Y {
public:
  void f();
} ;

// This function no longer works.
void Z::f()
{
//  i = 2;  i and j are no longer accessible
//  j = 3;
}

int main()
{
  Y var;
  Z var2;

//  var.get_ij();  no longer accessible
//  var.put_ij();  no longer accessible

  var.make_k();
  cout << var.get_k();
  cout << "\n";

  var2.f();
//  var2.put_ij();  no longer accessible

  return 0;
}

listing 6
#include <iostream.h>

class Base {
public:
  Base() {cout << "\nBase created\n";}
};

class D_class1 : public Base {
public:
  D_class1() {cout << "D_class1 created\n";}
};

int main()
{
  D_class1 d1;

  // do nothing but execute constructors
  return 0;
}

listing 7
#include <iostream.h>

class Base {
public:
  Base() {cout << "\nBase created\n";}
  ~Base() {cout << "Base destroyed\n\n";}
};

class D_class1 : public Base {
public:
  D_class1() {cout << "D_class1 created\n";}
  ~D_class1() {cout << "D_class1 destroyed\n";}
};

int main()
{
  D_class1 d1;

  cout << "\n";

  return 0;
}

listing 8
#include <iostream.h>

class Base {
public:
  Base() {cout << "\nBase created\n";}
  ~Base() {cout << "Base destroyed\n\n";}
};

class D_class1 : public Base {
public:
  D_class1() {cout << "D_class1 created\n";}
  ~D_class1() {cout << "D_class1 destroyed\n";}
};

class D_class2 : public D_class1 {
public:
  D_class2() {cout << "D_class2 created\n";}
  ~D_class2() {cout << "D_class2 destroyed\n";}
};

int main()
{
  D_class1 d1;
  D_class2 d2;

  cout << "\n";

  return 0;
}

listing 9
#include <iostream.h>

class X {
protected:
  int a;
public:
  void make_a(int i) { a = i; }
};

class Y {
protected:
  int b;
public:
  void make_b(int i) { b = i; }
} ;

// Z inherits both X and Y
class Z : public X, public Y {
public:
  int make_ab() { return a*b; }
} ;

int main()
{
  Z i;

  i.make_a(10);
  i.make_b(12);
  cout << i.make_ab();

  return 0;
}

listing 10
#include <iostream.h>

class X {
protected:
  int a;
public:
  X() {
    a = 10;
    cout << "Initializing X\n";
  }
};

class Y {
protected:
  int b;
public:
  Y() {
    cout << "Initializing Y\n";
    b = 20;
  }
} ;

// Z inherits both X and Y
class Z : public X, public Y {
public:
  Z() { cout << "Initializing Z\n"; }
  int make_ab() { return a*b; }
} ;

int main()
{
  Z i;

  cout << i.make_ab();

  return 0;
}

listing 11
#include <iostream.h>

class X {
protected:
  int a;
public:
  X(int i) { a = i; }
};

class Y {
protected:
  int b;
public:
  Y(int i) { b = i; }
} ;

// Z inherits both X and Y
class Z : public X, public Y {
public:
  /* Initialize X and Y via Z's constructor.
     Notice that Z does not actually use x or y
     itself, but it could, if it so chooses. */
  Z(int x, int y) : X(x), Y(y)
  {
    cout << "Initializing\n";
  }
  int make_ab() { return a*b; }
} ;

int main()
{
  Z i(10, 20);

  cout << i.make_ab();

  return 0;
}

listing 12
B_class *p; // pointer to object of type B_class
B_class B_ob; // object of type B_class
D_class D_ob; // object of type D_class

listing 13
p = &B_ob; // p points to object of type B_class

p = &D_ob; /* p points to object of type D_class,
              which is an object derived from B_class. */

listing 14
// Using pointers on derived class objects.

#include <iostream.h>
#include <string.h>

class B_class {
  char name[80];
public:
  void put_name(char *s) {strcpy(name, s); }
  void show_name() {cout << name << " ";}
} ;

class D_class : public B_class {
  char phone_num[80];
public:
  void put_phone(char *num) {
    strcpy(phone_num, num);
  }
  void show_phone() {cout << phone_num << "\n";}
};

int main()
{
  B_class *p;
  B_class B_ob;

  D_class *dp;
  D_class D_ob;

  p = &B_ob;  // address of base

  // Access B_class via pointer.
  p->put_name("Thomas Edison");

  // Access D_class via base pointer.
  p = &D_ob;
  p->put_name("Albert Einstein");

  // Show that each name went into proper object.
  B_ob.show_name();
  D_ob.show_name();
  cout << "\n";

  /* Since put_phone and show_phone are not part of the
     base class, they are not accessible via the base
     pointer p and must be accessed either directly,
     or, as shown here, through a pointer to the
     derived type.
  */
  dp = &D_ob;
  dp->put_phone("555 555-1234");
  p->show_name(); // either p or dp can be used in this line
  dp->show_phone();
  return 0;
}

listing 15
((D_class *)p)->show_phone();

listing 16
// A short example that uses virtual functions.
#include <iostream.h>

class Base {
public:
  virtual void who() { // specify a virtual function
    cout << "Base\n";
  }
};

class first_d : public Base {
public:
  void who() { // define who() relative to first_d
    cout << "First derivation\n";
  }
};

class second_d : public Base {
public:
  void who() { // define who() relative to second_d
    cout << "Second derivation\n";
  }
};

int main()
{
  Base base_obj;
  Base *p;
  first_d first_obj;
  second_d second_obj;

  p = &base_obj;
  p->who();  // access Base's who

  p = &first_obj;
  p->who(); // access first_d's who

  p = &second_obj;
  p->who();  // access second_d's who

  return 0;
}

listing 17
/* Here, a base class reference is used to access
   a virtual function. */
#include <iostream.h>

class Base {
public:
  virtual void who() { // specify a virtual function
    cout << "Base\n";
  }
};

class first_d : public Base {
public:
  void who() { // define who() relative to first_d
    cout << "First derivation\n";
  }
};

class second_d : public Base {
public:
  void who() { // define who() relative to second_d
    cout << "Second derivation\n";
  }
};

// Use a base class reference parameter.
void show_who(Base &r) {
  r.who();
}

int main()
{
  Base base_obj;
  first_d first_obj;
  second_d second_obj;

  show_who(base_obj); // access Base's who

  show_who(first_obj); // access first_d's who

  show_who(second_obj); // access second_d's who

  return 0;
}

listing 18
// Derive from first_d, not Base
class second_d : public first_d {
public:
  void who() { // define who() relative to second_d
    cout << "Second derivation\n";
  }
};

listing 19
#include <iostream.h>

class Base {
public:
  virtual void who() {
    cout << "Base\n";
  }
};

class first_d : public Base {
public:
  void who() {
    cout << "First derivation\n";
  }
};

class second_d : public Base {
// who() not defined
};

int main()
{
  Base base_obj;
  Base *p;
  first_d first_obj;
  second_d second_obj;

  p = &base_obj;
  p->who();  // access Base's who()

  p = &first_obj;
  p->who(); // access first_d's who()

  p = &second_obj;
  p->who();  /* access Base's who() because
                second_d does not redefine it */

  return 0;
}

listing 20
#include <iostream.h>

class figure {
protected:
  double x, y;
public:
  void set_dim(double i, double j) {
    x = i;
    y = j;
  }
  virtual void show_area() {
    cout << "No area computation defined ";
    cout << "for this class.\n";
  }
} ;

class triangle : public figure {
  public:
    void show_area() {
      cout << "Triangle with height ";
      cout << x << " and base " << y;
      cout << " has an area of ";
      cout << x * 0.5 * y << ".\n";
    }
};

class square : public figure {
  public:
    void show_area() {
      cout << "Square with dimensions ";
      cout << x << "x" << y;
      cout << " has an area of ";
      cout << x *  y << ".\n";
    }
};

int main()
{
  figure *p;  /* create a pointer to base type */

  triangle t;  /* create objects of derived types */
  square s;

  p = &t;
  p->set_dim(10.0, 5.0);
  p->show_area();
  p = &s;
  p->set_dim(10.0, 5.0);
  p->show_area();

  return 0;
}

listing 21
class circle : public figure {
  public:
    void show_area() {
      cout << "Circle with radius ";
      cout << x;
      cout << " has an area of ";
      cout <<  3.14 * x * x;
    }
} ;

listing 22
#include <iostream.h>

class figure {
protected:
  double x, y;
public:
  void set_dim(double i, double j=0) {
    x = i;
    y = j;
  }
  virtual void show_area() {
    cout << "No area computation defined ";
    cout << "for this class.\n";
  }
} ;

class triangle : public figure {
  public:
    void show_area() {
      cout << "Triangle with height ";
      cout << x << " and base " << y;
      cout << " has an area of ";
      cout << x * 0.5 * y << ".\n";
    }
};

class square : public figure {
  public:
    void show_area() {
      cout << "Square with dimensions ";
      cout << x << "x" << y;
      cout << " has an area of ";
      cout << x *  y << ".\n";
    }
};

class circle : public figure {
  public:
    void show_area() {
      cout << "Circle with radius ";
      cout << x;
      cout << " has an area of ";
      cout << 3.14 * x * x;
    }
} ;

int main()
{
  figure *p;  /* create a pointer to base type */
  triangle t;  /* create objects of derived types */
  square s;
  circle c;

  p = &t;
  p->set_dim(10.0, 5.0);
  p->show_area();

  p = &s;
  p->set_dim(10.0, 5.0);
  p->show_area();

  p = &c;
  p->set_dim(9.0);
  p->show_area();

  return 0;
}

listing 23
class figure {
  double x, y;
public:
  void set_dim(double i, double j=0) {
    x = i;
    y = j;
  }
  virtual void show_area() = 0; // pure
} ;

listing 24
/*
   This program will not compile because the class
   circle does not override show_area().
*/
#include <iostream.h>

class figure {
protected:
  double x, y;
public:
  void set_dim(double i, double j) {
    x = i;
    y = j;
  }
  virtual void show_area() = 0; // pure
} ;

class triangle : public figure {
  public:
    void show_area() {
      cout << "Triangle with height ";
      cout << x << " and base " << y;
      cout << " has an area of ";
      cout << x * 0.5 * y << ".\n";
    }
};

class square : public figure {
  public:
    void show_area() {
      cout << "Square with dimensions ";
      cout << x << "x" << y;
      cout << " has an area of ";
      cout << x *  y << ".\n";
    }
};

class circle : public figure {
// no definition of show_area() will cause an error
};

int main()
{
  figure *p;  // create a pointer to base type 
  circle c; // attempt to create an object of type circle -- ERROR
  triangle t;  // create objects of derived types */
  square s;

  p = &t;
  p->set_dim(10.0, 5.0);
  p->show_area();

  p = &s;
  p->set_dim(10.0, 5.0);
  p->show_area();

  return 0;
}

listing 1
struct my_struct {
  int count;
  char s[80];
  double balance;
} ;

listing 2
char str[80];
int i;

scanf("%d%s", str, &i);

listing 3
class three_d {
public:
  int x, y, z; // 3-d coordinates
  three_d(int a, int b, int c) {x=a; y=b; z=c;}
} ;

listing 4
// Display X, Y, Z coordinates (three_d's inserter).
ostream &operator<<(ostream &stream, three_d obj)
{
  stream << obj.x << ", ";
  stream << obj.y << ", ";
  stream << obj.z << "\n";
  return stream; // return the stream
}

listing 5
#include <iostream.h>

class three_d {
public:
  int x, y, z; // 3-d coordinates
  three_d(int a, int b, int c) {x=a; y=b; z=c;}
} ;

// Display X, Y, Z coordinates - three_d inserter.
ostream &operator<<(ostream &stream, three_d obj)
{
  stream << obj.x << ", ";
  stream << obj.y << ", ";
  stream << obj.z << "\n";
  return stream;  // return the stream
}

int main()
{
  three_d a(1, 2, 3), b(3, 4, 5), c(5, 6, 7);

  cout << a << b << c;

  return 0;
}

listing 6
// Limited version - don't use.
ostream &operator<<(ostream &stream, three_d obj)
{
  cout << obj.x << ", ";
  cout << obj.y << ", ";
  cout << obj.z << "\n";
  return stream;  // return the stream
}

listing 7
#include <iostream.h>

class three_d {
  int x, y, z; // 3-d coordinates - - now private
public:
  three_d(int a, int b, int c) {x=a; y=b; z=c;}
  friend ostream &operator<<(ostream &stream, three_d obj);
} ;

// Display X, Y, Z coordinates - three_d inserter.
ostream &operator<<(ostream &stream, three_d obj)
{
  stream << obj.x << ", ";
  stream << obj.y << ", ";
  stream << obj.z << "\n";
  return stream;  // return the stream
}

int main()
{
  three_d a(1, 2, 3), b(3, 4, 5), c(5, 6, 7);

  cout << a << b << c;

  return 0;
}

listing 8
// Get three dimensional values - extractor.
istream &operator>>(istream &stream, three_d &obj)
{
  cout << 
    "Enter X Y Z values, separating each with a space: ";
  stream >> obj.x >> obj.y >> obj.z;
  return stream;
}

listing 9
#include <iostream.h>

class three_d {
  int x, y, z; // 3-d coordinates
public:
  three_d(int a, int b, int c) {x=a; y=b; z=c;}
  friend ostream &operator<<(ostream &stream, three_d obj);
  friend istream &operator>>(istream &stream, three_d &obj);
} ;

// Display X, Y, Z coordinates - inserter.
ostream &operator<<(ostream &stream, three_d obj)
{
  stream << obj.x << ", ";
  stream << obj.y << ", ";
  stream << obj.z << "\n";
  return stream; // return the stream
}

// Get three dimensional values - extractor.
istream &operator>>(istream &stream, three_d &obj)
{
  cout << 
    "Enter X Y Z values, separating each with a space: ";
  stream >> obj.x >> obj.y >> obj.z;
  return stream;
}

int main()
{
  three_d a(1, 2, 3);

  cout << a;

  cin >> a;
  cout << a;

  return 0;
}

listing 10
stream.setf(ios::showbase);

listing 11
#include <iostream.h>

int main()
{
  cout.setf(ios::showpos);
  cout.setf(ios::scientific);
  cout << 123 << " " << 123.23 << " ";

  return 0;
}

listing 12
cout.setf(ios::scientific | ios::showpos);

listing 13
#include <iostream.h>

void showflags (long f);

int main ()
{
  long f;

  f = cout.flags();

  showflags(f);
  cout.setf(ios::showpos);
  cout.setf(ios::scientific);

  f = cout.flags();
  showflags(f);

  cout.unsetf(ios::scientific);

  f = cout.flags();
  showflags(f);

  return 0;
}

void showflags(long f)
{
  long i;

  for(i=0x8000; i; i = i >> 1)
    if(i & f) cout << "1 ";
    else cout << "0 ";

  cout << "\n";
}

listing 14
#include <iostream.h>

int main()
{
  cout.setf(ios::showpos);
  cout.setf(ios::scientific);
  cout << 123 << " " << 123.23 << "\n";

  cout.precision(2); // two digits after decimal point
  cout.width(10);  // in a field of ten characters
  cout << 123 << " " << 123.23 << "\n";

  cout.fill('#');  // fill using #
  cout.width(10);  // in a field of ten characters
  cout << 123 << " " << 123.23;

  return 0;
}

listing 15
#include <iostream.h>
#include <iomanip.h>

int main()
{
  cout << setiosflags(ios::fixed);
  cout << setprecision(2) << 1000.243 << endl;
  cout << setw(20) << "Hello there.";

  return 0;
}

listing 16
#include <iostream.h>
#include <iomanip.h>

main()
{
  cout << setiosflags(ios::showpos);
  cout << setiosflags(ios::scientific);
  cout << 123 << " " << 123.23;

  return 0;
}

listing 17
#include <iostream.h>

int main()
{
  char s[80];

  cin >> ws >> s;
  cout << s;
}

listing 18
#include <iostream.h>
#include <iomanip.h>

ostream &setup(ostream &stream)
{
  stream.setf(ios::left);
  stream << setw(10) << setfill('$');
  return stream;
}

int main()
{
  cout << 10 << " " << setup << 10;

  return 0;
}

listing 19
#include <iostream.h>
#include <iomanip.h>

istream &prompt(istream &stream)
{
  cin >> hex;
  cout << "Enter number using hex format: ";

  return stream;
}

int main()
{
  int i;

  cin >> prompt >> i;
  cout << i;

  return 0;
}

listing 20
#include <iostream.h>
#include <iomanip.h>

// Indent length number of spaces.
ostream &indent(ostream &stream, int length)
{
  register int i;

  for(i=0; i<length; i++) cout << " ";
  return stream;
}

omanip<int> indent(int length)
{
  return omanip<int>(indent, length);
}

int main()
{
  cout << indent(10) << "This is a test\n";
  cout << indent(20) << "of the indent manipulator.\n";
  cout << indent(5) << "It works!\n";

  return 0;
}

listing 21
#include <iostream.h>
#include <iomanip.h>

ostream &dollars(ostream &stream, double amount)
{
  stream.setf(ios::showpoint);
  stream << "$" << setw(10) << setprecision(2)  << amount;

  return stream;
}

omanip <double> dollars(double amount) {
  return omanip<double> (dollars, amount);
}

int main()
{
  cout << dollars(123.123456);
  cout << "\n" << dollars(10.0);
  cout << "\n" << dollars(1234.23);
  cout << "\n" << dollars(0.0);

  return 0;
}


listing 22
// This program uses a manipulator to input a password.
#include <iostream.h>
#include <iomanip.h>
#include <string.h>
#include <stdlib.h>

char *password="IlikeC++";
char pw[80];

// Input a password
istream &getpass(istream &stream, int tries)
{
  do {
    cout << "Enter password: ";
    stream >> pw;
    if(!strcmp(password, pw)) return stream;
    cout << "\a"; // bell
    tries--;
  } while(tries>0);

  cout << "All tries failed!\n";
  exit(1) ; // didn't enter password
  
  return stream;
}

imanip<int> getpass(int tries) {
  return imanip<int>(getpass, tries);
}

int main()
{
  // give 3 tries to enter password
  cin >> getpass(3);
  cout << "Login Complete!\n";

  return 0;
}

listing 23
ifstream in;  // input

ofstream out; // output

fstream both; // input and output

listing 24
ofstream out;
out.open("test", ios::out, 0);

listing 25
out.open("test");  // defaults to output and normal file

listing 26
fstream mystream;
mystream.open("test", ios::in | ios::out);

listing 27
ifstream  mystream("myfile"); // open file for input

listing 28
ifstream  mystream("myfile"); // open file for input
if(!mystream) {
  cout << "Cannot open file.\n";
  //  process error
}

listing 29
mystream.close();

listing 30
#include <iostream.h>
#include <fstream.h>

int main()
{
  ofstream out("test");
  if(!out) {
    cout << "Cannot open file.\n";
    return 1;
    }

  out << 10 << " " << 123.23 << "\n";
  out << "This is a short text file.\n";

  out.close();

  return 0;
}

listing 31
#include <iostream.h>
#include <fstream.h>

int main()
{
  char ch;
  int i;
  float f;
  char str[80];

  ifstream in("test");
  if(!in) {
    cout << "Cannot open file.\n";
    return 1;
  }

  in >> i;
  in >> f;
  in >> ch;
  in >> str;

  cout << i << " " << f << " " << ch << "\n";
  cout << str;

  in.close();
  return 0;
}

listing 32
#include <iostream.h>
#include <fstream.h>

int main(int argc, char *argv[])
{
  char ch;

  if(argc!=2) {
    cout << "Usage: PR <filename>\n";
    return 1;
  }

  ifstream in(argv[1], ios::in | ios::binary);
  if(!in) {
    cout << "Cannot open file.\n";
    return 1;
  }

  while(in) { // in will be null when eof is reached
    in.get(ch);
    cout << ch;
  }

  in.close();

  return 0;
}

listing 33
while(in.get(ch))
  cout << ch;

listing 34
#include <iostream.h>
#include <fstream.h>

int main()
{
  char *p = "hello there\n\r\xfe\xff";

  ofstream out("test", ios::out | ios::binary);
  if(!out) {
    cout << "Cannot open file.\n";
    return 1;
   }

  while(*p) out.put(*p++);

  out.close();

  return 0;
}

listing 35
#include <iostream.h>
#include <fstream.h>

int main()
{
  int n[5] = {1, 2, 3, 4, 5};
  register int i;

  ofstream out("test", ios::out | ios::binary);
  if(!out) {
    cout << "Cannot open file.\n";
    return 1;
   }

  out.write((unsigned char *) &n, sizeof n);

  out.close();

  for(i=0; i<5; i++) // clear array
    n[i] = 0;

  ifstream in("test", ios::in | ios::binary);
  in.read((unsigned char *) &n, sizeof n);

  for(i=0; i<5; i++) // show values read from file
    cout << n[i] << " ";

  in.close();

  return 0;
}

listing 36
#include <iostream.h>
#include <fstream.h>
#include <stdlib.h>

int main(int argc, char *argv[])
{
  if(argc!=3) {
    cout << "Usage: CHANGE <filename> <byte>\n";
    return 1;
  }

  fstream out(argv[1], ios::in | ios::out | ios::binary);
  if(!out) {
    cout << "Cannot open file.\n";
    return 1;
  }

  out.seekp(atoi(argv[2]), ios::beg);

  out.put('X');
  out.close();

  return 0;
}

listing 37
#include <iostream.h>
#include <fstream.h>
#include <stdlib.h>

int main(int argc, char *argv[])
{
  char ch;

  if(argc!=3) {
    cout << "Usage: NAME <filename> <starting location>\n";
    return 1;
  }

  ifstream in(argv[1], ios::in | ios::binary);
  if(!in) {
    cout << "Cannot open file.\n";
    return 1;
  }

  in.seekg(atoi(argv[2]), ios::beg);

  while(in.get(ch))
    cout << ch;

  in.close();

  return 0;
}

listing 1
#include <strstrea.h>
#include <iostream.h>

int main()
{
  char str[80];
  int a = 10;

  ostrstream outs(str, sizeof(str));

  outs << "Hello there ";
  outs << a+44 << hex << " ";
  outs.setf(ios::showbase);
  outs << 100 << ends;

  cout << str;  // display string on console

  return 0;
}

listing 2
#include <stdio.h>

int main()
{
  char str[80];
  int a = 10;

  sprintf(str, "Hello there %d %#x", a+44, 100);

  printf(str);

  return 0;
}

listing 3
#include <strstrea.h>
#include <iostream.h>

int main()
{
  char str[80];

  ostrstream outs(str, sizeof(str));

  outs << "Hello ";
  outs << 34 << " " << 1234.23;
  outs << ends;  // null terminate

  cout << outs.pcount(); // display how many chars in outs

  cout << " " << str;

  return 0;
}

listing 4
#include <iostream.h>
#include <strstrea.h>

int main()
{
  char s[] = "One 2 3.00";

  istrstream ins(s);

  int i;
  char str[80];
  float f;

  // reading: one 2
  ins >> str;
  ins >> i;
  cout << str << " " << i << endl;

  // reading 3.00
  ins >> f;
  cout << f <<  '\n' ;

  return 0;
}

listing 5
/* This program shows how to read the contents of any
   null-terminated array. */
#include <iostream.h>
#include <strstrea.h>

int main()
{
  char s[] = "C++ arrays are fun! 123.23 0x23\n";

  istrstream ins(s);

  char ch;

  // This will read and display the contents of an array. 
  ins.unsetf(ios::skipws); // don't skip spaces
  while (ins) {  // null when end of array is reached
    ins >> ch;
    cout << ch;
  }

  return 0;
}

listing 6
#include <iostream.h>
#include <strstrea.h>

int main()
{
  char s[] = "This is a test array\23\22\21\a\t\n";

  istrstream ins(s);

  char ch;

  // This will read the contents of any type of array.
  while (!ins.eof()) {
    ins.get(ch);
    cout << ch;
  }

  return 0;
}

listing 7
// Perform both input and output.
#include <iostream.h>
#include <strstrea.h>

int main()
{
  char iostr[80];

  strstream ios(iostr, sizeof(iostr), ios::in | ios::out);

  int a, b;
  char str[80];
  
  ios << "1734 534abcdefghijklmnopqrstuvwxyz";
  ios >> a >> b >> str;
  cout << a << " " << b << " " << str << endl;

}

listing 8
#include <iostream.h>
#include <strstrea.h>

int main()
{
  char iostr[80];

  strstream ios(iostr, sizeof(iostr), ios::in | ios::out);

  char ch;
  
  ios << "abcdefghijklmnopqrstuvwxyz";
  ios.seekg(7, ios::beg);
  ios >> ch;
  cout << "Character at 7: " << ch;

  return 0;
}

listing 9
#include <strstrea.h>

#include <iostream.h>

main()
{
  char *p;

  ostrstream outs;  // dynamically allocate array

  outs << "I like C++ ";
  outs << -10 << hex << " ";
  outs.setf(ios::showbase);
  outs << 100 << ends;

  p = outs.str(); /* Freeze dynamic buffer and return 
                     pointer to it. */
  
  cout << p;

  delete p;  // Free dynamic buffer created by ostrstream().
  return 0;
}

listing 10
/* This program uses a custom manipulator with 
   array-based I/O. */

#include <strstrea.h>
#include <iostream.h>
#include <iomanip.h>

// Custom output manipulator.
ostream &setup(ostream &stream)
{
  stream.setf(ios::left);
  stream << setw(10) << setfill('$');
  return stream;
}


int main()
{
  char str[80];

  ostrstream outs(str, sizeof(str));

  outs << setup << 99 << ends;

  cout << str  << '\n';

  return 0;
}

listing 11
#include <iostream.h>
#include <strstrea.h>

const int size=5;

class plot {
  int x, y;
public:
  plot(int i, int j) {
    // For simplicity, restrict x and y to 0 through size.
    if(i>size) i = size;  if (i<0) i=0;
    if(j>size) j = size;  if (j<0) j=0;
    x=i; y=j;
  }
  // An inserter for plot.
  friend ostream &operator<<(ostream &stream, plot o);
};

ostream &operator<<(ostream &stream, plot o)
{
  register int i, j;

  for(j=size; j>=0; j--) {
    stream << j;
    if(j == o.y) {
      for(i=0; i<o.x; i++) stream << "  ";
      stream <<  '*';  
    } 
    stream << "\n"; 
  }

  for(i=0; i<=size; i++) stream << " " << i;
  stream << "\n";

  return stream;
}

int main()
{
  plot a(2, 3), b(1, 1);

  // output first using cout
  cout << "Output using cout:\n";
  cout << a << "\n" << b << "\n\n";

  char str[200];  // now use RAM-based I/O
  ostrstream outs(str, sizeof(str));

  // now output using outs and in-RAM formatting
  outs << a << b << ends;

  cout << "Output using in-RAM formatting:\n";
  cout << str;
}

listing 1
// Function template example.
#include <iostream.h>

// This is a function template.
template <class X> void swap(X &a, X &b)
{
  X temp;

  temp = a;
  a = b;
  b = temp;
}

int main()
{
  int i=10, j=20;
  float x=10.1, y=23.3;
  char a='x', b='z';

  cout << "Original i, j: " << i << ' ' << j << endl;
  cout << "Original x, y: " << x << ' ' << y << endl;
  cout << "Original a, b: " << a << ' ' << b << endl;

  swap(i, j); // swap integers
  swap(x, y); // swap floats
  swap(a, b); // swap chars

  cout << "Swapped i, j: " << i << ' ' << j << endl;
  cout << "Swapped x, y: " << x << ' ' << y << endl;
  cout << "Swapped a, b: " << a << ' ' << b << endl;

  return 0;
}

listing 2
template <class X> void swap(X &a, X &b)

listing 3
#include <iostream.h>

template <class type1, class type2>
void myfunc(type1 x, type2 y)
{
  cout << x << ' ' << y << endl;
}

int main()
{
  myfunc(10, "hi");

  myfunc(0.23, 10L);

  return 0;
}


listing 4
// Overriding a template function.
#include <iostream.h>

template <class X> void swap(X &a, X &b)
{
  X temp;

  temp = a;
  a = b;
  b = temp;
}

// This overrides the generic version of swap().
void swap(int &a, int &b)
{
  int temp;

  temp = a;
  a = b;
  b = temp;
  cout << "Inside overloaded swap(int &, int &).\n";
}

int main()
{
  int i=10, j=20;
  float x=10.1, y=23.3;
  char a='x', b='z';

  cout << "Original i, j: " << i << ' ' << j << endl;
  cout << "Original x, y: " << x << ' ' << y << endl;
  cout << "Original a, b: " << a << ' ' << b << endl;

  swap(i, j); // this calls the explicitly overloaded swap()
  swap(x, y); // swap floats
  swap(a, b); // swap chars

  cout << "Swapped i, j: " << i << ' ' << j << endl;
  cout << "Swapped x, y: " << x << ' ' << y << endl;
  cout << "Swapped a, b: " << a << ' ' << b << endl;

  return 0;
}

listing 5
#include <iostream.h>
#include <math.h>

void myfunc(int i)
{
  cout << "value is: " << i << "\n";
}

void myfunc(double d)
{
  double intpart;
  double fracpart;

  fracpart = modf(d, &intpart);
  cout << "Fractional part: " << fracpart;
  cout << "\n";
  cout << "Integer part: " << intpart;
}

int main()
{
  myfunc(1);
  myfunc(12.2);

  return 0;
}

listing 6
// Demonstrate a generic stack class.
#include <iostream.h>

const int SIZE = 100;

// This creates the generic class stack.
template <class SType> class stack {
  SType stck[SIZE];
  int tos;
public:
  stack();
  ~stack();
  void push(SType i);
  SType pop();
};

// stack's constructor function.
template <class SType> stack<SType>::stack()
{
  tos = 0;
  cout << "Stack Initialized\n";
}

/* stack's destructor function.
   This function is not required.  It is included
   for illustration only. */
template <class SType> stack<SType>::~stack()
{
  cout << "Stack Destroyed\n";
}

// Push an object onto the stack.
template <class SType> void stack<SType>::push(SType i)
{
  if(tos==SIZE) {
    cout << "Stack is full.\n";
    return;
  }
  stck[tos] = i;
  tos++;
}

// Pop an object off the stack.
template <class SType> SType stack<SType>::pop()
{
  if(tos==0) {
    cout << "Stack underflow.\n";
    return 0;
  }
  tos--;
  return stck[tos];
}

int main()
{
  stack<int> a; // create integer stack
  stack<double> b; // create a double stack
  stack<char> c; // create a character stack

  int i;

  // use the integer and double stacks
  a.push(1);
  b.push(99.3);
  a.push(2);
  b.push(-12.23);

  cout << a.pop() << " ";
  cout << a.pop() << " ";
  cout << b.pop() << " ";
  cout << b.pop() << "\n";

  // demonstrate the character stack
  for(i=0; i<10; i++) c.push((char) 'A'+i);
  for(i=0; i<10; i++) cout << c.pop();
  cout << "\n";

  return 0;
}

listing 7
stack<int> a; // create integer stack
stack<double> b; // create a double stack
stack<char> c; // create a character stack

listing 8
stack<char *> chrptrstck;

listing 9
struct addr {
  char name[40];
  char street[40];
  char city[30];
  char state[3];
  char zip[12];
}

listing 10
stack<addr> obj;

listing 11
/* This example uses two generic data types in a
   class definition.
*/
#include <iostream.h>

template <class Type1, class Type2> class myclass
{
  Type1 i;
  Type2 j;
public:
  myclass(Type1 a, Type2 b) { i = a; j = b; }
  void show() { cout << i << ' ' << j << '\n'; }
};

int main()
{
  myclass<int, double> ob1(10, 0.23);
  myclass<char, char *> ob2('X', "This is a test");

  ob1.show(); // show int, double
  ob2.show(); // show char, char *
 
  return 0;
}

listing 12
// A simple exception handling example.
#include <iostream.h>

int main()
{
  cout << "Start\n";

  try { // start a try block
    cout << "Inside try block\n";
    throw 100; // throw an error
    cout << "This will not execute";
  }
  catch (int i) { // catch an error
    cout << "Caught an exception -- value is: ";
    cout << i << "\n";
  }

  cout << "End";

  return 0;
}

listing 13
// This example will not work.
#include <iostream.h>

int main()
{
  cout << "Start\n";

  try { // start a try block
    cout << "Inside try block\n";
    throw 100; // throw an error
    cout << "This will not execute";
  }
  catch (double i) { // Won't work for an int exception
    cout << "Caught an exception -- value is: ";
    cout << i << "\n";
  }

  cout << "End";

  return 0;
}

listing 14
/* Throwing an exception from a function outside the
   try block. 
*/
#include <iostream.h>

void Xtest(int test)
{
  cout << "Inside Xtest, test is: " << test << "\n";
  if(test) throw test;
}

int main()
{
  cout << "Start\n";

  try { // start a try block
    cout << "Inside try block\n";
    Xtest(0);
    Xtest(1);
    Xtest(2);
  }
  catch (int i) { // catch an error
    cout << "Caught an exception -- value is: ";
    cout << i << "\n";
  }

  cout << "End";

  return 0;
}

listing 15
#include <iostream.h>

// A try/catch can be inside a function other than main().
void Xhandler(int test)
{
  try{
    if(test) throw test;
  }
  catch(int i) {
    cout << "Caught Exception #: " << i << '\n';
  }
}

int main()
{
  cout << "Start\n";

  Xhandler(1);
  Xhandler(2);
  Xhandler(0);
  Xhandler(3);

  cout << "End";

  return 0;
}


listing 16
#include <iostream.h>

// Different types of exceptions can be caught.
void Xhandler(int test)
{
  try{
    if(test) throw test;
    else throw "Value is zero";
  }
  catch(int i) {
    cout << "Caught Exception #: " << i << '\n';
  }
  catch(char *str) {
    cout << "Caught a string: ";
    cout << str << '\n';
  }
}

int main()
{
  cout << "Start\n";

  Xhandler(1);
  Xhandler(2);
  Xhandler(0);
  Xhandler(3);

  cout << "End";

  return 0;
}

listing 17
// This example catches all exceptions.
#include <iostream.h>

void Xhandler(int test)
{
  try{
    if(test==0) throw test; // throw int
    if(test==1) throw 'a'; // throw char
    if(test==2) throw 123.23; // throw double
  }
  catch(...) { // catch all exceptions
    cout << "Caught One!\n";
  }
}

int main()
{
  cout << "Start\n";

  Xhandler(0);
  Xhandler(1);
  Xhandler(2);

  cout << "End";

  return 0;
}


listing 18
// Restricting function throw types.
#include <iostream.h>

// This function can only throw ints, chars, and doubles.
void Xhandler(int test) throw(int, char, double)
{
  if(test==0) throw test; // throw int
  if(test==1) throw 'a'; // throw char
  if(test==2) throw 123.23; // throw double
}

int main()
{
  cout << "start\n";

  try{
    Xhandler(0); // also, try passing 1 and 2 to Xhandler()
  }
  catch(int i) {
    cout << "Caught an integer\n";
  }
  catch(char c) { 
    cout << "Caught char\n";
  }
  catch(double d) { 
    cout << "Caught double\n";
  }

  cout << "end";

  return 0;
}

listing 19
// This function can throw NO exceptions!
void Xhandler(int test) throw()
{
  /* The following statements no longer work.  Instead,
     they will cause an abnormal program termination. */
  if(test==0) throw test; 
  if(test==1) throw 'a'; 
  if(test==2) throw 123.23; 
}


listing 20
// Example of "rethrowing" an exception.
#include <iostream.h>

void Xhandler()
{
  try {
    throw "hello"; // throw a char *
  }
  catch(char *) { // catch a char *
    cout << "Caught char * inside Xhandler\n";
    throw ; // rethrow char * out of function
  }
}

int main()
{
  cout << "Start\n";

  try{
    Xhandler();
  }
  catch(char *) {
    cout << "Caught char * inside main\n";
  }

  cout << "End";

  return 0;
}

listing 21
#include <iostream.h>

void divide(double a, double b);

int main()
{
  double i, j;

  do {
    cout << "Enter numerator (0 to stop): ";
    cin >> i;
    cout << "Enter denominator: ";
    cin >> j;
    divide(i, j);
  } while(i != 0);

  return 0;
}

void divide(double a, double b)
{
  try {
    if(!b) throw b; // check for divide-by-zero   
    cout << "Result: " << a/b << endl;
  }
  catch (double b) {
    cout << "Can't divide by zero.\n";
  }
}

listing 22
// An example that uses typeid.
#include <iostream.h>
#include <typeinfo.h>

class BaseClass {
  int a, b;
  virtual void f() {}; // make BaseClass polymorphic
};

class Derived1: public BaseClass {
  int i, j;
};

class Derived2: public BaseClass {
  int k;
};

int main()
{
  int i;
  BaseClass *p, baseob;
  Derived1 ob1;
  Derived2 ob2;

  // First, display type name of a built in type.
  cout << "Typeid of i is ";
  cout << typeid(i).name() << endl;
  
  // Demonstrate typeid with polymorphic types.
  p = &baseob;
  cout << "p is pointing to an object of type ";
  cout << typeid(*p).name() << endl;

  p = &ob1;
  cout << "p is pointing to an object of type ";
  cout << typeid(*p).name() << endl;

  p = &ob2;
  cout << "p is pointing to an object of type ";
  cout << typeid(*p).name() << endl;

  return 0;
}

listing 23
#include <iostream.h>

#define NUM_EMPLOYEES 4

class employee {
public:
  employee() { cout << "Constructing employee\n"; }
  virtual void print() = 0;
};

class programmer : public employee {
public:
  programmer() { cout << "Constructing programmer\n"; }
  void print() { cout << "Printing programmer object\n"; }
};

class salesperson : public employee {
public:
  salesperson() { cout << "Constructing salesperson\n"; }
  void print() { cout << "Printing salesperson object\n"; }
};

class executive : public employee {
public:
  executive() { cout << "Constructing executive\n"; }
  void print() { cout << "Printing executive object\n"; }
};

int main() {
  programmer prog1, prog2;
  executive ex;
  salesperson sp;

  // Initialize the array of employees
  employee *e[NUM_EMPLOYEES];
  e[0] = &prog1;
  e[1] = &sp;
  e[2] = &ex;
  e[3] = &prog2;

  // See which ones are programmers.
  for(int i = 0; i < NUM_EMPLOYEES; i++) {
    programmer *pp = dynamic_cast<programmer*>(e[i]);
    if(pp) {
      cout << "Is a programmer\n";
      pp->print();
    }
    else {
      cout << "Not a programmer\n";
    }
  }
}

listing 24
// An example that uses reinterpret_cast.
#include <iostream.h>

int main()
{
  int i;
  char *p = "This is a string";

  i = reinterpret_cast<int> (p); // cast pointer to integer

  cout << i;

  return 0;
}

listing 1
#include <iostream.h>
#include <except.h>

int main()
{
  int *p;

  try { 
    p = new int; // allocate memory for int
  } catch (xalloc xa) {
    cout << "Allocation failure.\n";
    return 1;
  }

  *p = 20; // assign that memory the value 20
  cout << *p; // prove that it works by displaying value

  delete p; // free the memory

  return 0;
}

listing 2
#include <iostream.h>
#include <except.h>

int main()
{
  int *p;

  try {
    p = new int (99);  // initialize with 99
  } catch(xalloc xa) {
    cout << "Allocation failure.\n";
    return 1;
  }

  cout << *p;

  delete p;

  return 0;
}

listing 3
#include <iostream.h>
#include <except.h>

int main()
{
  float *p;
  int i;

  try {
    p = new float [10]; // get a 10-element array
  } catch(xalloc xa) {
    cout << "Allocation failure.\n";
    return 1;
  }

  // assign the values 100 through 109
  for(i=0; i<10; i++) p[i] = 100.00 + i;

  // display the contents of the array
  for(i=0; i<10; i++)  cout << p[i] << " ";

  delete [] p; // delete the entire array

  return 0;
}

listing 4
#include <iostream.h>
#include <except.h>

class three_d {
public:
  int x, y, z; // 3-d coordinates
  three_d(int a, int b, int c);
  ~three_d() {cout << "Destructing\n";}
} ;

three_d::three_d(int a, int b, int c)
{
  cout << "Constructing\n";
  x = a;
  y = b;
  z = c;
}

// Display X, Y, Z coordinates - three_d inserter.
ostream &operator<<(ostream &stream, three_d &obj)
{
  stream << obj.x << ", ";
  stream << obj.y << ", ";
  stream << obj.z << "\n";
  return stream;  // return the stream
}

int main()
{
  three_d *p;

  try {
    p = new three_d (5, 6, 7);
  } catch(xalloc xa) {
    cout << "Allocation failure.\n";
    return 1;
  }

  cout << *p;

  delete p;

  return 0;
}

listing 5
#include <iostream.h>
#include <except.h>

class three_d {
public:
  int x, y, z; // 3-d coordinates
  three_d(int a, int b, int c) ;
  three_d(){cout << "Constructing\n";} // needed for arrays
  ~three_d() {cout << "Destructing\n";}
};

three_d::three_d(int a, int b, int c)
{
  cout << "Constructing\n";
  x = a;
  y = b;
  z = c;
}

// Display X, Y, Z coordinates - three_d inserter.
ostream &operator<<(ostream &stream, three_d &obj)
{
  stream << obj.x << ", ";
  stream << obj.y << ", ";
  stream << obj.z << "\n";
  return stream;  // return the stream
}

int main()
{
  three_d *p;
  int i;

  try {
    p = new three_d [10];
  } catch (xalloc xa) {
    cout << "Allocation failure.\n";
    return 1;
  }

  for(i=0; i<10; i++) {
    p[i].x = 1;
    p[i].y = 2;
    p[i].z = 3;
  }

  for(i=0; i<10; i++) cout << *p;

  delete [] p;

  return 0;
}

listing 6
 // Demonstrate a new alternative.
#include <new.h>
#include <iostream.h>

int main()
{
  double *p;

  // have new return null on failure
  set_new_handler(0);

  // this will eventually run out of memory
  do {
    p = new double[100000];
    if(p) cout << "Allocation OK\n";
    else cout << "Allocation Error\n";
  } while(p);

  return 0;
}

listing 7
#include <iostream.h>

class counter {
  static int count;
public:
  void setcount(int i) {count = i;};
  void showcount() {cout << count << " ";}
};

int counter::count; // define count

int main()
{
  counter a, b;

  a.showcount(); // prints 0
  b.showcount(); // prints 0

  a.setcount(10); // set static count to 10

  a.showcount(); // prints 10
  b.showcount(); // also prints 10

  return 0;
}

listing 8
#include <iostream.h>

enum access_t {shared, in_use, locked, unlocked};

// a scarce resource control class
class access {
  static enum access_t acs;
  // ...
public:
  static void set_access(enum access_t a) {acs = a;}
  static enum access_t get_access()
  {
    return acs;
  }
  // ...
};

enum access_t access::acs; // define acs

int main()
{
  access  obj1, obj2;

  access::set_access(locked); // call using class name

  // ... intervening code

  // see if obj2 can access resource
  if(obj2.get_access()==unlocked) { // call using object
    access::set_access(in_use);  // call using class name
    cout << "Access resource.\n";
  }
  else cout << "Locked out.\n";

  // ...

  return 0;
}

listing 9
// This program contains an error and will not compile.
#include <iostream.h>

enum access_t {shared, in_use, locked, unlocked};

// a scarce resource control class
class access {
  static enum access_t acs;
  int i;  // non-static
  // ...
public:
  static void set_access(enum access_t a) {acs = a;}
  static enum access_t get_access()
  {
    i = 100; // this will not compile
    return acs;
  }
  // ...
};

enum access_t access::acs; // define acs

int main()
{
  access  obj1, obj2;

  access::set_access(locked); // call using class name

  // ... intervening code

  // see if obj2 can access resource
  if(obj2.get_access()==unlocked) { // call using object
    access::set_access(in_use); // call using class name
    cout << "Access resource.\n";
  }
  else cout << "Locked out.\n";

  // ...
}

listing 10
// This program contains an error and will not compile.
#include <iostream.h>

class base {
public:
  int i;
};

// d1 inherits base.
class d1 :  public base {
public:
  int j;
};

// d2 inherits base.
class d2 : public base {
public:
  int k;
};

/* d3 inherits both d1 and d2. This means that there
   are two copies of base in d3! */
class d3 : public d1, public d2 {
public:
  int m;
};

int main()
{
  d3 d;

  d.i = 10;  // this is ambiguous, which i???
  d.j = 20;
  d.k = 30;
  d.m = 40;


  // also ambiguous, which i???
  cout << d.i << " ";
  cout << d.j << " " << d.k << " ";
  cout << d.m;

  return 0;
}

listing 11
d.i = 20;

listing 12
#include <iostream.h>

class base {
public:
  int i;
};

// d1 inherits base.
class d1 :  public base {
public:
  int j;
};

// d2 inherits base.
class d2 : public base {
public:
  int k;
};

/* d3 inherits both d1 and d2. This means that there
   are two copies of base in d3! */
class d3 : public d1, public d2 {
public:
  int m;
};

int main()
{
  d3 d;

  d.d2::i = 10; // scope resolved, using d2's i
  d.j = 20;
  d.k = 30;
  d.m = 40;


  // scope resolved, using d2's i
  cout << d.d2::i << " ";
  cout << d.j << " " << d.k << " ";
  cout << d.m;

  return 0;
}

listing 13
#include <iostream.h>

class base {
public:
  int i;
};

// d1 inherits base as virtual.
class d1 : virtual public base {
public:
  int j;
};

// d2 inherits base as virtual.
class d2 : virtual public base {
public:
  int k;
};

/* d3 inherits both d1 and d2. However, now there is
   only one copy of base in d3. */
class d3 : public d1, public d2 {
public:
  int m;
};

int main()
{
  d3 d;

  d.i = 10; // no longer ambiguous
  d.j = 20;
  d.k = 30;
  d.m = 40;

  cout << d.i << " "; // no longer ambiguous
  cout << d.j << " " << d.k << " ";
  cout << d.m;

  return 0;
}

listing 14
// define a class of type d1
d1 myclass;

myclass.i = 100;

listing 15
class X {
public:
  int f1() const; // const member function
  void f2(int a) volatile; // volatile member function
  char *f3() const volatile; // const volatile member function
};

listing 16
// Print the screen.
#include <iostream.h>

int main()
{
  asm int 5;
  return 0;
}

listing 17
#include <iostream.h>

int main()
{
  // this effectively does nothing
  asm {
    push ds
    pop ds
  }

  return 0;
}

listing 18
#include <iostream.h>

extern "C" void myCfunc(void);

int main()
{
  myCfunc();

  return 0;
}

// This will link as a C function.
void myCfunc(void)
{
  cout << "This links as a C function.\n";
}

listing 19
#include <iostream.h>

class myclass {
public:
  int sum;
  void myclass::sum_it(int x);
};

void myclass::sum_it(int x) {
  int i;

  sum = 0;
  for(i=x; i; i--) sum += i;
}

int main()
{
  int myclass::*dp;  // pointer to an integer class member
  void (myclass::*fp)(int x); // pointer to member function
  myclass c;

  dp = &myclass::sum;  // get address of data
  fp = &myclass::sum_it; // get address of function

  (c.*fp)(7);  // compute summation of 7
  cout << "summation of 7 is " << c.*dp;

  return 0;
}

listing 20
#include <iostream.h>

class myclass {
public:
  int sum;
  void myclass::sum_it(int x);
};

void myclass::sum_it(int x) {
  int i;

  sum = 0;
  for(i=x; i; i--) sum += i;
}

int main()
{
  int myclass::*dp;  // pointer to an integer class member
  void (myclass::*fp)(int x); // pointer to member function
  myclass *c, d; // c is now a pointer to an object

  c = &d; // give c the address of an object

  dp = &myclass::sum;  // get address of data
  fp = &myclass::sum_it; // get address of function

  (c->*fp)(7);  // now, use ->* to call function
  cout << "summation of 7 is " << c->*dp; // use ->*

  return 0;
}

listing 21
operator int() { return x * y * z; }

listing 22
#include <iostream.h>

class three_d {
  int x, y, z; // 3-d coordinates
public:
  three_d(int a, int b, int c) {x=a; y=b, z=c;}

  three_d operator+(three_d op2) ;
  friend ostream &operator<<(ostream &stream, three_d &obj);

  operator int() {return x*y*z;}
} ;

// Display X, Y, Z coordinates - three_d inserter.
ostream &operator<<(ostream &stream, three_d &obj)
{
  stream << obj.x << ", ";
  stream << obj.y << ", ";
  stream << obj.z << "\n";
  return stream;  // return the stream
}

three_d three_d::operator+(three_d op2)
{
  three_d temp(0, 0, 0);

  temp.x = x+op2.x;  // these are integer additions
  temp.y = y+op2.y;  // and the + retains its original
  temp.z = z+op2.z;  // meaning relative to them
  return temp;
}

int main()
{
  three_d a(1, 2, 3), b(2, 3, 4);

  cout << a << b;

  cout <<  b+100;  // displays 124 because of conversion to int
  cout << "\n";
  cout << a+b;  // displays 3, 5, 7 - no conversion

  return 0;
}

listing 23
myclass x = y; // initialization
func(x); // parameter passing
y = func();  // receiving temporary object

listing 24
/* This program creates a "safe" array class.  Since space
   for the array is allocated using new, a copy constructor
   is provided to allocate memory when one array object is
   used to initialize another.
*/
#include <iostream.h>
#include <stdlib.h>

class array {
  int *p;
  int size;
public:
  array(int sz) {
    p = new int[sz];
    if(!p) exit(1);
    size = sz;
  }
  ~array() {delete [] p;}

  // copy constructor
  array(const array &a);

  void put(int i, int j) {
    if(i>=0 && i<size) p[i] = j;
  }
  int get(int i) {
    return p[i];
  }
};

// copy constructor
array::array(const array &a) {
  int i;

  p = new int[a.size];
  if(!p) exit(1);
  for(i=0; i<a.size; i++) p[i] = a.p[i];
}

int main()
{
  array num(10);
  int i;

  for(i=0; i<10; i++) num.put(i, i);
  for(i=9; i>=0; i--) cout << num.get(i);
  cout << "\n";

  // create another array and initialize with num
  array x(num);  // invokes copy constructor
  for(i=0; i<10; i++) cout << x.get(i);

  return 0;
}

listing 25
array a(10);
 .
 .
 .
array b(10);

b = a; // does not call copy constructor

listing 26
#include <iostream.h>

class B_class {
public:
  int i, j;
};

class D_class : private B_class {
public:
  // access declaration
  B_class::i;  // i from B_class is now public again

  int k;
} ;

int main()
{
  D_class d;

  d.i = 10;  // legal because i is made public in D_class
  d.k = 20;
// d.j = 30; // illegal because j is private in D_class

  cout << d.i * d.k;

  return 0;
}

listing 27
namespace MyNameSpace {
  int i, k;
  void myfunc(int j) { cout << j; }
}

listing 28
MyNameSpace::i = 10;

listing 29
using MyNameSpace::k; // only k is made visible
k = 10; // OK because k is visible

using namespace MyNameSpace; // all members of MyNameSpace are visible
i = 10; // OK because all members of MyNameSpace are now visible

listing 30
#include <iostream>

listing 31
#include <fstream>

listing 32
class MyClass {
  int i;
public:
  MyClass(int j) {i = j;}
  // ...
};

listing 33
MyClass ob1(1);
MyClass ob2 = 10;

listing 34
MyClass ob2 = 10;

listing 35
MyClass ob2(10);

listing 36
class MyClass {
  int i;
public:
  explicit MyClass(int j) {i = j;}
  // ...
};

listing 37
MyClass ob(110); 

listing 38
// A short example that demonstrates vector.
#include <iostream.h>
#include <vector.h>

// must use std namespace for vector
using namespace std;

int main()
{
  vector<int> v; // create zero-length vector

  cout << "size = " << v.size() << endl;

  /* put values onto end of vector
     vector will grow as needed. */
  for(int i=0; i<10; i++) v.push_back(i);

  cout << "size now = " << v.size() << endl;

  // can access vector contents using subscripting
  for(int i=0; i<10; i++) cout << v[i] << " ";
  cout << endl;

  // Can access vector's first and last element
  cout << "front = " << v.front() << endl;
  cout << "back = " << v.back() << endl;

  // access via iterator
  vector<int>::iterator p = v.begin();
  while(p != v.end()) {
    cout << *p << " ";
    p++;
  }

  return 0;
}


listing 39
int f();

listing 40
int f();

int f(void);

listing 1
#include <iostream.h>

void sqr_it(int n);

int main() {
  int i;

  for(i=0; i<10; i++) {
    cout << i << " ";
    sqr_it(i);
  }
  return 0;
}

void sqr_it(int n)
{
  cout << n*n << " ";
}

listing 2
cout << n*n << " ";

listing 3
average,F5

listing 4
#include <string.h>

struct inventory {
  char item[10];
  int  count;
  float cost;
} sample;

int main()
{
  strcpy(sample.item, "hammer");
  sample.count = 100;
  sample.cost = 3.95;

  return 0;
}

listing 5
sample: {"hammer", 100, 3.95}
sample,R: {item: "hammer", count: 100, cost: 3.95}

listing 6
#include <string.h>

class inventory {
  int i;  // private data
public:
  inventory() {i=100;}
  char item[10];
  int  count;
  float cost;
} sample;

int main()
{
  strcpy(sample.item, "hammer");
  sample.count = 100;
  sample.cost = 3.95;

  return 0;
}

listing 7
sample,R: {i: 100, item: "hammer", count: 100, cost: 3.95}

listing 8
void f1()
{
  int count;
  .
  .
  .
}

void f2()
{
  int count;
  .
  .
  .
}

listing 9
f1.count
f2.count

listing 10
#include <iostream.h>
void f1(), f2(int i);

int main()
{
  f1();
  return 0;
}

void f1()
{
  int i;

  for(i=0; i<10; i++) f2(i);
}

void f2(int i)
{
  cout << "in f2, value is " << i << " ";
}

